/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 912c1f39-a16e-4f86-a001-cd74e823f2bc

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We prove that an injective polynomial map from K^n to K^n, where K is an algebraically closed field of characteristic zero, has a polynomial inverse. This is a strengthening of the Ax-Grothendieck theorem, which asserts surjectivity. The proof proceeds by showing that the pullback map on the coordinate rings is surjective, which implies the existence of a polynomial inverse.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 72b5e1c4-8a80-44ad-a0ce-120577977d92

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 10c49653-35e2-4e3a-ad63-7fa1a00cd764

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: ff624c39-09df-49b8-ab10-e0033bd202b1

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 8692a9f9-2f92-42e6-aaf9-3ec761a2e4c0

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 3d5611d6-857b-49bc-bb2d-c1a1d6ce2204

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 9aa97419-54d9-4087-a1a7-a4a7ff958742

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 8b0d0bc5-b95f-4721-b4c1-b04d273cd66f

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: a35c4045-d47e-4458-8a26-982f6f06af47

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 40bd30c0-6804-4414-880b-8906ebcf5547

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 21a14406-9fb2-4da5-a80a-fdd2c72f7c40

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: c0fd9f1b-0378-40a8-9058-bef95dcc4040

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: aca9f597-350d-4f41-9574-c84e33c298c3

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: db39a677-5156-43c4-8d96-628bcd4a0e71

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 32828c01-6d14-468b-a470-fb27a27e6803

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: b7dfbd65-661f-46d4-861f-d8c5021597c2

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
A map f : K^n -> K^n is a polynomial map if there exist polynomials p_1, ..., p_n such that f(v)_i = p_i(v).
-/
def IsPolyMap {K : Type*} [CommSemiring K] {n : Type*} [Fintype n] (f : (n → K) → (n → K)) : Prop :=
  ∃ p : n → MvPolynomial n K, ∀ v, f v = fun i => MvPolynomial.eval v (p i)

/-
Any injective polynomial map from K^n to K^n is surjective, where K is an algebraically closed field.
-/
theorem injective_poly_map_surjective {K : Type*} [Field K] [IsAlgClosed K] {n : Type*} [Fintype n]
    (f : (n → K) → (n → K)) (hf : IsPolyMap f) (hinj : Function.Injective f) :
    Function.Surjective f := by
      -- By the Ax-Groth �end�ieck theorem, any injective polynomial map from $K^n$ to $K^n$ is surjective.
      have h_ax_grothendieck : ∀ (f : (n → K) → (n → K)) (hf : IsPolyMap f) (hinj : Function.Injective f), Function.Surjective f := by
        intro f hf h_inj
        obtain ⟨p, hp⟩ := hf
        have h_poly : ∀ (p : n → MvPolynomial n K), Function.Injective (fun v => fun i => MvPolynomial.eval v (p i)) → Function.Surjective (fun v => fun i => MvPolynomial.eval v (p i)) := by
          exact?
        exact (by
        convert h_poly p _ using 1 ; aesop_cat;
        exact fun v w h => h_inj <| by aesop;)
      exact h_ax_grothendieck f hf hinj

/-
The pullback of a polynomial map is the ring homomorphism induced by precomposition. If the polynomial map is surjective, the pullback is injective.
-/
def pullback {K : Type*} [CommSemiring K] {n : Type*} [Fintype n]
    (p : n → MvPolynomial n K) : MvPolynomial n K →+* MvPolynomial n K :=
  MvPolynomial.eval₂Hom (algebraMap K (MvPolynomial n K)) p

theorem pullback_eval {K : Type*} [CommSemiring K] {n : Type*} [Fintype n]
    (p : n → MvPolynomial n K) (q : MvPolynomial n K) (v : n → K) :
    MvPolynomial.eval v (pullback p q) = MvPolynomial.eval (fun i => MvPolynomial.eval v (p i)) q := by
      -- Applying the definition of the pullback, we get:
      simp [pullback];
      induction q using MvPolynomial.induction_on <;> aesop

theorem pullback_injective {K : Type*} [Field K] [IsAlgClosed K] {n : Type*} [Fintype n]
    (p : n → MvPolynomial n K) (h_surj : Function.Surjective (fun v i => MvPolynomial.eval v (p i))) :
    Function.Injective (pullback p) := by
      intro P Q hPQ
      have h_eval : ∀ v : n → K, MvPolynomial.eval v (P) = MvPolynomial.eval v (Q) := by
        intro v
        have h_eval : MvPolynomial.eval (fun i => MvPolynomial.eval v (p i)) P = MvPolynomial.eval (fun i => MvPolynomial.eval v (p i)) Q := by
          convert congr_arg ( MvPolynomial.eval v ) hPQ using 1;
          · exact?;
          · unfold pullback; simp +decide [ MvPolynomial.eval₂_eq' ] ;
            clear hPQ h_surj;
            induction Q using MvPolynomial.induction_on <;> aesop;
        obtain ⟨ w, hw ⟩ := h_surj v;
        convert congr_arg ( fun f => MvPolynomial.eval w f ) hPQ using 1 <;> simp +decide [ ← hw ];
        · exact?;
        · exact?;
      exact MvPolynomial.funext fun v => by simpa using h_eval v;

/-
A surjective endomorphism of a Noetherian ring is injective.
-/
theorem RingHom.injective_of_surjective_of_isNoetherianRing {R : Type*} [CommRing R] [IsNoetherianRing R]
    (f : R →+* R) (hf : Function.Surjective f) : Function.Injective f := by
      by_contra h_not_injective;
      -- Let $I_n = \ker(f^n)$. This is an increasing chain of ideals.
      set I : ℕ → Ideal R := fun n => RingHom.ker (f^n);
      -- Since $R$ is Noetherian, the chain of ideals $I_n$ stabilizes, so there exists $n$ such that $I �_n� = I_{n+1}$.
      obtain ⟨n, hn⟩ : ∃ n, I n = I (n + 1) := by
        -- By the ascending chain condition, there � exists� an $n$ such that $I_n = I_{n+1}$.
        have h_ascending_chain : ∃ n, ∀ m ≥ n, I m = I n := by
          have h_ascending_chain : ∀ n, I n ≤ I (n + 1) := by
            intro n x hx;
            simp +zetaDelta at *;
            erw [ Function.iterate_succ_apply', hx, map_zero ];
          -- Since $R$ is Noetherian, the � chain� of� ideals $I_n$ must stabilize by the ascending chain condition.
          have h_stabilize : IsNoetherian R R := by
            infer_instance;
          have := h_stabilize.wf.has_min;
          contrapose! this;
          exact ⟨ Set.range I, ⟨ _, Set.mem_range_self 0 ⟩, fun x hx => by rcases hx with ⟨ n, rfl ⟩ ; rcases this n with ⟨ m, hm₁, hm₂ ⟩ ; exact ⟨ _, Set.mem_range_self m, lt_of_le_of_ne ( by exact monotone_nat_of_le_succ h_ascending_chain hm₁ ) hm₂.symm ⟩ ⟩;
        exact ⟨ h_ascending_chain.choose, Eq.symm ( h_ascending_chain.choose_spec _ ( Nat.le_succ _ ) ) ⟩;
      -- Let $x \in \ker f$. Since $f$ is surjective, $f^n$ is surjective.
      have h_surjective_fn : Function.Surjective (f ^ n) := by
        exact Function.Surjective.iterate hf n;
      simp_all +decide [ Ideal.ext_iff ];
      refine' h_not_injective ( fun x y hxy => _ );
      -- Since $f$ is sur �jective�, there exists $z$ such that $f^n(z) = x - y$.
      obtain ⟨z, hz⟩ : ∃ z, (f ^ n) z = x - y := by
        exact?;
      specialize hn z; simp_all +decide [ pow_succ, Function.iterate_succ_apply' ] ;
      simp +zetaDelta at *;
      exact eq_of_sub_eq_zero ( hz.symm.trans ( hn.mpr ( by erw [ Function.iterate_succ_apply' ] ; aesop ) ) )

/-
If the pullback of a polynomial map is surjective, it is an isomorphism.
-/
theorem pullback_isIso_of_surjective {K : Type*} [Field K] {n : Type*} [Fintype n]
    (p : n → MvPolynomial n K) (h_surj : Function.Surjective (pullback p)) :
    Function.Bijective (pullback p) := by
  constructor
  · apply RingHom.injective_of_surjective_of_isNoetherianRing
    · exact h_surj
  · exact h_surj

/-
If the pullback is surjective, the polynomial map has a polynomial inverse.
-/
theorem poly_inverse_of_pullback_surjective {K : Type*} [Field K] {n : Type*} [Fintype n]
    (p : n → MvPolynomial n K) (h_surj : Function.Surjective (pullback p)) :
    ∃ q : n → MvPolynomial n K, ∀ v, (fun i => MvPolynomial.eval v (q i)) = Function.invFun (fun v i => MvPolynomial.eval v (p i)) v := by
  -- Since pullback p is bijective, it has an inverse ring homomorphism.
  let ϕ := pullback p
  have h_bij : Function.Bijective ϕ := pullback_isIso_of_surjective p h_surj
  let ψ := RingEquiv.ofBijective ϕ h_bij
  -- Let q_i = ψ (X_i)
  let q : n → MvPolynomial n K := fun i => ψ.symm (MvPolynomial.X i)
  use q
  intro v
  -- We need to show q(v) = f⁻¹(v)
  -- Let f(v) = w. We want q(w) = v.
  -- q(w)_i = eval w (q_i) = eval w (ψ⁻¹(X_i))
  -- We know ψ(q_i) = X_i.
  -- ψ is pullback p.
  -- So pullback p q_i = X_i.
  -- eval v (pullback p q_i) = eval v (X_i) = v_i
  -- eval (f v) q_i = v_i
  -- So q(f(v)) = v.
  -- This shows q is a left inverse of f.
  -- Since f is bijective (implied by pullback being iso? Yes).
  -- If pullback p is iso, then f is bijective.
  -- Proof:
  -- f is dominant (since pullback injective).
  -- f is closed embedding?
  -- Actually, we can just show q is the inverse directly.
  -- q(f(v)) = v.
  -- Also f(q(v)) = v?
  -- eval (q v) p_i = ?
  -- pullback q p_i = ?
  -- We know pullback p (q_i) = X_i.
  -- This implies pullback p \circ pullback q = id?
  -- pullback q (p_i) = ?
  -- We have q_i = pullback p^{-1} (X_i).
  -- So pullback p (q_i) = X_i.
  -- This means q \circ p = id as maps on polynomials?
  -- No, pullback (q \circ p) = pullback p \circ pullback q.
  -- We want pullback p \circ pullback q = id.
  -- We know pullback p (q_i) = X_i.
  -- pullback p (pullback q (X_i)) = pullback p (q_i) = X_i.
  -- So pullback p \circ pullback q acts as identity on generators X_i.
  -- So pullback p \circ pullback q = id.
  -- Since pullback p is iso, pullback q is its inverse.
  -- So pullback q \circ pullback p = id.
  -- So q \circ p = id and p \circ q = id (as polynomial maps).
  -- So q is the inverse of p.
  -- So q is the inverse of f.
  -- By definition of $q$, we know that for any $v : n → K$, $v (i) = \phi(q_i)(v)$.
  have h_inv : ∀ v : n → K, ∀ i : n, v i = MvPolynomial.eval v (ψ (q i)) := by
    aesop;
  refine' funext fun i => _;
  rw [ eq_comm, Function.invFun ];
  split_ifs with h;
  · have := h.choose_spec;
    convert h_inv h.choose i using 1;
    erw [ pullback_eval ];
    rw [ this ];
  · contrapose! h;
    use fun i => MvPolynomial.eval v (q i);
    ext i; specialize h_inv v i; simp +decide [ pullback ] at h_inv ⊢;
    simp +zetaDelta at *;
    convert congr_arg ( MvPolynomial.eval v ) ( RingEquiv.symm_apply_apply ( RingEquiv.ofBijective ( pullback p ) h_bij ) ( MvPolynomial.X i ) ) using 1;
    · simp +decide [ pullback ];
      induction' p i using MvPolynomial.induction_on with i p q hp hq;
      · simp +decide [ MvPolynomial.eval_C ];
        convert rfl;
        convert MvPolynomial.eval_C i;
        exact ( RingEquiv.symm_apply_eq _ ).mpr ( by simp +decide );
      · simp +decide [ hp, hq ];
      · simp +decide [ *, MvPolynomial.eval_mul ];
    · simp +decide

/-
Checking for instances required to define the map on the fraction ring.
-/
variable {K : Type*} [Field K] {n : Type*} [Fintype n]

#synth Algebra (MvPolynomial n K) (FractionRing (MvPolynomial n K))
#synth Algebra K (FractionRing (MvPolynomial n K))
#synth IsScalarTower K (MvPolynomial n K) (FractionRing (MvPolynomial n K))
#synth Field (FractionRing (MvPolynomial n K))

/-
The pullback map extended to the fraction field.
-/
noncomputable def pullback_frac_map {K : Type*} [Field K] [IsAlgClosed K] {n : Type*} [Fintype n]
    (p : n → MvPolynomial n K) : MvPolynomial n K →+* FractionRing (MvPolynomial n K) :=
  (algebraMap (MvPolynomial n K) (FractionRing (MvPolynomial n K))).comp (pullback p)

theorem pullback_frac_map_injective {K : Type*} [Field K] [IsAlgClosed K] {n : Type*} [Fintype n]
    (p : n → MvPolynomial n K) (h_surj : Function.Surjective (fun v i => MvPolynomial.eval v (p i))) :
    Function.Injective (pullback_frac_map p) := by
      have h_pullback_injective : Function.Injective (pullback p) := by
        exact?;
      intro x y hxy;
      have h_eq : (algebraMap (MvPolynomial n K) (FractionRing (MvPolynomial n K))) (pullback p x) = (algebraMap (MvPolynomial n K) (FractionRing (MvPolynomial n K))) (pullback p y) := by
        convert hxy using 1;
      exact h_pullback_injective ( by simpa using h_eq )

noncomputable def pullback_frac {K : Type*} [Field K] [IsAlgClosed K] {n : Type*} [Fintype n]
    (p : n → MvPolynomial n K) (h_surj : Function.Surjective (fun v i => MvPolynomial.eval v (p i))) :
    FractionRing (MvPolynomial n K) →+* FractionRing (MvPolynomial n K) :=
  IsFractionRing.lift (pullback_frac_map_injective p h_surj)

/-
Checking if pullback_frac is already defined.
-/
#check pullback_frac

/-
The geometric degree of the polynomial map.
-/
noncomputable def geometric_degree {K : Type*} [Field K] [IsAlgClosed K] {n : Type*} [Fintype n]
    (p : n → MvPolynomial n K) (h_surj : Function.Surjective (fun v i => MvPolynomial.eval v (p i))) : ℕ :=
  let f := pullback_frac p h_surj
  let S := f.fieldRange
  Module.finrank S (FractionRing (MvPolynomial n K))

/-
Checking if geometric_degree is available.
-/
#check geometric_degree

#check CharZero

variable {K : Type*} [Field K] {n : Type*} [Fintype n]
#synth IsIntegrallyClosed (MvPolynomial n K)
#synth IsNoetherianRing (MvPolynomial n K)
#check RingHom.IsIntegral
#check RingHom.Finite

/-
If a subfield has dimension 1 as a vector space over itself (which is trivial) or rather, if the field extension L/S has degree 1, then S = L.
-/
lemma Subfield.eq_top_of_finrank_eq_one {L : Type*} [Field L] (S : Subfield L) (h : Module.finrank S L = 1) : S = ⊤ := by
  -- If the dimension of $L$ over $S$ is 1, then $S = L$.
  have h_S_eq_L : ∀ y : L, y ∈ S := by
    rw [ finrank_eq_one_iff' ] at h;
    -- Let $v$ be a non-zero element in $L$ such that every element in $L$ can be written as $c \cdot v$ for some $c \in S$.
    obtain ⟨v, hv_ne_zero, hv⟩ := h;
    have hv_inv : v⁻¹ ∈ S := by
      obtain ⟨ c, hc ⟩ := hv 1;
      convert c.2 using 1;
      exact?;
    have hv_inv_mul : ∀ w : L, w ∈ S := by
      intro w
      obtain ⟨c, hc⟩ := hv w
      have hc_mul : c = w * v⁻¹ := by
        simp +decide [ ← hc, mul_assoc, hv_ne_zero ];
        simp +decide [ Algebra.smul_def ];
        rfl;
      convert S.mul_mem c.2 ( S.inv_mem hv_inv ) using 1 ; aesop;
    exact hv_inv_mul;
  aesop

#check IsFractionRing.lift
#check mem_nonZeroDivisors_iff_ne_zero

noncomputable def lift_hom {R : Type*} [CommRing R] [IsDomain R] (f : R →+* R) (hf : Function.Injective f) :
    FractionRing R →+* FractionRing R :=
  IsFractionRing.lift (g := (algebraMap R (FractionRing R)).comp f) (by
    rw [RingHom.coe_comp]
    exact Function.Injective.comp (IsFractionRing.injective R (FractionRing R)) hf)

/-
The image of an integrally closed domain under an injective homomorphism is integrally closed.
-/
lemma isIntegrallyClosed_range_of_isIntegrallyClosed {R : Type*} [CommRing R] [IsDomain R] [IsIntegrallyClosed R]
    (f : R →+* R) (hf : Function.Injective f) : IsIntegrallyClosed f.range := by
  -- Since $f$ is injective, $f(R)$ is isomorphic to $R$, which is integrally closed.
  have h_iso : Nonempty (f.range ≃+* R) := by
    refine' ⟨ _ ⟩;
    symm;
    refine' { Equiv.ofBijective ( fun x => ⟨ f x, x, rfl ⟩ ) ⟨ fun x y hxy => _, fun x => _ ⟩ with .. } <;> aesop;
  obtain ⟨ g ⟩ := h_iso;
  convert IsIntegrallyClosed.of_equiv g.symm

/-
If a subring is integrally closed, the ring is integral over it, and they share the same fraction ring, then the subring is the whole ring.
-/
lemma subring_eq_top_of_isIntegrallyClosed_of_integral_of_isFractionRing {R : Type*} [CommRing R] [IsDomain R]
    (S : Subring R) [IsIntegrallyClosed S]
    (h_int : Algebra.IsIntegral S R)
    (h_frac : IsFractionRing S (FractionRing R)) : S = ⊤ := by
  ext x;
  constructor;
  · exact fun hx => trivial;
  · -- Since $R$ is integral over $S$, $x$ is integral over $S$.
    have h_integral : IsIntegral S x := by
      exact?;
    -- Since $x$ is integral over $S$ and $S$ is integrally closed, $x$ must be in $S$.
    have h_in_S : x ∈ S := by
      have h_integral : IsIntegral S x := h_integral
      have h_int_closed : IsIntegrallyClosed S := by assumption
      have h_in_S : ∀ {y : FractionRing R}, IsIntegral S y → y ∈ (algebraMap R (FractionRing R)) '' S := by
        intro y hy
        have h_in_S : y ∈ (algebraMap S (FractionRing R)) '' Set.univ := by
          convert h_int_closed.isIntegral_iff.mp hy;
          simp +decide;
        aesop;
      specialize h_in_S ( show IsIntegral S ( algebraMap R ( FractionRing R ) x ) from by
                            exact? )
      generalize_proofs at *;
      aesop;
    exact fun _ => h_in_S

lemma lift_hom_apply {R : Type*} [CommRing R] [IsDomain R]
    (f : R →+* R) (hf : Function.Injective f) (x : R) :
    lift_hom f hf (algebraMap R (FractionRing R) x) = algebraMap R (FractionRing R) (f x) := by
  rw [lift_hom, IsFractionRing.lift_algebraMap]
  rfl

/-
Every element in the fraction ring can be written as a fraction of elements in the image of the map.
-/
lemma exists_frac_in_range {R : Type*} [CommRing R] [IsDomain R]
    (f : R →+* R) (h_inj : Function.Injective f)
    (h_surj : Function.Surjective (lift_hom f h_inj))
    (x : FractionRing R) :
    ∃ (a b : f.range), b ≠ 0 ∧ x = (algebraMap f.range (FractionRing R) a) / (algebraMap f.range (FractionRing R) b) := by
  -- By surjectivity of ` �lift�_hom`, there exists some `y ∈ FractionRing R` such that `lift_hom y = x`.
  obtain ⟨y, hy⟩ : ∃ y : FractionRing R, lift_hom f h_inj y = x := h_surj x;
  -- By definition of `IsFractionRing`, there exist `u �,� v ∈ R` with `v ≠ 0` such that `y = u / v`.
  obtain ⟨u, v, hv_ne_zero, hy_eq⟩ : ∃ u v : R, v ≠ 0 ∧ y = (algebraMap R (FractionRing R)) u / (algebraMap R (FractionRing R)) v := by
    have := IsLocalization.mk'_surjective ( nonZeroDivisors R ) y; obtain ⟨ u, v, hv ⟩ := this; use u, v; aesop;
  -- By definition of `lift �_hom�`, we have `lift_hom ( �u� / v) = (lift_hom u) / (lift_hom v)`.
  have h_lift_div : lift_hom f h_inj ((algebraMap R (FractionRing R)) u / (algebraMap R (FractionRing R)) v) = (algebraMap R (FractionRing R)) (f u) / (algebraMap R (FractionRing R)) (f v) := by
    rw [ map_div₀ ];
    rw [ lift_hom_apply, lift_hom_apply ];
  -- By definition of `lift_hom ���`, we have `lift_hom ( � ��u / v �)� = (lift_hom u) / (lift_hom v)`. Therefore, `x = (lift_hom u) / (lift_hom v)`.
  use ⟨f u, by
    exact Set.mem_range_self u⟩, ⟨f v, by
    exact Set.mem_range_self _⟩
  generalize_proofs at *;
  simp_all +decide [ Subtype.ext_iff ];
  exact ⟨ fun h => hv_ne_zero <| h_inj <| by simp +decide [ h ], hy.symm ⟩

/-
If the lifted map on the fraction ring is surjective, then the fraction ring is also the fraction ring of the image of the original map.
-/
lemma isFractionRing_range_of_surjective_lift {R : Type*} [CommRing R] [IsDomain R]
    (f : R →+* R) (h_inj : Function.Injective f)
    (h_frac_surj : Function.Surjective (lift_hom f h_inj)) :
    IsFractionRing f.range (FractionRing R) := by
  refine' { .. };
  · aesop;
  · intro z
    obtain ⟨a, b, hb, hz⟩ := exists_frac_in_range f h_inj h_frac_surj z
    use (⟨a, by
      exact a.2⟩, ⟨b, by
      exact mem_nonZeroDivisors_iff_ne_zero.mpr hb⟩)
    generalize_proofs at *
    aesop
    skip;
  · simp +decide;
    intro a x hx a' x' hx' h_eq;
    have h_eq' : (algebraMap R (FractionRing R)) a = (algebraMap R (FractionRing R)) a' := by
      convert h_eq using 1;
    exact IsFractionRing.injective R ( FractionRing R ) h_eq'

#check Algebra.IsIntegral
#print Algebra.IsIntegral

/-
If a ring homomorphism is integral, then the target ring is integral over the image of the homomorphism.
-/
lemma isIntegral_range_of_isIntegral_hom {R S : Type*} [CommRing R] [CommRing S]
    (f : R →+* S) (hf : f.IsIntegral) : Algebra.IsIntegral f.range S := by
      refine' ⟨ fun x => _ ⟩;
      by_contra hx;
      obtain ⟨ p, hp ⟩ := hf x;
      refine' hx ⟨ p.map ( f.rangeRestrict ), _, _ ⟩;
      · convert hp.1.map _;
      · simp_all +decide [ Polynomial.eval₂_map ];
        convert hp.2 using 1

/-
If a ring homomorphism is integral, then the target ring is integral over the image of the homomorphism.
-/
lemma isIntegral_range_of_isIntegral_hom' {R S : Type*} [CommRing R] [CommRing S]
    (f : R →+* S) (hf : f.IsIntegral) : Algebra.IsIntegral f.range S := by
      convert isIntegral_range_of_isIntegral_hom f hf

/-
An injective integral endomorphism of an integrally closed domain which induces a surjective map on fraction fields is surjective.
-/
lemma surjective_of_integral_of_isIntegrallyClosed_of_fraction_map_surjective {R : Type*} [CommRing R] [IsDomain R] [IsIntegrallyClosed R]
    (f : R →+* R) (h_int : f.IsIntegral) (h_inj : Function.Injective f)
    (h_frac_surj : Function.Surjective (lift_hom f h_inj)) :
    Function.Surjective f := by
  -- Let $S = f(R)$. � Since� $f$ is injective, $S \cong R$.
  set S := f.range;
  -- Since $R$ is integrally closed, $S$ is integrally closed.
  have hS_integrally_closed : IsIntegrallyClosed S := by
    exact?;
  -- Since $f$ is integral, $R$ is integral over $S$.
  have hR_integral_over_S : Algebra.IsIntegral S R := by
    exact?;
  -- Since $S$ is integrally closed, $R$ is integral over $S$, and they share the same fraction ring, we have $S = R$.
  have hS_eq_R : S = ⊤ := by
    apply subring_eq_top_of_isIntegrallyClosed_of_integral_of_isFractionRing;
    · exact hR_integral_over_S;
    · convert isFractionRing_range_of_surjective_lift f h_inj h_frac_surj;
  exact fun x => by rw [ SetLike.ext_iff ] at hS_eq_R; aesop;

/-
If the pullback is integral and has geometric degree 1, it is surjective.
-/
lemma pullback_surjective_of_integral_of_degree_one {K : Type*} [Field K] [IsAlgClosed K] {n : Type*} [Fintype n]
    (p : n → MvPolynomial n K) (h_surj : Function.Surjective (fun v i => MvPolynomial.eval v (p i)))
    (h_int : (pullback p).IsIntegral)
    (h_deg : geometric_degree p h_surj = 1) :
    Function.Surjective (pullback p) := by
      -- Since the geometric degree is 1, the range of `pullback_frac` is $\top$.
      have h_pullback_frac_range_top : (pullback_frac p h_surj).fieldRange = ⊤ := by
        apply Subfield.eq_top_of_finrank_eq_one;
        exact h_deg;
      convert surjective_of_integral_of_isIntegrallyClosed_of_fraction_map_surjective ( pullback p ) h_int _ _ using 1;
      convert pullback_injective p h_surj using 1;
      intro x; replace h_pullback_frac_range_top := SetLike.ext_iff.mp h_pullback_frac_range_top x; aesop;

#check Polynomial.disc

def fiber {K : Type*} [CommSemiring K] {n : Type*} [Fintype n]
    (p : n → MvPolynomial n K) (y : n → K) : Set (n → K) :=
  { x | (fun i => MvPolynomial.eval x (p i)) = y }

lemma fiber_card_eq_one_of_bijective {K : Type*} [Field K] {n : Type*} [Fintype n]
    (p : n → MvPolynomial n K) (h_bij : Function.Bijective (fun v i => MvPolynomial.eval v (p i)))
    (y : n → K) :
    Set.ncard (fiber p y) = 1 := by
      obtain ⟨ x, hx ⟩ := h_bij.2 y;
      -- Since the polynomial map is injective, the fiber of y is just {x}.
      have h_fiber : fiber p y = {x} := by
        -- Since the polynomial map is bijective, there exists a unique x such that p(x �)� = y. Therefore, the fiber of y � is� exactly {x}.
        ext v
        simp [fiber, hx];
        -- Since p is bijective, the function p is injective. Therefore, if p(v) = p(x), then v must equal x.
        apply Iff.intro;
        · exact fun h => h_bij.injective ( h.trans hx.symm );
        · -- If $v = � x�$, then substituting $v$ into the function gives us the same result as substituting $x$, which is $y$.
          intro hv
          rw [hv]
          exact hx;
      rw [ h_fiber, Set.ncard_singleton ]

/-
The evaluation of a polynomial map is a polynomial map.
-/
lemma isPolyMap_eval {K : Type*} [CommSemiring K] {n : Type*} [Fintype n]
    (p : n → MvPolynomial n K) :
    IsPolyMap (fun v i => MvPolynomial.eval v (p i)) := by
      exact ⟨ p, fun v => rfl ⟩

/-
A polynomial that does not vanish anywhere is a unit.
-/
lemma isUnit_of_forall_eval_ne_zero {K : Type*} [Field K] [IsAlgClosed K] {n : Type*} [Fintype n]
    (P : MvPolynomial n K) (h : ∀ v, MvPolynomial.eval v P ≠ 0) : IsUnit P := by
      -- By the Nullstellensatz, since $P$ has no roots in $K^n$, the ideal generated by $P$ is the unit ideal.
      have h_unit_ideal : Ideal.span {P} = ⊤ := by
        rw [ Ideal.eq_top_iff_one ];
        have h_ideal : ∀ (I : Ideal (MvPolynomial n K)), I ≠ ⊤ → ∃ v : n → K, ∀ p ∈ I, MvPolynomial.eval v p = 0 := by
          intro I hI;
          have := @MvPolynomial.vanishingIdeal_zeroLocus_eq_radical K;
          specialize @this K _ _ _ n _ _ I;
          by_cases h : MvPolynomial.zeroLocus K I = ∅ <;> simp_all +decide [ SetLike.ext_iff ];
          · specialize this 1 ; simp_all +decide [ Ideal.radical ];
            exact False.elim ( hI.elim fun x hx => hx ( by rw [ show I = ⊤ from eq_top_iff.mpr fun p hp => by simpa using I.mul_mem_left p this ] ; simp +decide ) );
          · exact Set.nonempty_iff_ne_empty.2 h |> fun ⟨ v, hv ⟩ => ⟨ v, fun p hp => by simpa using hv p hp ⟩;
        contrapose! h_ideal;
        exact ⟨ Ideal.span { P }, by rw [ Ne.eq_def, Ideal.eq_top_iff_one ] ; exact h_ideal, fun v => ⟨ P, Ideal.subset_span ( Set.mem_singleton P ), h v ⟩ ⟩;
      rw [ Ideal.span_singleton_eq_top ] at h_unit_ideal ; aesop;



#check IsPolyMap
#check injective_poly_map_surjective
#check pullback
#check geometric_degree
#check pullback_surjective_of_integral_of_degree_one

/-
If the pullback of a polynomial map is surjective, its geometric degree is 1.
-/
theorem geometric_degree_eq_one_of_pullback_surjective {K : Type*} [Field K] [IsAlgClosed K] {n : Type*} [Fintype n]
    (p : n → MvPolynomial n K) (h_surj_map : Function.Surjective (fun v i => MvPolynomial.eval v (p i)))
    (h_surj_pullback : Function.Surjective (pullback p)) :
    geometric_degree p h_surj_map = 1 := by
      -- Since `pullback p` is surjective, `pullback_frac p` is also surjective.
      have h_surj_pullback_frac : Function.Surjective (pullback_frac p h_surj_map) := by
        convert pullback_isIso_of_surjective p h_surj_pullback |> And.right using 1
        generalize_proofs at *; (
        refine' ⟨ fun h => _, fun h => _ ⟩
        all_goals generalize_proofs at *;
        · grind;
        · intro x
          generalize_proofs at *; (
          rcases IsFractionRing.div_surjective ( A := MvPolynomial n K ) x with ⟨ a, b, ha, hb, rfl ⟩
          generalize_proofs at *; (
          obtain ⟨ c, hc ⟩ := h_surj_pullback a
          obtain ⟨ d, hd ⟩ := h_surj_pullback b
          use (algebraMap (MvPolynomial n K) (FractionRing (MvPolynomial n K))) c / (algebraMap (MvPolynomial n K) (FractionRing (MvPolynomial n K))) d
          generalize_proofs at *; (
          simp +decide [ ← hc, ← hd, pullback_frac ];
          rfl
          skip))));
      have h_fieldRange : (pullback_frac p h_surj_map).fieldRange = ⊤ := by
        ext x; aesop;
      have h_finrank : ∀ (S : Subfield (FractionRing (MvPolynomial n K))), S = ⊤ → Module.finrank S (FractionRing (MvPolynomial n K)) = 1 := by
        intro S hS
        have h_finrank : Module.finrank S (FractionRing (MvPolynomial n K)) = 1 := by
          have h_iso : FractionRing (MvPolynomial n K) ≃ₐ[S] S := by
            refine' { Equiv.ofBijective ( fun x => ⟨ x, by aesop ⟩ ) ⟨ fun x y hxy => _, fun x => _ ⟩ with .. } <;> aesop
          have := h_iso.toLinearEquiv.finrank_eq;
          aesop;
        exact h_finrank;
      exact h_finrank _ h_fieldRange

/-
If a polynomial map is injective over an algebraically closed field K, it is injective over any field extension L.
-/
theorem injective_of_isAlgClosed_of_injective {K L : Type*} [Field K] [IsAlgClosed K] [Field L] [Algebra K L] {n : Type*} [Fintype n]
    (p : n → MvPolynomial n K) (h_inj : Function.Injective (fun v i => MvPolynomial.eval v (p i))) :
    Function.Injective (fun v i => MvPolynomial.eval₂ (algebraMap K L) v (p i)) := by
      intro v w h_inj;
      -- For each $i$, the system $p(x) = p(y) \land z(x_i - y_i) = 1$ is a polynomial system.
      -- If it has a solution in $L$, it � has� a solution in $K$.
      have h_sol : ∀ i, ¬(v i = w i) → False := by
        intro i hi
        have h_poly : ∃ x y : n → L, (fun v i => MvPolynomial.eval₂ (algebraMap K L) v (p i)) x = (fun v i => MvPolynomial.eval₂ (algebraMap K L) v (p i)) y ∧ x i ≠ y i := by
          exact ⟨ v, w, h_inj, hi ⟩;
        obtain ⟨ x, y, hxy, hiy ⟩ := h_poly;
        -- Consider the system of polynomial equations $p(x) = p(y)$ and $z(x_i - y_i) = 1$.
        set S : Finset (MvPolynomial (n ⊕ n ⊕ Unit) K) := Finset.image (fun j => MvPolynomial.rename (Sum.inl) (p j) - MvPolynomial.rename (Sum.inr ∘ Sum.inl) (p j)) Finset.univ ∪ {MvPolynomial.X (Sum.inr (Sum.inr ())) * (MvPolynomial.X (Sum.inl i) - MvPolynomial.X (Sum.inr (Sum.inl i))) - 1};
        -- By the Nullstellensatz, since $S$ has a solution in $L$, it also has a solution in $K$.
        obtain ⟨z, hz⟩ : ∃ z : (n ⊕ n ⊕ Unit) → K, ∀ s ∈ S, MvPolynomial.eval z s = 0 := by
          have h_nullstellensatz : ∀ (I : Ideal (MvPolynomial (n ⊕ n ⊕ Unit) K)), I ≠ ⊤ → ∃ z : (n ⊕ n ⊕ Unit) → K, ∀ s ∈ I, MvPolynomial.eval z s = 0 := by
            intro I hI;
            have := @MvPolynomial.vanishingIdeal_zeroLocus_eq_radical K;
            specialize @this K _ _ _ ( n ⊕ n ⊕ Unit ) _ _ I;
            contrapose! this;
            simp +decide [ MvPolynomial.vanishingIdeal, MvPolynomial.zeroLocus ];
            simp +decide [ SetLike.ext_iff, Ideal.radical ];
            use 1;
            simp +decide [ this ];
            exact fun h => hI <| I.eq_top_of_isUnit_mem ( h.mp this ) isUnit_one;
          contrapose! h_nullstellensatz;
          refine' ⟨ Ideal.span S, _, _ ⟩;
          · rw [ Ne.eq_def, Ideal.eq_top_iff_one ];
            intro h_one_in_ideal
            obtain ⟨s, hs⟩ : ∃ s : (n ⊕ n ⊕ Unit) → L, ∀ s' ∈ S, MvPolynomial.eval₂ (algebraMap K L) s s' = 0 := by
              use fun j => Sum.elim (fun j => x j) (fun j => Sum.elim (fun j => y j) (fun _ => (x i - y i)⁻¹) j) j;
              simp +zetaDelta at *;
              simp_all +decide [ funext_iff, MvPolynomial.eval₂_rename ];
              exact ⟨ by rw [ inv_mul_cancel₀ ( sub_ne_zero_of_ne hiy ), sub_self ], fun a => by simp +decide [ MvPolynomial.eval₂_eq' ] ⟩;
            have h_eval_one : MvPolynomial.eval₂ (algebraMap K L) s 1 = 0 := by
              have h_eval_one : ∀ (f : MvPolynomial (n ⊕ n ⊕ Unit) K), f ∈ Ideal.span S → MvPolynomial.eval₂ (algebraMap K L) s f = 0 := by
                intro f hf
                induction' hf using Submodule.span_induction with f hf ih;
                · exact hs f hf;
                · simp +decide;
                · simp +decide [ *, MvPolynomial.eval₂_add ];
                · simp +decide [ *, MvPolynomial.eval₂_mul ];
              exact h_eval_one _ h_one_in_ideal;
            simp +zetaDelta at *;
          · exact fun x => by obtain ⟨ s, hs₁, hs₂ ⟩ := h_nullstellensatz x; exact ⟨ s, Ideal.subset_span hs₁, hs₂ ⟩ ;
        simp +zetaDelta at *;
        simp_all +decide [ funext_iff, MvPolynomial.eval_rename ];
        have := ‹Function.Injective ( fun v i => MvPolynomial.eval v ( p i ) ) › ( show ( fun i => MvPolynomial.eval ( z ∘ Sum.inl ) ( p i ) ) = fun i => MvPolynomial.eval ( z ∘ Sum.inr ∘ Sum.inl ) ( p i ) from funext fun i => sub_eq_zero.mp ( hz.2 i ) ) ; simp_all +decide [ funext_iff ] ;
      exact funext fun i => Classical.not_not.1 fun hi => h_sol i hi





#check Algebra.IsSeparable

/-
If a finite separable field extension has degree greater than 1, there exist at least two distinct embeddings into an algebraically closed field.
-/
lemma exists_ne_algHom_of_finrank_gt_one {F E K : Type*} [Field F] [Field E] [Field K]
    [Algebra F E] [Algebra F K] [FiniteDimensional F E] [Algebra.IsSeparable F E] [IsAlgClosed K]
    (h_rank : Module.finrank F E > 1) :
    ∃ (f g : E →ₐ[F] K), f ≠ g := by
      have h_card : Fintype.card (E →ₐ[F] K) > 1 := by
        -- Apply the theorem that states the cardinality of the set of embeddings is equal to the degree of the extension.
        have h_card_eq_deg : Fintype.card (E →ₐ[F] K) = Module.finrank F E := by
          exact?
        generalize_proofs at *; (
        exact h_card_eq_deg.symm ▸ h_rank)
      generalize_proofs at *; (
      exact Fintype.one_lt_card_iff.1 h_card |> fun ⟨ f, g, hfg ⟩ => ⟨ f, g, hfg ⟩)

#check AlgebraicClosure

/-
If there are two distinct embeddings of the function field over the pullback field, then the polynomial map is not injective over the extension.
-/
lemma exists_ne_and_map_eq_of_exists_ne_algHom {K : Type*} [Field K] [IsAlgClosed K] {n : Type*} [Fintype n]
    (p : n → MvPolynomial n K)
    (h_surj : Function.Surjective (fun v i => MvPolynomial.eval v (p i)))
    (Ω : Type*) [Field Ω] [Algebra K Ω] [IsAlgClosed Ω]
    (σ τ : FractionRing (MvPolynomial n K) →ₐ[K] Ω)
    (h_eq_on_range : ∀ x : pullback_frac p h_surj |>.fieldRange, σ x = τ x)
    (h_ne : σ ≠ τ) :
    ∃ v₁ v₂ : n → Ω, v₁ ≠ v₂ ∧ (fun i => MvPolynomial.eval₂ (algebraMap K Ω) v₁ (p i)) = (fun i => MvPolynomial.eval₂ (algebraMap K Ω) v₂ (p i)) := by
      -- Since $\sigma$ and $\tau$ are distinct, there exists some $i$ such that $\sigma(X_i) \neq \tau(X_i)$.
      obtain ⟨i, hi⟩ : ∃ i : n, σ (algebraMap (MvPolynomial n K) (FractionRing (MvPolynomial n K)) (MvPolynomial.X i)) ≠ τ (algebraMap (MvPolynomial n K) (FractionRing (MvPolynomial n K)) (MvPolynomial.X i)) := by
        contrapose! h_ne;
        ext x;
        exact h_ne x;
      refine' ⟨ fun j => σ ( algebraMap ( MvPolynomial n K ) ( FractionRing ( MvPolynomial n K ) ) ( MvPolynomial.X j ) ), fun j => τ ( algebraMap ( MvPolynomial n K ) ( FractionRing ( MvPolynomial n K ) ) ( MvPolynomial.X j ) ), _, _ ⟩ <;> simp_all +decide [ funext_iff ];
      · use i;
      · intro j; specialize h_eq_on_range ( algebraMap ( MvPolynomial n K ) ( FractionRing ( MvPolynomial n K ) ) ( MvPolynomial.X j ) ) ; simp_all +decide [ pullback_frac ] ;
        convert h_eq_on_range using 1 <;> simp +decide [ pullback_frac_map ];
        · simp +decide [ pullback, MvPolynomial.aeval_def ];
          induction' p j using MvPolynomial.induction_on with i p q hp hq <;> simp_all +decide [ MvPolynomial.eval₂_add, MvPolynomial.eval₂_mul ];
          exact σ.commutes i ▸ rfl;
        · simp +decide [ pullback ];
          induction' p j using MvPolynomial.induction_on with i p q hp hq <;> simp_all +decide [ MvPolynomial.eval₂_add, MvPolynomial.eval₂_mul ];
          exact τ.commutes i ▸ rfl

#synth Field (AlgebraicClosure (FractionRing (MvPolynomial n K)))
#synth IsAlgClosed (AlgebraicClosure (FractionRing (MvPolynomial n K)))
#synth Algebra (FractionRing (MvPolynomial n K)) (AlgebraicClosure (FractionRing (MvPolynomial n K)))

/-
The pullback map on the fraction ring fixes the elements of the base field.
-/
lemma pullback_frac_fixes_K {K : Type*} [Field K] [IsAlgClosed K] {n : Type*} [Fintype n]
    (p : n → MvPolynomial n K) (h_surj : Function.Surjective (fun v i => MvPolynomial.eval v (p i)))
    (k : K) :
    pullback_frac p h_surj (algebraMap K (FractionRing (MvPolynomial n K)) k) = algebraMap K (FractionRing (MvPolynomial n K)) k := by
      convert IsFractionRing.lift_algebraMap ( pullback_frac_map_injective p h_surj ) _;
      -- The algebra map from K to the fraction ring of MvPolynomial n K is just the inclusion of K into the fraction ring. The pullback map on polynomials is defined as the evaluation of the polynomial map at the elements of K.
      simp [pullback_frac_map, pullback];
      erw [ MvPolynomial.bind₁_monomial ] ; aesop

#check pullback_frac_fixes_K

variable {K : Type*} [Field K] [CharZero K] {n : Type*} [Fintype n]
#synth CharZero (FractionRing (MvPolynomial n K))

/-
A subfield of a field of characteristic zero has characteristic zero.
-/
lemma charZero_subfield_of_charZero {L : Type*} [Field L] [CharZero L] (S : Subfield L) : CharZero S := by
  constructor;
  intro a b h;
  exact Nat.cast_injective ( by simpa using h )

/-
If the geometric degree is positive, the extension is finite dimensional.
-/
lemma finiteDimensional_of_geometric_degree_gt_zero {K : Type*} [Field K] [IsAlgClosed K] {n : Type*} [Fintype n]
    (p : n → MvPolynomial n K) (h_surj : Function.Surjective (fun v i => MvPolynomial.eval v (p i)))
    (h_deg : geometric_degree p h_surj > 0) :
    let S := (pullback_frac p h_surj).fieldRange
    let L := FractionRing (MvPolynomial n K)
    FiniteDimensional S L := by
      convert FiniteDimensional.of_finrank_pos h_deg

/-
If the geometric degree is positive, the extension is separable.
-/
lemma isSeparable_of_geometric_degree_gt_zero {K : Type*} [Field K] [IsAlgClosed K] [CharZero K] {n : Type*} [Fintype n]
    (p : n → MvPolynomial n K) (h_surj : Function.Surjective (fun v i => MvPolynomial.eval v (p i)))
    (h_deg : geometric_degree p h_surj > 0) :
    let S := (pullback_frac p h_surj).fieldRange
    let L := FractionRing (MvPolynomial n K)
    Algebra.IsSeparable S L := by
      have h_perfect : PerfectField (↥((pullback_frac p h_surj).fieldRange)) := by
        exact?;
      have h_finite : FiniteDimensional (↥((pullback_frac p h_surj).fieldRange)) (FractionRing (MvPolynomial n K)) := by
        convert finiteDimensional_of_geometric_degree_gt_zero p h_surj h_deg;
      exact?

/-
If the geometric degree is greater than 1, there exist two distinct embeddings of the fraction ring into its algebraic closure that fix the image of the pullback.
-/
lemma exists_distinct_embeddings_of_geometric_degree_gt_one {K : Type*} [Field K] [IsAlgClosed K] [CharZero K] {n : Type*} [Fintype n]
    (p : n → MvPolynomial n K) (h_surj : Function.Surjective (fun v i => MvPolynomial.eval v (p i)))
    (h_deg : geometric_degree p h_surj > 1) :
    let S := (pullback_frac p h_surj).fieldRange
    let L := FractionRing (MvPolynomial n K)
    let Ω := AlgebraicClosure L
    ∃ σ τ : L →ₐ[S] Ω, σ ≠ τ := by
      -- Apply the theorem `exists_ne_algHom_of_finrank_gt_one` to find two distinct embeddings.
      obtain ⟨σ, τ, h_ne⟩ : ∃ (σ τ : FractionRing (MvPolynomial n K) →ₐ[↥(pullback_frac p h_surj).fieldRange] AlgebraicClosure (FractionRing (MvPolynomial n K))), σ ≠ τ := by
        have h_finrank : Module.finrank (↥(pullback_frac p h_surj).fieldRange) (FractionRing (MvPolynomial n K)) > 1 := by
          convert h_deg using 1
        have h_finiteDimensional : FiniteDimensional (↥(pullback_frac p h_surj).fieldRange) (FractionRing (MvPolynomial n K)) := by
          exact FiniteDimensional.of_finrank_pos ( pos_of_gt h_finrank );
        exact?;
      exact ⟨ σ, τ, h_ne ⟩

/-
If a polynomial map is injective, its pullback is injective.
-/
theorem pullback_injective_of_injective {K : Type*} [Field K] [IsAlgClosed K] {n : Type*} [Fintype n]
    (p : n → MvPolynomial n K) (h_inj : Function.Injective (fun v i => MvPolynomial.eval v (p i))) :
    Function.Injective (pullback p) := by
      have := injective_poly_map_surjective ( fun v i => MvPolynomial.eval v ( p i ) ) ( by
        exact ⟨ p, fun v => rfl ⟩ ) h_inj;
      exact?

/-
Define a point in `Ω^n` from an embedding of the fraction ring.
-/
def point_of_embedding {K : Type*} [Field K] {n : Type*} [Fintype n] {Ω : Type*} [Field Ω] [Algebra K Ω]
    (σ : FractionRing (MvPolynomial n K) →ₐ[K] Ω) : n → Ω :=
  fun i => σ (algebraMap (MvPolynomial n K) (FractionRing (MvPolynomial n K)) (MvPolynomial.X i))

/-
Evaluating a polynomial at the point defined by an embedding corresponds to applying the embedding to the polynomial.
-/
lemma eval_point_of_embedding {K : Type*} [Field K] {n : Type*} [Fintype n] {Ω : Type*} [Field Ω] [Algebra K Ω]
    (σ : FractionRing (MvPolynomial n K) →ₐ[K] Ω) (P : MvPolynomial n K) :
    MvPolynomial.eval₂ (algebraMap K Ω) (point_of_embedding σ) P = σ (algebraMap (MvPolynomial n K) (FractionRing (MvPolynomial n K)) P) := by
      induction' P using MvPolynomial.induction_on with i P Q hP hQ;
      · simp +decide [ MvPolynomial.eval₂_C ];
        exact σ.commutes i ▸ rfl;
      · simp +decide [ hP, hQ, MvPolynomial.eval₂_add ];
      · simp +decide [ *, point_of_embedding ]

/-
The point defined by an embedding uniquely determines the embedding.
-/
lemma point_of_embedding_injective {K : Type*} [Field K] {n : Type*} [Fintype n] {Ω : Type*} [Field Ω] [Algebra K Ω]
    (σ τ : FractionRing (MvPolynomial n K) →ₐ[K] Ω)
    (h : point_of_embedding σ = point_of_embedding τ) : σ = τ := by
      -- Since σ and τ are algebra homomorphisms, they agree on the X_i's. Therefore, by the uniqueness of algebra homomorphisms determined by their action on generators, σ and τ must be equal.
      have h_gen : ∀ P : MvPolynomial n K, σ (algebraMap (MvPolynomial n K) (FractionRing (MvPolynomial n K)) P) = τ (algebraMap (MvPolynomial n K) (FractionRing (MvPolynomial n K)) P) := by
        intro P
        have h_eval : MvPolynomial.eval₂ (algebraMap K Ω) (point_of_embedding σ) P = MvPolynomial.eval₂ (algebraMap K Ω) (point_of_embedding τ) P := by
          rw [ h ];
        convert h_eval using 1 <;> rw [ eval_point_of_embedding ];
      ext x;
      exact h_gen _

/-
The pullback map on the fraction ring maps `X i` to `p i`.
-/
lemma pullback_frac_apply_X {K : Type*} [Field K] [IsAlgClosed K] {n : Type*} [Fintype n]
    (p : n → MvPolynomial n K) (h_surj : Function.Surjective (fun v i => MvPolynomial.eval v (p i)))
    (i : n) :
    pullback_frac p h_surj (algebraMap (MvPolynomial n K) (FractionRing (MvPolynomial n K)) (MvPolynomial.X i)) =
    algebraMap (MvPolynomial n K) (FractionRing (MvPolynomial n K)) (p i) := by
      convert lift_hom_apply ( pullback p ) _ ( MvPolynomial.X i ) using 1;
      · unfold pullback; aesop;
      · convert pullback_injective p h_surj using 1

/-
If two embeddings agree on the range of the pullback map, then the evaluations of the polynomial map at the corresponding points are equal.
-/
lemma eval_eq_of_embedding_eq_on_range {K : Type*} [Field K] [IsAlgClosed K] {n : Type*} [Fintype n] {Ω : Type*} [Field Ω] [Algebra K Ω]
    (p : n → MvPolynomial n K) (h_surj : Function.Surjective (fun v i => MvPolynomial.eval v (p i)))
    (σ τ : FractionRing (MvPolynomial n K) →ₐ[K] Ω)
    (h_agree : ∀ x : (pullback_frac p h_surj).fieldRange, σ x = τ x) :
    (fun i => MvPolynomial.eval₂ (algebraMap K Ω) (point_of_embedding σ) (p i)) =
    (fun i => MvPolynomial.eval₂ (algebraMap K Ω) (point_of_embedding τ) (p i)) := by
      ext i; exact (by
      convert h_agree ⟨ _, Set.mem_range_self ( algebraMap ( MvPolynomial n K ) ( FractionRing ( MvPolynomial n K ) ) ( MvPolynomial.X i ) ) ⟩ using 1;
      · simp +decide [ eval_point_of_embedding, pullback_frac_apply_X ];
      · convert eval_point_of_embedding τ ( p i ) using 1;
        exact congr_arg _ ( pullback_frac_apply_X p h_surj i ))

#check RingHom.mem_fieldRange

/-
The range of the pullback map is a K-algebra and forms a scalar tower.
-/
noncomputable def algebra_K_range {K : Type*} [Field K] [IsAlgClosed K] {n : Type*} [Fintype n]
    (p : n → MvPolynomial n K) (h_surj : Function.Surjective (fun v i => MvPolynomial.eval v (p i))) :
    Algebra K (pullback_frac p h_surj).fieldRange :=
  (RingHom.codRestrict (algebraMap K (FractionRing (MvPolynomial n K))) (pullback_frac p h_surj).fieldRange.toSubring
    (fun x => by
      rw [Subfield.mem_toSubring, RingHom.mem_fieldRange]
      use algebraMap K (FractionRing (MvPolynomial n K)) x
      rw [pullback_frac_fixes_K]
    )).toAlgebra

instance isScalarTower_range {K : Type*} [Field K] [IsAlgClosed K] {n : Type*} [Fintype n]
    (p : n → MvPolynomial n K) (h_surj : Function.Surjective (fun v i => MvPolynomial.eval v (p i))) :
    letI := algebra_K_range p h_surj
    IsScalarTower K (pullback_frac p h_surj).fieldRange (FractionRing (MvPolynomial n K)) := by
  letI := algebra_K_range p h_surj
  constructor
  intro x y z
  simp only [Algebra.smul_def]
  apply mul_assoc

/-
The polynomials defining a surjective map are algebraically independent.
-/
lemma aeval_eq_pullback {K : Type*} [CommSemiring K] {n : Type*} [Fintype n]
    (p : n → MvPolynomial n K) :
    (MvPolynomial.aeval p).toRingHom = pullback p := by
      bound

lemma p_algebraically_independent {K : Type*} [Field K] [IsAlgClosed K] {n : Type*} [Fintype n]
    (p : n → MvPolynomial n K) (h_surj : Function.Surjective (fun v i => MvPolynomial.eval v (p i))) :
    AlgebraicIndependent K p := by
      convert pullback_injective p h_surj using 1

/-
The polynomials defining a surjective map are algebraically independent.
-/
lemma p_algebraically_independent' {K : Type*} [Field K] [IsAlgClosed K] {n : Type*} [Fintype n]
    (p : n → MvPolynomial n K) (h_surj : Function.Surjective (fun v i => MvPolynomial.eval v (p i))) :
    AlgebraicIndependent K p := by
      exact?

#check p_algebraically_independent

/-
The polynomials defining a surjective map are algebraically independent.
-/
lemma p_algebraically_independent_of_surjective {K : Type*} [Field K] [IsAlgClosed K] {n : Type*} [Fintype n]
    (p : n → MvPolynomial n K) (h_surj : Function.Surjective (fun v i => MvPolynomial.eval v (p i))) :
    AlgebraicIndependent K p := by
      -- Apply the lemma that states the polynomials are algebraically independent if the polynomial map is surjective.
      apply p_algebraically_independent' p h_surj

/-
The pullback map on the fraction ring is injective.
-/
lemma pullback_frac_injective {K : Type*} [Field K] [IsAlgClosed K] {n : Type*} [Fintype n]
    (p : n → MvPolynomial n K) (h_surj : Function.Surjective (fun v i => MvPolynomial.eval v (p i))) :
    Function.Injective (pullback_frac p h_surj) := by
      exact?

/-
Definitions of pullback fraction map and geometric degree using injectivity instead of surjectivity.
-/
noncomputable def pullback_frac_map_inj {K : Type*} [Field K] [IsAlgClosed K] {n : Type*} [Fintype n]
    (p : n → MvPolynomial n K) : MvPolynomial n K →+* FractionRing (MvPolynomial n K) :=
  (algebraMap (MvPolynomial n K) (FractionRing (MvPolynomial n K))).comp (pullback p)

theorem pullback_frac_map_inj_injective {K : Type*} [Field K] [IsAlgClosed K] {n : Type*} [Fintype n]
    (p : n → MvPolynomial n K) (h_inj : Function.Injective (fun v i => MvPolynomial.eval v (p i))) :
    Function.Injective (pullback_frac_map_inj p) := by
      -- Since the pullback is injective, the fraction map is also injective.
      apply pullback_frac_map_injective;
      exact?

noncomputable def pullback_frac_inj {K : Type*} [Field K] [IsAlgClosed K] {n : Type*} [Fintype n]
    (p : n → MvPolynomial n K) (h_inj : Function.Injective (fun v i => MvPolynomial.eval v (p i))) :
    FractionRing (MvPolynomial n K) →+* FractionRing (MvPolynomial n K) :=
  IsFractionRing.lift (pullback_frac_map_inj_injective p h_inj)

noncomputable def geometric_degree_inj {K : Type*} [Field K] [IsAlgClosed K] {n : Type*} [Fintype n]
    (p : n → MvPolynomial n K) (h_inj : Function.Injective (fun v i => MvPolynomial.eval v (p i))) : ℕ :=
  let f := pullback_frac_inj p h_inj
  let S := f.fieldRange
  Module.finrank S (FractionRing (MvPolynomial n K))

/-
If two embeddings agree on the range of the pullback of an injective map, they are equal.
-/
lemma embeddings_eq_of_injective {K : Type*} [Field K] [IsAlgClosed K] {n : Type*} [Fintype n]
    (p : n → MvPolynomial n K) (h_surj : Function.Surjective (fun v i => MvPolynomial.eval v (p i)))
    (h_inj : Function.Injective (fun v i => MvPolynomial.eval v (p i)))
    (Ω : Type*) [Field Ω] [Algebra K Ω] [IsAlgClosed Ω]
    (σ τ : FractionRing (MvPolynomial n K) →ₐ[K] Ω)
    (h_agree : ∀ x : (pullback_frac p h_surj).fieldRange, σ x = τ x) :
    σ = τ := by
      -- By `eval_eq_of_embedding_eq_on_range`, `p(v₁) = p(v₂)`.
      have h_eval_eq : ∀ i, MvPolynomial.eval₂ (algebraMap K Ω) (point_of_embedding σ) (p i) = MvPolynomial.eval₂ (algebraMap K Ω) (point_of_embedding τ) (p i) := by
        apply_rules [ eval_eq_of_embedding_eq_on_range ];
      have h_point_eq : point_of_embedding σ = point_of_embedding τ := by
        apply injective_of_isAlgClosed_of_injective p h_inj |> fun h => h (by
        exact funext h_eval_eq);
      exact?

#check injective_poly_map_surjective
#check embeddings_eq_of_injective
#check exists_distinct_embeddings_of_geometric_degree_gt_one

/-
If a polynomial map is injective, its geometric degree is at most 1.
-/
lemma geometric_degree_le_one_of_injective {K : Type*} [Field K] [IsAlgClosed K] [CharZero K] {n : Type*} [Fintype n]
    (p : n → MvPolynomial n K) (h_inj : Function.Injective (fun v i => MvPolynomial.eval v (p i))) :
    geometric_degree p (injective_poly_map_surjective _ (isPolyMap_eval p) h_inj) ≤ 1 := by
      refine' Nat.le_of_not_lt fun h => _;
      -- By `exists_distinct_embeddings_of_geometric_degree_gt_one`, we get `σ, τ` distinct embeddings of `FractionRing (MvPolynomial n K)` into its algebraic closure over `(pullback_frac p h_surj).fieldRange`.
      obtain ⟨σ, τ, hστ⟩ : ∃ σ τ : FractionRing (MvPolynomial n K) →ₐ[(pullback_frac p (injective_poly_map_surjective _ (isPolyMap_eval p) h_inj)).fieldRange] AlgebraicClosure (FractionRing (MvPolynomial n K)), σ ≠ τ := by
        convert exists_distinct_embeddings_of_geometric_degree_gt_one p _ h;
      -- Being embeddings over the field range means they agree on the field range.
      have h_agree : ∀ x : (pullback_frac p (injective_poly_map_surjective _ (isPolyMap_eval p) h_inj)).fieldRange, σ x = τ x := by
        simp +decide [ Subtype.ext_iff ];
        intro a;
        convert σ.commutes ⟨ _, ⟨ a, rfl ⟩ ⟩ using 1;
        convert τ.commutes ⟨ _, ⟨ a, rfl ⟩ ⟩ using 1;
      apply hστ;
      convert embeddings_eq_of_injective p ( injective_poly_map_surjective _ ( isPolyMap_eval p ) h_inj ) h_inj ( AlgebraicClosure ( FractionRing ( MvPolynomial n K ) ) ) ( σ.restrictScalars K ) ( τ.restrictScalars K ) _ using 1;
      any_goals tauto;
      any_goals exact algebra_K_range p ( injective_poly_map_surjective _ ( isPolyMap_eval p ) h_inj );
      all_goals try infer_instance;
      simp +decide [ AlgHom.ext_iff ]

/-
If a polynomial map is injective, the polynomials are algebraically independent.
-/
lemma p_algebraically_independent_of_injective {K : Type*} [Field K] [IsAlgClosed K] {n : Type*} [Fintype n]
    (p : n → MvPolynomial n K) (h_inj : Function.Injective (fun v i => MvPolynomial.eval v (p i))) :
    AlgebraicIndependent K p := by
      convert p_algebraically_independent_of_surjective p _;
      exact?

#check Algebra.trdeg
#check Cardinal.lift
#check Cardinal.mk

/-
The transcendence degree of the polynomial ring is n.
-/
universe u v

lemma trdeg_mvPolynomial_eq_card_aux {K : Type u} [Field K] {n : Type v} [Fintype n] :
    Algebra.trdeg K (MvPolynomial n K) = Cardinal.lift.{u, v} (Cardinal.mk n) := by
      exact?

/-
The transcendence degree of the fraction ring is equal to the transcendence degree of the ring.
-/
lemma trdeg_fractionRing_eq_trdeg {K : Type u} [Field K] {A : Type v} [CommRing A] [IsDomain A] [Algebra K A] :
    Algebra.trdeg K (FractionRing A) = Algebra.trdeg K A := by
      -- Since $FractionRing A$ is algebraic over $A$, the transcendence degree of $FractionRing A$ over $A$ is zero.
      have h_frac_alg : Algebra.IsAlgebraic A (FractionRing A) := by
        refine' ⟨ fun x => _ ⟩;
        induction x using Localization.induction_on;
        rename_i x;
        refine' ⟨ Polynomial.X * Polynomial.C ( x.2 : A ) - Polynomial.C ( x.1 : A ), _, _ ⟩ <;> simp +decide [ Polynomial.eval₂_sub, Polynomial.eval₂_mul, Polynomial.eval₂_X, Polynomial.eval₂_C ];
        · exact ne_of_apply_ne ( fun p => p.coeff 1 ) ( by simp +decide [ Polynomial.coeff_eq_zero_of_natDegree_lt ] );
        · rw [ mul_div_cancel₀ ] <;> aesop;
      have h_frac_alg : Algebra.trdeg A (FractionRing A) = 0 := by
        exact?;
      have h_frac_alg : Algebra.trdeg K (FractionRing A) = Algebra.trdeg K A + Algebra.trdeg A (FractionRing A) := by
        exact?;
      aesop

/-
The transcendence degree of the fraction ring of polynomials is n.
-/
lemma trdeg_mvPolynomial_eq_card {K : Type u} [Field K] {n : Type v} [Fintype n] :
    Algebra.trdeg K (FractionRing (MvPolynomial n K)) = Cardinal.lift.{u, v} (Cardinal.mk n) := by
  rw [trdeg_fractionRing_eq_trdeg]
  exact trdeg_mvPolynomial_eq_card_aux

/-
The fraction ring is isomorphic to the field range of the pullback map.
-/
noncomputable def fieldRange_equiv {K : Type u} [Field K] [IsAlgClosed K] {n : Type v} [Fintype n]
    (p : n → MvPolynomial n K) (h_inj : Function.Injective (fun v i => MvPolynomial.eval v (p i))) :
    let h_surj := injective_poly_map_surjective _ (isPolyMap_eval p) h_inj
    let S := (pullback_frac p h_surj).fieldRange
    letI := algebra_K_range p h_surj
    FractionRing (MvPolynomial n K) ≃ₐ[K] S := by
  let h_surj := injective_poly_map_surjective _ (isPolyMap_eval p) h_inj
  let f := pullback_frac p h_surj
  let e := RingHom.rangeRestrictFieldEquiv f
  letI := algebra_K_range p h_surj
  refine' {
    toFun := e.toFun
    invFun := e.invFun
    left_inv := e.left_inv
    right_inv := e.right_inv
    map_mul' := e.map_mul
    map_add' := e.map_add
    commutes' := _
  }
  intro r
  apply Subtype.ext
  exact pullback_frac_fixes_K p h_surj r

/-
If a polynomial map is injective, the transcendence degree of its image is n.
-/
lemma trdeg_range_eq_card_of_injective {K : Type u} [Field K] [IsAlgClosed K] {n : Type v} [Fintype n]
    (p : n → MvPolynomial n K) (h_inj : Function.Injective (fun v i => MvPolynomial.eval v (p i))) :
    let h_surj := injective_poly_map_surjective _ (isPolyMap_eval p) h_inj
    @Algebra.trdeg K (pullback_frac p h_surj).fieldRange _ _ (algebra_K_range p h_surj) = Cardinal.lift.{u, v} (Cardinal.mk n) := by
      -- By definition of `fieldRange_equiv`, the transcendence degrees of the domain and codomain are equal.
      apply Eq.symm;
      convert trdeg_mvPolynomial_eq_card.symm;
      convert ( AlgEquiv.trdeg_eq ( fieldRange_equiv p h_inj |> AlgEquiv.symm ) ) using 1;
      infer_instance

#check injective_poly_map_surjective
#check trdeg_range_eq_card_of_injective
#check geometric_degree_le_one_of_injective
#check geometric_degree_inj

#check trdeg_mvPolynomial_eq_card

/-
The pullback map on the fraction ring as an algebra homomorphism.
-/
noncomputable def pullback_frac_algHom {K : Type*} [Field K] [IsAlgClosed K] {n : Type*} [Fintype n]
    (p : n → MvPolynomial n K) (h_surj : Function.Surjective (fun v i => MvPolynomial.eval v (p i))) :
    FractionRing (MvPolynomial n K) →ₐ[K] FractionRing (MvPolynomial n K) :=
  { pullback_frac p h_surj with
    commutes' := pullback_frac_fixes_K p h_surj }

#check Cardinal.lift

/-
Isomorphic algebras have the same transcendence degree.
-/
universe uK uA uB

lemma trdeg_eq_of_algEquiv {K : Type uK} {A : Type uA} {B : Type uB} [Field K] [CommRing A] [CommRing B] [Algebra K A] [Algebra K B]
    (e : A ≃ₐ[K] B) : Cardinal.lift.{uB, uA} (Algebra.trdeg K A) = Cardinal.lift.{uA, uB} (Algebra.trdeg K B) := by
      exact?

/-
The image of the pullback map is isomorphic to the fraction ring.
-/
noncomputable def range_equiv {K : Type*} [Field K] [IsAlgClosed K] {n : Type*} [Fintype n]
    (p : n → MvPolynomial n K) (h_surj : Function.Surjective (fun v i => MvPolynomial.eval v (p i))) :
    letI := algebra_K_range p h_surj
    FractionRing (MvPolynomial n K) ≃ₐ[K] (pullback_frac p h_surj).fieldRange :=
  letI := algebra_K_range p h_surj
  let f := pullback_frac p h_surj
  AlgEquiv.ofRingEquiv (f := RingHom.rangeRestrictFieldEquiv f) (fun x => by
    apply Subtype.ext
    rw [RingHom.rangeRestrictFieldEquiv_apply_coe]
    rw [pullback_frac_fixes_K p h_surj x]
    rfl)

/-
If the polynomial map is surjective, the transcendence degree of the image is n.
-/
lemma trdeg_range_eq_of_surjective {K : Type u} [Field K] [IsAlgClosed K] {n : Type v} [Fintype n]
    (p : n → MvPolynomial n K) (h_surj : Function.Surjective (fun v i => MvPolynomial.eval v (p i))) :
    let S := (pullback_frac p h_surj).fieldRange
    letI := algebra_K_range p h_surj
    Algebra.trdeg K S = Cardinal.lift.{u, v} (Cardinal.mk n) := by
      simp +zetaDelta at *;
      convert trdeg_mvPolynomial_eq_card ( K := K ) ( n := n ) using 1;
      · symm;
        convert trdeg_eq_of_algEquiv ( range_equiv p h_surj ) using 1;
        · simp +zetaDelta at *;
        · simp +decide [ Cardinal.lift_id ];
      · simp +decide [ Cardinal.mk_fintype ]

/-
If a subfield has the same finite transcendence degree as the field, the extension is algebraic.
-/
lemma isAlgebraic_of_trdeg_eq {K L : Type*} [Field K] [Field L] [Algebra K L]
    (S : Subfield L) [Algebra K S] [IsScalarTower K S L]
    (h_trdeg : Algebra.trdeg K S = Algebra.trdeg K L)
    (h_finite : Algebra.trdeg K L < Cardinal.aleph0) :
    Algebra.IsAlgebraic S L := by
      have h_transcendence_deg : Algebra.trdeg K L = Algebra.trdeg K S + Algebra.trdeg S L := by
        exact?;
      have h_transcendence_deg_zero : Algebra.trdeg S L = 0 := by
        rw [ h_trdeg ] at h_transcendence_deg;
        rw [ eq_comm ] at h_transcendence_deg;
        rw [ Cardinal.add_eq_left_iff ] at h_transcendence_deg;
        exact h_transcendence_deg.resolve_left fun h => h_finite.not_le <| le_trans ( le_max_left _ _ ) h;
      exact?

/-
If the pullback map is surjective, its extension to fraction rings is surjective.
-/
lemma pullback_frac_surjective_of_surjective {K : Type*} [Field K] [IsAlgClosed K] {n : Type*} [Fintype n]
    (p : n → MvPolynomial n K) (h_surj_map : Function.Surjective (fun v i => MvPolynomial.eval v (p i)))
    (h_surj_pullback : Function.Surjective (pullback p)) :
    Function.Surjective (pullback_frac p h_surj_map) := by
      -- Since the pullback map is surjective, the extension of the isomorphism is also surjective, hence an isomorphism.
      have h_iso : Function.Bijective (pullback p) := by
        exact?;
      have h_iso_frac : Function.Bijective (pullback_frac p h_surj_map) := by
        convert RingEquiv.bijective ( IsFractionRing.ringEquivOfRingEquiv ( RingEquiv.ofBijective ( pullback p ) h_iso ) ) using 1;
        infer_instance;
      exact h_iso_frac.2

/-
If a subfield has the same finite transcendence degree as the field, the extension is algebraic.
-/
lemma isAlgebraic_of_trdeg_eq_aux {K L : Type*} [Field K] [Field L] [Algebra K L]
    (S : Subfield L) [Algebra K S] [IsScalarTower K S L]
    (h_trdeg : Algebra.trdeg K S = Algebra.trdeg K L)
    (h_finite : Algebra.trdeg K L < Cardinal.aleph0) :
    Algebra.IsAlgebraic S L := by
      convert isAlgebraic_of_trdeg_eq S h_trdeg h_finite using 1

/-
The fraction ring of polynomials in finitely many variables is finitely generated as a field.
-/
lemma fraction_ring_fg {K : Type*} [Field K] {n : Type*} [Fintype n] :
    (⊤ : IntermediateField K (FractionRing (MvPolynomial n K))).FG := by
  rw [IntermediateField.fg_def]
  use Set.range (algebraMap (MvPolynomial n K) (FractionRing (MvPolynomial n K)) ∘ MvPolynomial.X)
  constructor
  · rw [Set.range_comp]
    apply Set.Finite.image
    exact Set.toFinite (Set.range MvPolynomial.X)
  ·
    refine' top_unique fun x hx => _;
    obtain ⟨ p, q, hpq ⟩ := IsLocalization.mk'_surjective ( nonZeroDivisors ( MvPolynomial n K ) ) x;
    -- Since $p$ and $q$ are polynomials, they can be written as sums of monomials, and each monomial is a product of the variables $X_i$.
    have hpq_in_adjoin : ∀ (p : MvPolynomial n K), algebraMap (MvPolynomial n K) (FractionRing (MvPolynomial n K)) p ∈ IntermediateField.adjoin K (Set.range (algebraMap (MvPolynomial n K) (FractionRing (MvPolynomial n K)) ∘ MvPolynomial.X)) := by
      intro p
      induction' p using MvPolynomial.induction_on with p hp ih;
      · exact Subalgebra.algebraMap_mem _ _;
      · simpa using Subalgebra.add_mem _ ‹ ( algebraMap ( MvPolynomial n K ) ( FractionRing ( MvPolynomial n K ) ) ) hp ∈ IntermediateField.adjoin K ( Set.range ( algebraMap ( MvPolynomial n K ) ( FractionRing ( MvPolynomial n K ) ) ∘ MvPolynomial.X ) ) › ‹ ( algebraMap ( MvPolynomial n K ) ( FractionRing ( MvPolynomial n K ) ) ) ih ∈ IntermediateField.adjoin K ( Set.range ( algebraMap ( MvPolynomial n K ) ( FractionRing ( MvPolynomial n K ) ) ∘ MvPolynomial.X ) ) ›;
      · simp +zetaDelta at *;
        exact MulMemClass.mul_mem ‹_› ( IntermediateField.subset_adjoin _ _ ⟨ _, rfl ⟩ );
    convert Subfield.div_mem _ ( hpq_in_adjoin p ) ( hpq_in_adjoin q ) using 1 ; aesop

/-
If a field extension is finitely generated over a base field, it is finitely generated over any intermediate field.
-/
lemma IntermediateField.FG.of_subfield {K L : Type*} [Field K] [Field L] [Algebra K L]
    (S : Subfield L) [Algebra K S] [IsScalarTower K S L]
    (h : (⊤ : IntermediateField K L).FG) :
    (⊤ : IntermediateField S L).FG := by
      exact?

/-
If a polynomial map is injective, the fraction ring is algebraic over the image of the pullback.
-/
lemma isAlgebraic_of_injective {K : Type*} [Field K] [IsAlgClosed K] [CharZero K] {n : Type*} [Fintype n]
    (p : n → MvPolynomial n K) (h_inj : Function.Injective (fun v i => MvPolynomial.eval v (p i))) :
    let h_surj := injective_poly_map_surjective _ (isPolyMap_eval p) h_inj
    let S := (pullback_frac p h_surj).fieldRange
    let L := FractionRing (MvPolynomial n K)
    letI := algebra_K_range p h_surj
    Algebra.IsAlgebraic S L := by
      convert isAlgebraic_of_trdeg_eq _ _ _;
      exact K;
      exact?;
      exact inferInstance;
      exact?;
      · exact?;
      · convert trdeg_range_eq_card_of_injective p h_inj;
        convert trdeg_mvPolynomial_eq_card;
        infer_instance;
      · rw [ trdeg_mvPolynomial_eq_card ];
        exact Cardinal.lift_lt_aleph0.mpr ( Cardinal.lt_aleph0_iff_finite.mpr ( by infer_instance ) )

/-
If a polynomial map is injective, the fraction ring is a finite dimensional vector space over the image of the pullback.
-/
lemma finiteDimensional_of_injective {K : Type*} [Field K] [IsAlgClosed K] [CharZero K] {n : Type*} [Fintype n]
    (p : n → MvPolynomial n K) (h_inj : Function.Injective (fun v i => MvPolynomial.eval v (p i))) :
    let h_surj := injective_poly_map_surjective _ (isPolyMap_eval p) h_inj
    let S := (pullback_frac p h_surj).fieldRange
    let L := FractionRing (MvPolynomial n K)
    letI := algebra_K_range p h_surj
    FiniteDimensional S L := by
      convert isAlgebraic_of_injective p h_inj;
      constructor <;> intro h;
      · exact?;
      · have h_fg : (⊤ : IntermediateField (↥(pullback_frac p (injective_poly_map_surjective _ (isPolyMap_eval p) h_inj)).fieldRange) (FractionRing (MvPolynomial n K))).FG := by
          convert IntermediateField.FG.of_subfield _ _;
          exact K;
          all_goals try infer_instance;
          exact?;
          · exact?;
          · exact?;
        convert IntermediateField.finite_of_fg_of_isAlgebraic;
        rotate_left;
        exact ↥ ( pullback_frac p ( injective_poly_map_surjective _ ( isPolyMap_eval p ) h_inj ) ).fieldRange;
        exact?;
        exact FractionRing ( MvPolynomial n K );
        exact?;
        exact?;
        exact?

/-
If a polynomial map is injective, its geometric degree is 1.
-/
lemma geometric_degree_eq_one_of_injective {K : Type*} [Field K] [IsAlgClosed K] [CharZero K] {n : Type*} [Fintype n]
    (p : n → MvPolynomial n K) (h_inj : Function.Injective (fun v i => MvPolynomial.eval v (p i))) :
    geometric_degree p (injective_poly_map_surjective _ (isPolyMap_eval p) h_inj) = 1 := by
      -- Since $L$ is a field extension of $S$, $Module.finrank S L \geq 1$ (specifically $> 0$).
      have h_finrank_pos : let S := (pullback_frac p (injective_poly_map_surjective _ (isPolyMap_eval p) h_inj)).fieldRange; let L := FractionRing (MvPolynomial n K); letI := algebra_K_range p (injective_poly_map_surjective _ (isPolyMap_eval p) h_inj); 0 < Module.finrank S L := by
        convert Module.finrank_pos_iff.mpr _;
        · infer_instance;
        · convert finiteDimensional_of_injective p h_inj using 1;
        · exact?;
        · infer_instance;
      exact le_antisymm ( le_of_not_gt fun h => by have := geometric_degree_le_one_of_injective p h_inj; linarith! ) h_finrank_pos

/-
If two polynomials are coprime and the zeros of one are contained in the zeros of the other, the first is a unit.
-/
lemma isUnit_of_isCoprime_of_zeros_subset {K : Type*} [Field K] [IsAlgClosed K] {n : Type*} [Fintype n]
    (A B : MvPolynomial n K) (h_coprime : IsCoprime A B)
    (h_zeros : ∀ v, MvPolynomial.eval v B = 0 → MvPolynomial.eval v A = 0) :
    IsUnit B := by
      contrapose! h_zeros with h_zeros_inj
      generalize_proofs at *; (
      -- By Hilbert's Nullstellensatz, since $B$ is not a unit, $V(B)$ is nonempty.
      have h_VB_nonempty : ∃ v : n → K, MvPolynomial.eval v B = 0 := by
        -- By contradiction, assume there is no zero of $B$.
        by_contra h_no_zero
        generalize_proofs at *; (
        -- By Hilbert's Nullstellensatz, since $B$ is not a unit, $V(B)$ is nonempty. Hence, $B$ must be a unit.
        have h_unit : IsUnit B := by
          convert isUnit_of_forall_eval_ne_zero B ( fun v => fun h => h_no_zero ⟨ v, h ⟩ ) using 1
          skip
        generalize_proofs at *; (
        exact h_zeros_inj h_unit))
      generalize_proofs at *; (
      obtain ⟨ v, hv ⟩ := h_VB_nonempty
      obtain ⟨ a, b, h ⟩ := h_coprime
      have := congr_arg ( MvPolynomial.eval v ) h
      simp [ hv ] at this
      exact ⟨ v, hv, by aesop ⟩))

/-
If a polynomial map is surjective, its pullback is injective.
-/
theorem pullback_injective' {K : Type*} [Field K] [IsAlgClosed K] {n : Type*} [Fintype n]
    (p : n → MvPolynomial n K) (h_surj : Function.Surjective (fun v i => MvPolynomial.eval v (p i))) :
    Function.Injective (pullback p) := by
      exact?

/-
If two polynomials a and b have gcd 1, and the zeros of b are contained in the zeros of a, then b is a unit.
-/
noncomputable instance mvPolynomial_gcdMonoid {K : Type*} [Field K] {n : Type*} [Fintype n] : GCDMonoid (MvPolynomial n K) :=
  UniqueFactorizationMonoid.toGCDMonoid (MvPolynomial n K)

lemma isUnit_of_gcd_eq_one_of_zeros_subset {K : Type*} [Field K] [IsAlgClosed K] {n : Type*} [Fintype n]
    (a b : MvPolynomial n K) (h_gcd : GCDMonoid.gcd a b = 1)
    (h_zeros : ∀ v, MvPolynomial.eval v b = 0 → MvPolynomial.eval v a = 0) :
    IsUnit b := by
      by_contra hb_not_unit;
      -- Since $b$ is not a unit, there exists an irreducible factor $p$ of $b$.
      obtain ⟨p, hp_irreducible, hp_div_b⟩ : ∃ p : MvPolynomial n K, Irreducible p ∧ p ∣ b := by
        have h_factor : ∃ p : MvPolynomial n K, Irreducible p ∧ p ∣ b := by
          have h_nonzero : b ≠ 0 := by
            intro hb_zero
            simp [hb_zero] at h_gcd h_zeros hb_not_unit;
            -- Since $a$ is zero, its gcd with any polynomial, including zero, should be zero. But $h_gcd$ says it's 1. This is a contradiction.
            have h_contra : gcd a 0 = 0 := by
              rw [ show a = 0 from MvPolynomial.funext fun x => by simp +decide [ h_zeros ] ] ; simp +decide [ gcd_zero_left ] ;
            generalize_proofs at *;
            aesop
            skip
          have h_not_unit : ¬IsUnit b := hb_not_unit
          convert WfDvdMonoid.exists_irreducible_factor h_not_unit h_nonzero;
        exact h_factor;
      -- Since $p$ divides $b$ and $b$ divides $a$, $p$ must also divide $a$.
      have hp_div_a : p ∣ a := by
        -- By the Nullstellensatz, since $p$ is irreducible and $Zeros(p) \subseteq Zeros(a)$, we have $p \mid a^k$ for some $k$.
        obtain ⟨k, hk⟩ : ∃ k : ℕ, p ∣ a ^ k := by
          have h_nullstellensatz : ∀ {I : Ideal (MvPolynomial n K)}, I.radical = I.radical → ∀ {f : MvPolynomial n K}, (∀ v : n → K, (∀ g ∈ I, MvPolynomial.eval v g = 0) → MvPolynomial.eval v f = 0) → f ∈ I.radical := by
            have := @MvPolynomial.vanishingIdeal_zeroLocus_eq_radical K;
            intro I _ f hf; specialize @this K _ _ _ n _ _ I; simp_all +decide [ MvPolynomial.vanishingIdeal ] ;
            exact this ▸ hf;
          specialize @h_nullstellensatz ( Ideal.span { p } ) rfl a;
          simp_all +decide [ Ideal.mem_span_singleton ];
          exact Exists.elim h_nullstellensatz fun k hk => ⟨ k, by simpa [ Ideal.mem_span_singleton ] using hk ⟩;
        exact hp_irreducible.prime.dvd_of_dvd_pow hk |> fun h => by aesop;
      have := GCDMonoid.dvd_gcd hp_div_a hp_div_b; simp_all +decide [ EuclideanDomain.mod_eq_zero ] ;
      exact hp_irreducible.not_dvd_one this

/-
Every element of the fraction ring can be written as a fraction of two elements whose gcd is a unit.
-/
lemma exists_fraction_with_unit_gcd {R : Type*} [CommRing R] [IsDomain R] [GCDMonoid R] (x : FractionRing R) :
    ∃ a b : R, IsUnit (GCDMonoid.gcd a b) ∧ b ≠ 0 ∧ x = algebraMap R (FractionRing R) a / algebraMap R (FractionRing R) b := by
      -- By definition of fraction rings, every element x can be written as a/b for some a, b in R with b ≠ 0.
      obtain ⟨a, b, hb, hx⟩ : ∃ a b : R, b ≠ 0 ∧ x = (algebraMap R (FractionRing R) a) / (algebraMap R (FractionRing R) b) := by
        rcases IsLocalization.mk'_surjective ( nonZeroDivisors R ) x with ⟨ a, b, rfl ⟩ ; use a, b ; aesop;
      -- Let $d$ be a gcd of $a$ and $b$, so $d \mid a$ and $d \mid b$.
      obtain ⟨d, hd⟩ : ∃ d : R, d ∣ a ∧ d ∣ b ∧ (∀ c : R, c ∣ a ∧ c ∣ b → c ∣ d) := by
        exact ⟨ GCDMonoid.gcd a b, GCDMonoid.gcd_dvd_left _ _, GCDMonoid.gcd_dvd_right _ _, fun c hc => GCDMonoid.dvd_gcd hc.1 hc.2 ⟩;
      -- Write $a = d a'$ and $b = d b'$ for some $a', b' \in R$.
      obtain ⟨a', ha'⟩ : ∃ a' : R, a = d * a' := hd.left
      obtain ⟨b', hb'⟩ : ∃ b' : R, b = d * b' := hd.right.left
      generalize_proofs at *; (
      refine' ⟨ a', b', _, _, _ ⟩ <;> simp_all +decide [ mul_assoc, mul_comm, mul_left_comm, div_eq_mul_inv ];
      · -- Since $d$ is a gcd of $a$ and $b$, and $d \mid a'$ and $d \mid b'$, it follows that $d$ is a unit.
        have h_unit : ∀ c : R, c ∣ a' → c ∣ b' → c ∣ 1 := by
          intro c hc₁ hc₂
          have h_div_d : c * d ∣ d := by
            exact hd _ ( by simpa only [ mul_comm ] using mul_dvd_mul_left d hc₁ ) ( by simpa only [ mul_comm ] using mul_dvd_mul_left d hc₂ ) |> fun h => by simpa only [ mul_comm ] using h;
          generalize_proofs at *; (
          exact Exists.elim h_div_d fun x hx => ⟨ x, mul_left_cancel₀ hb.1 <| by linear_combination' hx ⟩)
        generalize_proofs at *; (
        exact isUnit_of_dvd_one ( h_unit _ ( GCDMonoid.gcd_dvd_left _ _ ) ( GCDMonoid.gcd_dvd_right _ _ ) ));
      · simp +decide [ mul_left_comm ( algebraMap R ( FractionRing R ) d ), mul_assoc, hb.1 ])

/-
If pullback p a = X_i * pullback p b and p is surjective, then Zeros(b) is contained in Zeros(a).
-/
lemma zeros_subset_of_pullback_eq_mul {K : Type*} [Field K] [IsAlgClosed K] {n : Type*} [Fintype n]
    (p : n → MvPolynomial n K) (h_surj : Function.Surjective (fun v i => MvPolynomial.eval v (p i)))
    (a b : MvPolynomial n K) (i : n)
    (h_eq : pullback p a = MvPolynomial.X i * pullback p b) :
    ∀ v, MvPolynomial.eval v b = 0 → MvPolynomial.eval v a = 0 := by
      -- By definition of pullback, we have that for any w, MvPolynomial.eval w (pullback p a) = MvPolynomial.eval (fun i => MvPolynomial.eval w (p i)) a.
      have h_eval_pullback : ∀ w : n → K, MvPolynomial.eval w (pullback p a) = MvPolynomial.eval (fun i => MvPolynomial.eval w (p i)) a := by
        exact?;
      intro v hv; specialize h_surj v; obtain ⟨ w, rfl ⟩ := h_surj; simp_all +decide [ MvPolynomial.eval_mul, MvPolynomial.eval_X ] ;
      -- Since $MvPolynomial.eval w (pullback p b) = 0$, we have $MvPolynomial.eval (fun i => (MvPolynomial.eval w) (p i)) b = 0$.
      have h_eval_pullback_b : MvPolynomial.eval w (pullback p b) = 0 := by
        convert hv using 1;
        exact?;
      rw [ ← h_eval_pullback w, h_eval_pullback_b, MulZeroClass.mul_zero ]

/-
If a polynomial map is injective, the induced map on the fraction ring is surjective.
-/
lemma pullback_frac_surjective_of_injective {K : Type*} [Field K] [IsAlgClosed K] [CharZero K] {n : Type*} [Fintype n]
    (p : n → MvPolynomial n K) (h_inj : Function.Injective (fun v i => MvPolynomial.eval v (p i))) :
    Function.Surjective (pullback_frac p (injective_poly_map_surjective _ (isPolyMap_eval p) h_inj)) := by
  let h_surj := injective_poly_map_surjective _ (isPolyMap_eval p) h_inj
  have h_deg : geometric_degree p h_surj = 1 := geometric_degree_eq_one_of_injective p h_inj
  have h_range : (pullback_frac p h_surj).fieldRange = ⊤ := Subfield.eq_top_of_finrank_eq_one _ h_deg
  rw [← RingHom.fieldRange_eq_top_iff]
  exact h_range

/-
If gcd(a, b) is a unit and Zeros(b) ⊆ Zeros(a), then b is a unit.
-/
lemma isUnit_of_isUnit_gcd_of_zeros_subset {K : Type*} [Field K] [IsAlgClosed K] {n : Type*} [Fintype n]
    (a b : MvPolynomial n K) (h_gcd : IsUnit (GCDMonoid.gcd a b))
    (h_zeros : ∀ v, MvPolynomial.eval v b = 0 → MvPolynomial.eval v a = 0) :
    IsUnit b := by
      -- If b is not a unit, it has an irreducible factor p.
      by_contra h_not_unit
      obtain ⟨p, hp_irr, hp_div⟩ : ∃ p : MvPolynomial n K, Irreducible p ∧ p ∣ b := by
        convert WfDvdMonoid.exists_irreducible_factor h_not_unit _;
        intro h; simp_all +decide [ gcd_eq_zero_iff ] ;
        -- Since $a$ is zero, its gcd with any polynomial is zero, which contradicts $h_gcd$ being a unit.
        have h_contra : gcd a 0 = 0 := by
          rw [ show a = 0 from _ ] ; simp +decide [ h_zeros ];
          exact?;
        aesop;
      -- Since p is irreducible (hence prime), p divides a^k for some k.
      obtain ⟨k, hk⟩ : ∃ k : ℕ, p ∣ a ^ k := by
        have h_nullstellensatz : ∀ {I : Ideal (MvPolynomial n K)}, I ≠ ⊤ → ∀ {f : MvPolynomial n K}, (∀ v : n → K, (∀ g ∈ I, MvPolynomial.eval v g = 0) → MvPolynomial.eval v f = 0) → ∃ k : ℕ, f ^ k ∈ I := by
          intro I hI f hf;
          have := @MvPolynomial.vanishingIdeal_zeroLocus_eq_radical K;
          specialize @this K _ _ _ n _ _ I;
          replace this := SetLike.ext_iff.mp this f; simp_all +decide [ MvPolynomial.vanishingIdeal, MvPolynomial.zeroLocus ] ;
          exact this.mp ( by simpa [ MvPolynomial.aeval_def ] using hf ) |> fun ⟨ k, hk ⟩ => ⟨ k, hk ⟩;
        specialize @h_nullstellensatz ( Ideal.span { p } ) ?_ a ?_ <;> simp_all +decide [ Ideal.mem_span_singleton ];
        exact hp_irr.not_isUnit;
      -- Since p is irreducible (hence prime), p divides a.
      have h_div_a : p ∣ a := by
        have h_prime : Prime p := by
          rwa [ ← UniqueFactorizationMonoid.irreducible_iff_prime ];
        exact h_prime.dvd_of_dvd_pow hk;
      exact hp_irr.not_isUnit ( isUnit_of_dvd_unit ( GCDMonoid.dvd_gcd h_div_a hp_div ) h_gcd )

/-
If pullback p a = X_i * pullback p b and gcd(a, b) is a unit, then b is a unit.
-/
lemma isUnit_of_pullback_eq_mul_X {K : Type*} [Field K] [IsAlgClosed K] {n : Type*} [Fintype n]
    (p : n → MvPolynomial n K) (h_surj : Function.Surjective (fun v i => MvPolynomial.eval v (p i)))
    (a b : MvPolynomial n K) (i : n)
    (h_eq : pullback p a = MvPolynomial.X i * pullback p b)
    (h_gcd : IsUnit (GCDMonoid.gcd a b)) :
    IsUnit b := by
  have h_zeros : ∀ v, MvPolynomial.eval v b = 0 → MvPolynomial.eval v a = 0 :=
    zeros_subset_of_pullback_eq_mul p h_surj a b i h_eq
  exact isUnit_of_isUnit_gcd_of_zeros_subset a b h_gcd h_zeros

/-
If a polynomial map is injective, its pullback is surjective.
-/
theorem pullback_surjective_of_injective {K : Type*} [Field K] [IsAlgClosed K] [CharZero K] {n : Type*} [Fintype n]
    (p : n → MvPolynomial n K) (h_inj : Function.Injective (fun v i => MvPolynomial.eval v (p i))) :
    Function.Surjective (pullback p) := by
      have h_surjective : ∀ i, ∃ q : MvPolynomial n K, pullback p q = MvPolynomial.X i := by
        intro i
        obtain ⟨q, hq⟩ : ∃ q : FractionRing (MvPolynomial n K), pullback_frac p (injective_poly_map_surjective _ (isPolyMap_eval p) h_inj) q = algebraMap (MvPolynomial n K) (FractionRing (MvPolynomial n K)) (MvPolynomial.X i) := by
          apply_rules [ Function.Surjective.hasRightInverse, pullback_frac_surjective_of_injective ]
        generalize_proofs at *; (
        obtain ⟨a, b, h_gcd, hb_ne_zero, hq_eq⟩ : ∃ a b : MvPolynomial n K, IsUnit (GCDMonoid.gcd a b) ∧ b ≠ 0 ∧ q = algebraMap (MvPolynomial n K) (FractionRing (MvPolynomial n K)) a / algebraMap (MvPolynomial n K) (FractionRing (MvPolynomial n K)) b := by
          exact?
        generalize_proofs at *; (
        -- Then $\phi(a) = X_i \phi(b)$.
        have h_eq : pullback p a = MvPolynomial.X i * pullback p b := by
          have h_eq : pullback_frac p (injective_poly_map_surjective _ (isPolyMap_eval p) h_inj) (algebraMap (MvPolynomial n K) (FractionRing (MvPolynomial n K)) a) = algebraMap (MvPolynomial n K) (FractionRing (MvPolynomial n K)) (MvPolynomial.X i) * pullback_frac p (injective_poly_map_surjective _ (isPolyMap_eval p) h_inj) (algebraMap (MvPolynomial n K) (FractionRing (MvPolynomial n K)) b) := by
            rw [ ← hq, hq_eq, map_div₀, div_mul_cancel₀ ] ; aesop
            skip
          generalize_proofs at *; (
          have h_eq : algebraMap (MvPolynomial n K) (FractionRing (MvPolynomial n K)) (pullback p a) = algebraMap (MvPolynomial n K) (FractionRing (MvPolynomial n K)) (MvPolynomial.X i * pullback p b) := by
            convert h_eq using 1
            generalize_proofs at *; (
            unfold pullback_frac; aesop;);
            unfold pullback_frac; aesop;
          generalize_proofs at *; (
          exact ( IsFractionRing.injective ( MvPolynomial n K ) ( FractionRing ( MvPolynomial n K ) ) ) h_eq))
        generalize_proofs at *; (
        -- Since $\gcd(a, b)$ is a unit, $b$ is a unit.
        have h_b_unit : IsUnit b := by
          apply isUnit_of_isUnit_gcd_of_zeros_subset a b h_gcd (fun v hv => by
            apply zeros_subset_of_pullback_eq_mul p ‹_› a b i h_eq v hv |> fun h => by
              exact h
            skip)
        generalize_proofs at *; (
        obtain ⟨ u, hu ⟩ := h_b_unit.exists_left_inv; use a * u; simp_all +decide [ mul_assoc, mul_comm, mul_left_comm ] ;
        rw [ ← map_mul, hu, map_one ]))));
      intro b
      induction' b using MvPolynomial.induction_on with i b hb ih;
      · exact ⟨ MvPolynomial.C i, by simp +decide [ pullback ] ⟩;
      · exact ⟨ ih.choose + ‹∃ a, ( pullback p ) a = hb›.choose, by rw [ map_add, ih.choose_spec, ‹∃ a, ( pullback p ) a = hb›.choose_spec ] ⟩;
      · obtain ⟨ q, hq ⟩ := h_surjective ‹_›
        obtain ⟨ r, hr ⟩ := ‹∃ a, (pullback p) a = _›
        use r * q
        simp [hq, hr]

/-
If a polynomial map is injective, its pullback is surjective.
-/
theorem pullback_surjective_of_injective' {K : Type*} [Field K] [IsAlgClosed K] [CharZero K] {n : Type*} [Fintype n]
    (p : n → MvPolynomial n K) (h_inj : Function.Injective (fun v i => MvPolynomial.eval v (p i))) :
    Function.Surjective (pullback p) := by
      -- Apply the theorem that states the pullback map is surjective if the polynomial map is injective.
      apply pullback_surjective_of_injective p h_inj

/-
An injective polynomial map has a polynomial inverse.
-/
theorem injective_poly_map_has_poly_inverse {K : Type*} [Field K] [IsAlgClosed K] [CharZero K] {n : Type*} [Fintype n]
    (f : (n → K) → (n → K)) (hf : IsPolyMap f) (hinj : Function.Injective f) :
    ∃ g : (n → K) → (n → K), IsPolyMap g ∧ Function.LeftInverse g f ∧ Function.RightInverse g f := by
      -- Let p be the polynomials defining f. Since f is injective, the map associated to p is injective.
      obtain ⟨p, hp⟩ := hf
      have h_inj : Function.Injective (fun v i => MvPolynomial.eval v (p i)) := by
        exact fun v w h => hinj <| by aesop;
      generalize_proofs at *; (
      -- By `pullback_surjective_of_injective'`, the pullback map `pullback p` is surjective.
      have h_pullback_surjective : Function.Surjective (pullback p) := by
        exact?
      generalize_proofs at *; (
      -- By `poly_inverse_of_pullback_surjective`, there exists a polynomial map g which is the inverse of f.
      obtain ⟨g, hg⟩ := poly_inverse_of_pullback_surjective p h_pullback_surjective
      generalize_proofs at *; (
      use fun v => fun i => MvPolynomial.eval v (g i);
      refine' ⟨ ⟨ g, _ ⟩, _, _ ⟩ <;> simp_all +decide [ Function.LeftInverse, Function.RightInverse ];
      · exact fun v => Function.leftInverse_invFun h_inj v;
      · exact fun v => Function.invFun_eq ( show ∃ w, ( fun v i => ( MvPolynomial.eval v ) ( p i ) ) w = v from by
                                              have := injective_poly_map_surjective _ ( isPolyMap_eval p ) h_inj; aesop; ))))
