/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 6c162bf5-bf91-4890-a1bc-e7a531bc56e9

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We prove Zolotarev's Lemma, which states that for a finite field $F$ and a non-zero element $a \in F$, the permutation of $F$ given by multiplication by $a$ is even if and only if $a$ is a square in $F$.

The proof proceeds in several steps:
1.  We analyze the cycle type of the permutation given by left multiplication by an element $a$ in a finite group $G$. We show that if $a \ne 1$, the cycle type consists of $|G| / \text{order}(a)$ cycles of length $\text{order}(a)$ (`cycleType_mulLeft`).
2.  We derive a formula for the sign of this permutation in a group: $\text{sign}(a) = (-1)^{|G| - |G|/\text{order}(a)}$ (`sign_mulLeft_eq_of_group`).
3.  We relate the sign of the multiplication permutation on the field $F$ (acting on all elements including 0) to the sign of the multiplication permutation on the multiplicative group $F^\times$. Since 0 is fixed, these signs are equal (`sign_AddAut_mulLeft_eq_sign_units_mulLeft`).
4.  Finally, we combine these results to prove Zolotarev's Lemma (`zolotarev_lemma`). We use the fact that in a finite field of odd characteristic, $a$ is a square iff $a^{(|F|-1)/2} = 1$, and analyze the parity of the exponent in the sign formula. In characteristic 2, every element is a square and the sign is always 1, so the theorem holds trivially.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#check AddAut.mulLeft
#check IsSquare

/-
The cycle type of the permutation given by left multiplication by `a` (where `a \ne 1`) consists of `|G| / orderOf a` copies of `orderOf a`.
-/
theorem cycleType_mulLeft {G : Type*} [Group G] [Fintype G] [DecidableEq G] (a : G) (h : a ≠ 1) :
  Equiv.Perm.cycleType (Equiv.mulLeft a) = Multiset.replicate (Fintype.card G / orderOf a) (orderOf a) := by
    -- The permutation is `Equiv.mulLeft a`. Its cycles correspond to the right cosets of the subgroup generated by `a`.
    have h_cosets : (Equiv.mulLeft a).cycleType = (Finset.card (Finset.univ : Finset (G ⧸ Subgroup.zpowers a))) • {orderOf a} := by
      -- The permutation is `Equiv.mulLeft a`. Its cycles correspond to the right cosets of the subgroup generated by `a`. The size of each cycle is `orderOf a`.
      have h_cycle_type : ∀ g : G, (Equiv.Perm.cycleOf (Equiv.mulLeft a) g).support.card = orderOf a := by
        intro g
        have h_cycle_length : (Equiv.Perm.cycleOf (Equiv.mulLeft a) g).support = Finset.image (fun k => a^k * g) (Finset.range (orderOf a)) := by
          ext x
          simp [Equiv.Perm.cycleOf_apply];
          constructor <;> intro h;
          · obtain ⟨ k, hk ⟩ := h.1;
            refine' ⟨ Int.toNat ( k % orderOf a ), _, _ ⟩;
            · linarith [ Int.emod_nonneg k ( Int.natCast_ne_zero.mpr ( ne_of_gt ( orderOf_pos a ) ) ), Int.emod_lt_of_pos k ( Int.natCast_pos.mpr ( orderOf_pos a ) ), Int.toNat_of_nonneg ( Int.emod_nonneg k ( Int.natCast_ne_zero.mpr ( ne_of_gt ( orderOf_pos a ) ) ) ) ];
            · rw [ ← hk, ← zpow_natCast, Int.toNat_of_nonneg ( Int.emod_nonneg _ ( Int.natCast_ne_zero.mpr ( ne_of_gt ( orderOf_pos a ) ) ) ) ];
              rw [ ← Int.emod_add_mul_ediv k ( orderOf a : ℤ ), zpow_add, zpow_mul ] ; simp +decide [ pow_orderOf_eq_one ];
          · obtain ⟨ k, hk, rfl ⟩ := h; exact ⟨ ⟨ k, by simp +decide [ pow_succ', mul_assoc ] ⟩, by assumption ⟩ ;
        rw [ h_cycle_length, Finset.card_image_of_injOn, Finset.card_range ];
        intro k hk l hl hkl; simp_all +decide [ pow_eq_pow_iff_modEq ] ;
        exact Nat.mod_eq_of_lt hk ▸ Nat.mod_eq_of_lt hl ▸ hkl;
      -- Since the cycles are disjoint and their lengths are all equal to `orderOf a`, the cycle type is `Multiset.replicate (Finset.card (Finset.univ : Finset (G ⧸ Subgroup.zpowers a))) (orderOf a)`.
      have h_cycle_type_eq : ∀ c ∈ Equiv.Perm.cycleType (Equiv.mulLeft a), c = orderOf a := by
        intro c hc
        obtain ⟨g, hg⟩ : ∃ g : G, c = (Equiv.Perm.cycleOf (Equiv.mulLeft a) g).support.card := by
          rw [ Equiv.Perm.mem_cycleType_iff ] at hc;
          obtain ⟨ c, τ, h₁, h₂, h₃, rfl ⟩ := hc;
          obtain ⟨ g, hg ⟩ := h₃;
          use g;
          rw [ h₁, Equiv.Perm.cycleOf_mul_of_apply_right_eq_self ];
          · have h_support_eq : c.support = (c.cycleOf g).support := by
              ext y; simp [hg];
              by_cases hy : c y = y <;> simp_all +decide [ Equiv.Perm.cycleOf_apply ];
            rw [h_support_eq];
          · exact?;
          · exact h₂ _ |>.resolve_left hg.1;
        rw [ hg, h_cycle_type ];
      have h_cycle_type_card : (Equiv.Perm.cycleType (Equiv.mulLeft a)).sum = Fintype.card G := by
        rw [ Equiv.Perm.sum_cycleType ];
        simp +decide [ Equiv.Perm.support ];
        aesop;
      have h_cycle_type_card_eq : (Equiv.Perm.cycleType (Equiv.mulLeft a)).card = Fintype.card (G ⧸ Subgroup.zpowers a) := by
        have := Subgroup.card_eq_card_quotient_mul_card_subgroup ( Subgroup.zpowers a ) ; simp_all +decide [ Fintype.card_subtype ] ;
        have h_card_subgroup : Finset.card (Finset.filter (fun x => x ∈ Subgroup.zpowers a) Finset.univ) = orderOf a := by
          rw [ show ( Finset.filter ( fun x => x ∈ Subgroup.zpowers a ) Finset.univ : Finset G ) = Finset.image ( fun x : ℤ => a ^ x ) ( Finset.Ico 0 ( orderOf a ) ) from ?_, Finset.card_image_of_injOn ];
          · simp +decide [ Int.card_Ico ];
          · intros x hx y hy hxy; simp_all +decide [ zpow_eq_zpow_iff_modEq ] ;
            rw [ Int.ModEq ] at hxy; rw [ Int.emod_eq_of_lt, Int.emod_eq_of_lt ] at hxy <;> linarith;
          · ext x; simp [Subgroup.mem_zpowers_iff];
            constructor <;> rintro ⟨ k, hk ⟩;
            · refine' ⟨ k % orderOf a, ⟨ Int.emod_nonneg _ ( Nat.cast_ne_zero.mpr ( ne_of_gt ( orderOf_pos a ) ) ), Int.emod_lt_of_pos _ ( Nat.cast_pos.mpr ( orderOf_pos a ) ) ⟩, _ ⟩;
              rw [ ← hk, ← Int.emod_add_mul_ediv k ( orderOf a ), zpow_add, zpow_mul ] ; simp +decide [ pow_orderOf_eq_one ];
            · grind;
        have h_card_cycle_type : (Equiv.Perm.cycleType (Equiv.mulLeft a)).sum = (Equiv.Perm.cycleType (Equiv.mulLeft a)).card * orderOf a := by
          rw [ Multiset.eq_replicate_of_mem fun x hx => h_cycle_type_eq x hx ] ; simp +decide [ h_card_subgroup ] ;
        nlinarith [ show 0 < orderOf a from orderOf_pos a ];
      have h_cycle_type_eq : ∀ {m : Multiset ℕ}, (∀ c ∈ m, c = orderOf a) → m = Multiset.replicate (Multiset.card m) (orderOf a) := by
        exact fun { m } hm => Multiset.eq_replicate.mpr ⟨ by simp, hm ⟩;
      convert h_cycle_type_eq ‹_› using 1;
      simp +decide [ h_cycle_type_card_eq ];
      exact?;
    have := Subgroup.card_eq_card_quotient_mul_card_subgroup ( Subgroup.zpowers a ) ; simp_all +decide [ Fintype.card_zpowers ] ;
    rw [ Nat.mul_div_cancel _ ( orderOf_pos a ), Multiset.nsmul_singleton ]

/-
The sign of the permutation given by left multiplication by `a` in a finite group `G` is `(-1)^{|G| - |G|/orderOf a}`.
-/
theorem sign_mulLeft_eq_of_group {G : Type*} [Group G] [Fintype G] [DecidableEq G] (a : G) :
  Equiv.Perm.sign (Equiv.mulLeft a) = (-1) ^ (Fintype.card G - Fintype.card G / orderOf a) := by
    by_cases ha : a = 1;
    · aesop;
    · -- By definition of cycle type, we know that the sign of a permutation is determined by the number of cycles of even length.
      have h_sign : Equiv.Perm.sign (Equiv.mulLeft a) = (-1) ^ (Multiset.sum (Equiv.Perm.cycleType (Equiv.mulLeft a)) + Multiset.card (Equiv.Perm.cycleType (Equiv.mulLeft a))) := by
        rw [ Equiv.Perm.sign_of_cycleType ];
      -- By definition of cycle type, we know that the sum of the lengths of the cycles is equal to the cardinality of the group.
      have h_sum : Multiset.sum (Equiv.Perm.cycleType (Equiv.mulLeft a)) = Fintype.card G := by
        rw [ Equiv.Perm.sum_cycleType ];
        simp +decide [ Equiv.Perm.support ];
        aesop;
      -- By definition of cycle type, we know that the number of cycles is equal to the cardinality of the group divided by the order of $a$.
      have h_card : Multiset.card (Equiv.Perm.cycleType (Equiv.mulLeft a)) = Fintype.card G / orderOf a := by
        have := cycleType_mulLeft a ha;
        rw [ this, Multiset.card_replicate ];
      cases Nat.even_or_odd ( Fintype.card G - Fintype.card G / orderOf a ) <;> simp_all +decide [ Nat.even_sub ];
      · cases le_total ( Fintype.card G ) ( Fintype.card G / orderOf a ) <;> simp_all +decide [ parity_simps ];
        exact absurd ‹_› ( not_le_of_gt ( Nat.div_lt_self ( Fintype.card_pos ) ( lt_of_le_of_ne ( Nat.succ_le_of_lt ( orderOf_pos a ) ) ( Ne.symm ( by aesop ) ) ) ) );
      · cases le_total ( Fintype.card G ) ( Fintype.card G / orderOf a ) <;> simp_all +decide [ parity_simps ]

/-
The sign of multiplication by `a` on the field `F` is equal to the sign of multiplication by `a` on the units `Fˣ`.
-/
theorem sign_AddAut_mulLeft_eq_sign_units_mulLeft {F : Type*} [Field F] [Fintype F] [DecidableEq F] (a : Fˣ) :
  Equiv.Perm.sign (AddAut.mulLeft a : Equiv.Perm F) = Equiv.Perm.sign (Equiv.mulLeft a) := by
    have h_sign_mulLeft : ∀ (G : Type) [Group G] [Fintype G] [DecidableEq G] (a : G), (Equiv.Perm.sign (Equiv.mulLeft a)) = (-1) ^ (Fintype.card G - Fintype.card G / orderOf a) := by
      exact?;
    contrapose! h_sign_mulLeft;
    refine' ⟨ Multiplicative ( ULift ( Fin 8 ) ), _, _, _, _, _ ⟩;
    all_goals try infer_instance;
    exact Multiplicative.ofAdd 1;
    rw [ show orderOf ( Multiplicative.ofAdd 1 : Multiplicative ( ULift ( Fin 8 ) ) ) = 8 by rw [ orderOf_eq_iff ] <;> simp +decide ] ; simp +decide;
    convert h_sign_mulLeft using 1;
    rw [ show ( AddAut.mulLeft a : F ≃ F ) = Equiv.ofBijective ( fun x => a.val * x ) ⟨ fun x y hxy => by simpa using hxy, fun x => ⟨ a⁻¹.val * x, by simp +decide ⟩ ⟩ from ?_ ];
    · convert Equiv.Perm.sign_eq_sign_of_equiv _ _ _;
      rotate_left;
      exact Fˣ ⊕ Unit;
      exact?;
      exact F;
      exact?;
      exact?;
      exact?;
      exact Equiv.sumCongr ( Equiv.mulLeft a ) ( Equiv.refl Unit );
      exact Equiv.ofBijective ( fun x => a.val * x ) ⟨ fun x y hxy => by simpa using hxy, fun x => ⟨ a⁻¹.val * x, by simp +decide ⟩ ⟩;
      refine' Equiv.ofBijective ( fun x => x.elim ( fun x => x.val ) fun _ => 0 ) ⟨ _, _ ⟩;
      all_goals simp +decide [ Function.Injective, Function.Surjective ];
      · exact ⟨ fun x y h => Units.ext h, fun x => Ne.symm x.ne_zero ⟩;
      · exact fun b => if hb : b = 0 then Or.inr hb.symm else Or.inl ⟨ Units.mk0 b hb, rfl ⟩;
      · rw [ eq_comm ];
    · exact?

/-
Zolotarev's Lemma: Over a finite field, multiplication by a non-zero element is an even permutation if and only if the element is a square.
-/
theorem zolotarev_lemma {F : Type*} [Field F] [Fintype F] [DecidableEq F] (a : Fˣ) :
  Equiv.Perm.sign (AddAut.mulLeft a : Equiv.Perm F) = 1 ↔ IsSquare (a : F) := by
    -- By `sign_AddAut_mulLeft_eq_sign_units_mulLeft`, this sign is $(-1)^{|F^\times| - |F^\times|/\text{orderOf}(a)}$.
    have h_sign_add : (Equiv.Perm.sign : Equiv.Perm F → ℤˣ) (AddAut.mulLeft a : Equiv.Perm F) = (-1) ^ (Fintype.card Fˣ - Fintype.card Fˣ / orderOf a) := by
      convert sign_mulLeft_eq_of_group ( a : Fˣ ) using 1;
      convert sign_AddAut_mulLeft_eq_sign_units_mulLeft a using 1;
    -- By `IsSquare_iff_orderOf`, $a$ is a square if and only if $k \mid m/2$.
    have h_order : IsSquare (a : F) ↔ orderOf a ∣ Fintype.card Fˣ / 2 ∨ Fintype.card Fˣ % 2 = 1 := by
      constructor <;> intro h;
      · -- If $a$ is a square, then there exists some $b \in F^\times$ such that $a = b^2$.
        obtain ⟨b, hb⟩ : ∃ b : Fˣ, a = b^2 := by
          obtain ⟨ b, hb ⟩ := h;
          exact ⟨ Units.mk0 b ( by aesop ), by simpa [ sq ] using Units.ext hb ⟩;
        by_cases h₂ : Fintype.card Fˣ % 2 = 1 <;> simp_all +decide [ orderOf_dvd_iff_pow_eq_one ];
        rw [ ← pow_mul, Nat.mul_div_cancel' ( Nat.dvd_of_mod_eq_zero h₂ ), pow_card_eq_one ];
      · have h_order : IsSquare (a : Fˣ) ↔ orderOf a ∣ Fintype.card Fˣ / 2 ∨ Fintype.card Fˣ % 2 = 1 := by
          have h_cyclic : IsCyclic Fˣ := by
            infer_instance
          obtain ⟨ g, hg ⟩ := h_cyclic.exists_generator;
          -- Since $g$ is a generator of the cyclic group $F^\times$, we can write $a = g^k$ for some integer $k$.
          obtain ⟨k, hk⟩ : ∃ k : ℕ, a = g^k := by
            obtain ⟨ k, rfl ⟩ := hg a;
            use Int.toNat ( k % orderOf g );
            simp +decide [ ← zpow_natCast, ← zpow_ofNat, Int.emod_nonneg _ ( Int.natCast_ne_zero.mpr ( ne_of_gt ( orderOf_pos g ) ) ), Int.emod_lt_of_pos _ ( Int.natCast_pos.mpr ( orderOf_pos g ) ), zpow_mod_orderOf ];
          by_cases h : Fintype.card Fˣ % 2 = 1 <;> simp_all +decide [ orderOf_dvd_iff_pow_eq_one ];
          · -- Since $g$ is a generator of the cyclic group $F^\times$, we can write $g^k$ as $(g^{k/2})^2$ if $k$ is even, or $(g^{(k+1)/2})^2$ if $k$ is odd.
            obtain ⟨m, hm⟩ : ∃ m : ℕ, k = 2 * m ∨ k = 2 * m + 1 := by
              exact Nat.even_or_odd' k;
            rcases hm with ( rfl | rfl ) <;> simp_all +decide [ pow_add, pow_mul ];
            · exact ⟨ g ^ m, by group ⟩;
            · -- Since $g$ is a generator of the cyclic group $F^\times$, we can write $g$ as $(g^{(Fintype.card Fˣ + 1)/2})^2$.
              have h_gen_sq : g = (g ^ ((Fintype.card Fˣ + 1) / 2)) ^ 2 := by
                rw [ ← pow_mul, Nat.div_mul_cancel ( Nat.dvd_of_mod_eq_zero ( by omega ) ) ];
                rw [ pow_succ', pow_card_eq_one ] ; aesop;
              rw [ h_gen_sq ];
              exact ⟨ ( g ^ ( ( Fintype.card Fˣ + 1 ) / 2 ) ) ^ ( 2 * m + 1 ), by group ⟩;
          · -- Since $g$ is a generator of the cyclic group $F^\times$, we know that $g^{Fintype.card Fˣ / 2} = -1$.
            have h_gen_half : g ^ (Fintype.card Fˣ / 2) = -1 := by
              have h_gen_half : (g ^ (Fintype.card Fˣ / 2)) ^ 2 = 1 := by
                rw [ ← pow_mul, Nat.div_mul_cancel ( Nat.dvd_of_mod_eq_zero h ), pow_card_eq_one ];
              have h_gen_half : g ^ (Fintype.card Fˣ / 2) ≠ 1 := by
                intro H; have := orderOf_dvd_iff_pow_eq_one.mpr H; simp_all +decide [ Nat.dvd_div_iff_mul_dvd ] ;
                have := orderOf_eq_card_of_forall_mem_zpowers hg; simp_all +decide [ Nat.dvd_div_iff_mul_dvd ] ;
                exact Nat.not_dvd_of_pos_of_lt ( Nat.div_pos ( Nat.le_of_dvd ( Fintype.card_pos ) ( Nat.dvd_of_mod_eq_zero h ) ) zero_lt_two ) ( Nat.div_lt_self ( Fintype.card_pos ) ( by decide ) ) ‹Fintype.card Fˣ ∣ Fintype.card Fˣ / 2›;
              simp_all +decide [ Units.ext_iff ];
            -- Since $g^{Fintype.card Fˣ / 2} = -1$, we have $(-1)^k = 1$, which implies that $k$ is even.
            have h_k_even : Even k := by
              simp_all +decide [ ← pow_mul, Nat.even_iff ];
              have h_k_even : g ^ (k * (Fintype.card Fˣ / 2)) = (g ^ (Fintype.card Fˣ / 2)) ^ k := by
                rw [ pow_mul' ];
              rcases Nat.even_or_odd' k with ⟨ k, rfl | rfl ⟩ <;> simp_all +decide [ pow_add, pow_mul ];
              simp_all +decide [ Units.ext_iff ];
              rw [ neg_eq_iff_add_eq_zero ] at h;
              norm_num at h;
              have := CharP.cast_eq_zero_iff F ( ringChar F ) 2; simp_all +decide ;
              have := Nat.le_of_dvd ( by decide ) this; interval_cases _ : ringChar F <;> simp_all +decide ;
              · exact absurd ( Fintype.card_le_one_iff_subsingleton.mpr ‹_› ) ( by exact Nat.not_le_of_gt ( Fintype.one_lt_card ) );
              · have := FiniteField.card F ( ringChar F ) ; simp_all +decide ;
                obtain ⟨ n, hn ⟩ := this; simp_all +decide [ Fintype.card_units ] ;
            exact ⟨ g ^ ( k / 2 ), by rw [ ← pow_two, ← pow_mul, Nat.div_mul_cancel ( even_iff_two_dvd.mp h_k_even ) ] ⟩;
        obtain ⟨ b, hb ⟩ := h_order.mpr h;
        exact ⟨ b, by simp [ hb ] ⟩;
    by_cases h : Fintype.card Fˣ % 2 = 1 <;> simp_all +decide [ ← even_iff_two_dvd, parity_simps ];
    · by_cases h : Even ( Fintype.card Fˣ - Fintype.card Fˣ / orderOf a ) <;> simp_all +decide [ Nat.even_sub ( show Fintype.card Fˣ / orderOf a ≤ Fintype.card Fˣ from Nat.div_le_self _ _ ) ];
      simp_all +decide [ Nat.even_iff, Nat.odd_iff ];
      have := Nat.div_mul_cancel ( orderOf_dvd_iff_pow_eq_one.mpr ( show a ^ ( Fintype.card ( Units F ) ) = 1 from by rw [ ← orderOf_dvd_iff_pow_eq_one ] ; exact orderOf_dvd_card ) ) ; replace this := congr_arg ( · % 2 ) this ; simp_all +decide [ Nat.mul_mod, Nat.pow_mod ];
    · by_cases h' : Even ( Fintype.card Fˣ - Fintype.card Fˣ / orderOf a ) <;> simp_all +decide [ Nat.even_iff ];
      · rw [ ← Nat.dvd_iff_mod_eq_zero ] at *;
        obtain ⟨ k, hk ⟩ := h';
        rw [ tsub_eq_iff_eq_add_of_le ] at hk;
        · -- Since $orderOf a \mid Fintype.card Fˣ$, we have $Fintype.card Fˣ = orderOf a * m$ for some integer $m$.
          obtain ⟨ m, hm ⟩ : ∃ m, Fintype.card Fˣ = orderOf a * m := by
            exact orderOf_dvd_card;
          rcases Nat.even_or_odd' m with ⟨ c, rfl | rfl ⟩ <;> simp +decide [ hm ] at hk ⊢;
          · exact ⟨ c, Nat.div_eq_of_eq_mul_left zero_lt_two ( by ring ) ⟩;
          · rw [ Nat.mul_div_cancel_left _ ( Nat.pos_of_ne_zero ( by aesop_cat ) ) ] at hk ; replace hk := congr_arg Even hk ; simp_all +decide [ parity_simps ];
            exact absurd h ( by rw [ Nat.dvd_iff_mod_eq_zero ] ; obtain ⟨ m, hm ⟩ := hk; simp +decide [ hm, Nat.add_mod, Nat.mul_mod ] );
        · exact Nat.div_le_self _ _;
      · rw [ ← Nat.mod_add_div ( Fintype.card Fˣ - Fintype.card Fˣ / orderOf a ) 2, h' ] ; norm_num [ pow_add, pow_mul ];
        intro h''; obtain ⟨ k, hk ⟩ := h''; simp_all +decide [ Nat.mul_mod, Nat.mod_eq_of_lt ] ;
        rw [ Nat.div_eq_iff_eq_mul_left zero_lt_two ] at hk;
        · simp_all +decide [ Nat.mul_assoc, Nat.mul_mod ];
          rw [ Nat.mul_div_cancel_left _ ( Nat.pos_of_ne_zero ( by aesop_cat ) ) ] at h';
          grind;
        · exact Nat.dvd_of_mod_eq_zero h
