/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: e787182a-6ba4-45b2-beda-77cf7a59f8db

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We have proved two additional formulas for the volume of an n-dimensional simplex:
1. The Cayley-Menger formula: The square of the volume is related to the determinant of the Cayley-Menger matrix (constructed from squared distances between vertices) by the factor `(-1)^(n+1) / (2^n * (n!)^2)`.
2. The Extended Matrix formula: The volume is the absolute value of the determinant of the extended matrix (vertices as columns, plus a row of 1s) divided by `n!`.

These complement the formulas already provided in the context (Side Matrix and Gram Matrix formulas).
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: ce87d18a-c59d-4e06-a3e6-211b4c02f0f8

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 6b30d2a3-c93d-4417-acb6-8ea12b6037dd

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: ac41a389-b466-4cbd-8016-e7e20aef603f

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 7db8927a-b690-48cb-974e-e353ca24d619

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: aececa7b-219d-4445-9937-854c776e1318

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 8f711401-bbde-4183-9fe2-3512bbfa01fa

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: eba919aa-005d-4dcd-99c2-b13d100d1f65

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 036a3181-ee4b-428e-80a3-a8a906fdad92

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: a60ac108-59e8-4084-8600-bdc808be295f

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 117b4829-74db-4237-9bdb-4fcd54a3e82b

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
The volume of a simplex is the volume of the convex hull of its vertices.
-/
noncomputable def simplexVolume {n : ℕ} (s : Affine.Simplex ℝ (EuclideanSpace ℝ (Fin n)) n) : ℝ :=
  (MeasureTheory.volume (convexHull ℝ (Set.range s.points))).toReal

/-
The Cayley-Menger matrix of a simplex is a matrix constructed from the squared distances between its vertices. The top-left entry is 0, the first row and column (excluding the top-left) are 1s, and the rest are squared distances.
-/
noncomputable def cayleyMengerMatrix {n : ℕ} (s : Affine.Simplex ℝ (EuclideanSpace ℝ (Fin n)) n) : Matrix (Fin (n + 2)) (Fin (n + 2)) ℝ :=
  Matrix.of fun i j =>
    Fin.cases
      (Fin.cases 0 (fun _ => 1) j)
      (fun x => Fin.cases 1 (fun y => dist (s.points x) (s.points y) ^ 2) j)
      i

/-
The simplex side matrix is the matrix whose columns are the vectors from the first vertex to the other vertices of the simplex.
-/
noncomputable def simplexSideMatrix {n : ℕ} (s : Affine.Simplex ℝ (EuclideanSpace ℝ (Fin n)) n) : Matrix (Fin n) (Fin n) ℝ :=
  Matrix.of fun i j => (s.points j.succ - s.points 0) i

/-
The volume of the standard simplex scaled by r is r^n times the volume of the standard simplex.
-/
def stdSimplexInRn_scaled (n : ℕ) (r : ℝ) : Set (EuclideanSpace ℝ (Fin n)) :=
  {x | (∀ i, 0 ≤ x i) ∧ ∑ i, x i ≤ r}

theorem volume_stdSimplexInRn_scaled_eq_pow_mul_volume (n : ℕ) (r : ℝ) (hr : 0 ≤ r) :
  MeasureTheory.volume (stdSimplexInRn_scaled n r) = ENNReal.ofReal (r ^ n) * MeasureTheory.volume (stdSimplexInRn_scaled n 1) := by
    rw [ show stdSimplexInRn_scaled n r = ( fun x => r • x ) '' stdSimplexInRn_scaled n 1 from ?_ ];
    · norm_num [ abs_of_nonneg hr ];
    · ext x
      simp [stdSimplexInRn_scaled];
      by_cases hr' : r = 0 <;> simp_all +decide [ Set.mem_smul_set, Finset.mul_sum _ _ _ ];
      · constructor <;> intro h;
        · exact ⟨ ⟨ 0, fun _ => by norm_num, by norm_num ⟩, Eq.symm <| by ext i; exact le_antisymm ( le_trans ( Finset.single_le_sum ( fun a _ => h.1 a ) ( Finset.mem_univ i ) ) h.2 ) ( h.1 i ) ⟩;
        · aesop;
      · constructor <;> intro h;
        · exact ⟨ fun i => x i / r, ⟨ fun i => div_nonneg ( h.1 i ) hr, by simpa [ Finset.sum_div _ _ _, hr' ] using div_le_one_of_le₀ h.2 hr ⟩, by ext i; simp +decide [ hr', mul_div_cancel₀ _ hr' ] ⟩;
        · rcases h with ⟨ y, ⟨ hy₁, hy₂ ⟩, rfl ⟩ ; exact ⟨ fun i => mul_nonneg hr ( hy₁ i ), by simpa [ Finset.mul_sum _ _ _ ] using mul_le_mul_of_nonneg_left hy₂ hr ⟩ ;

/-
The standard simplex in R^n is the set of points with non-negative coordinates summing to at most 1.
-/
def stdSimplexInRn (n : ℕ) : Set (EuclideanSpace ℝ (Fin n)) :=
  {x | (∀ i, 0 ≤ x i) ∧ ∑ i, x i ≤ 1}

/-
The volume of the standard simplex in 1 dimension is 1.
-/
theorem volume_stdSimplexInRn_one :
  MeasureTheory.volume (stdSimplexInRn 1) = ENNReal.ofReal 1 := by
    -- The standard simplex in 1 dimension is just the interval [0,1], so its volume is 1.
    simp [stdSimplexInRn];
    erw [ show { x : EuclideanSpace ℝ ( Fin 1 ) | 0 ≤ x 0 ∧ x 0 ≤ 1 } = ( Metric.closedBall ( EuclideanSpace.single 0 ( 1 / 2 ) ) ( 1 / 2 ) ) from ?_, MeasureTheory.Measure.addHaar_closedBall ] <;> norm_num;
    · erw [ EuclideanSpace.volume_ball ] ; norm_num;
      rw [ show ( 3 / 2 : ℝ ) = 1 / 2 + 1 by norm_num, Real.Gamma_add_one ( by norm_num ), Real.Gamma_one_half_eq ] ; ring_nf ; norm_num [ Real.pi_pos.le ];
      rw [ ← ENNReal.toReal_eq_one_iff ] ; norm_num [ ENNReal.toReal_mul ];
    · norm_num [ Set.ext_iff, Metric.mem_closedBall, EuclideanSpace.dist_eq ];
      exact fun x => ⟨ fun hx => abs_le.mpr ⟨ by linarith, by linarith ⟩, fun hx => ⟨ by linarith [ abs_le.mp hx ], by linarith [ abs_le.mp hx ] ⟩ ⟩

/-
The integral of (1-t)^n from 0 to 1 is 1/(n+1).
-/
theorem integral_one_sub_pow (n : ℕ) :
  ∫ t in Set.Icc (0 : ℝ) 1, (1 - t) ^ n = 1 / (n + 1 : ℝ) := by
    rw [ MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le zero_le_one, intervalIntegral.integral_comp_sub_left fun x => x ^ n ] ; norm_num

/-
The standard simplex in n+1 dimensions is the union of slices, where each slice at height t corresponds to the standard simplex in n dimensions scaled by 1-t.
-/
theorem stdSimplexInRn_succ_eq_union (n : ℕ) :
  stdSimplexInRn (n + 1) = ⋃ (t : Set.Icc (0 : ℝ) 1), {x : EuclideanSpace ℝ (Fin (n + 1)) | x (Fin.last n) = t ∧ (Fin.init x) ∈ stdSimplexInRn_scaled n (1 - t)} := by
    ext xop;
    simp +zetaDelta at *;
    constructor;
    · rintro ⟨ hx₁, hx₂ ⟩;
      refine' ⟨ ⟨ hx₁ _, _ ⟩, _, _ ⟩;
      · exact le_trans ( Finset.single_le_sum ( fun i _ => hx₁ i ) ( Finset.mem_univ _ ) ) hx₂;
      · exact fun i => hx₁ _;
      · simp_all +decide [ Fin.sum_univ_castSucc ];
        exact le_tsub_of_add_le_right hx₂;
    · intro hxop
      simp [stdSimplexInRn, stdSimplexInRn_scaled] at hxop ⊢;
      exact ⟨ fun i => if hi : i.val < n then hxop.2.1 ⟨ i.val, hi ⟩ else by rw [ Fin.eq_last_of_not_lt hi ] ; exact hxop.1.1, by rw [ Fin.sum_univ_castSucc ] ; exact by linarith! [ hxop.2.2 ] ⟩

/-
The slice of the standard simplex in n+1 dimensions at height t (where 0 <= t <= 1) is the standard simplex in n dimensions scaled by 1-t.
-/
theorem slice_stdSimplexInRn_succ (n : ℕ) (t : ℝ) (ht : 0 ≤ t) (ht' : t ≤ 1) :
  {y : EuclideanSpace ℝ (Fin n) | (Fin.snoc y t) ∈ stdSimplexInRn (n + 1)} = stdSimplexInRn_scaled n (1 - t) := by
    -- Let's simplify the goal using the definition of `stdSimplexInRn`.
    ext y
    simp [stdSimplexInRn];
    constructor <;> rintro ⟨ h1, h2 ⟩ <;> refine' ⟨ _, _ ⟩ <;> simp_all +decide [ Fin.sum_univ_castSucc, Fin.snoc ];
    · exact fun i => by simpa using h1 ( Fin.castSucc i ) ;
    · linarith;
    · exact fun i => by split_ifs <;> simp +decide [ * ] ;
    · linarith

#check @MeasurableEquiv.piFinSuccAbove

/-
The volume measure on (n+1)-dimensional Euclidean space, mapped by the equivalence separating the last coordinate, is the product of the volume on the real line (for the last coordinate) and the volume on n-dimensional Euclidean space.
-/
theorem volume_piFinSuccAbove_eq_prod (n : ℕ) :
  MeasureTheory.Measure.map (MeasurableEquiv.piFinSuccAbove (fun _ : Fin (n + 1) => ℝ) (Fin.last n)) MeasureTheory.volume = MeasureTheory.Measure.prod MeasureTheory.volume MeasureTheory.volume := by
    simp +decide [ MeasureTheory.MeasureSpace.volume ];
    rw [ MeasureTheory.Measure.pi_eq ];
    rotate_right;
    exact MeasureTheory.Measure.map ( fun x : ℝ × ( Fin n → ℝ ) => Fin.snoc x.2 x.1 ) ( MeasureTheory.Measure.prod ( MeasureTheory.MeasureSpace.volume ) ( MeasureTheory.Measure.pi fun _ => MeasureTheory.MeasureSpace.volume ) );
    · rw [ MeasureTheory.Measure.map_map ];
      · convert MeasureTheory.Measure.map_id;
        exact funext fun x => by ext <;> simp +decide [ Fin.snoc ] ;
      · refine' Measurable.prodMk _ _;
        · exact measurable_pi_apply _;
        · exact measurable_pi_lambda _ fun _ => measurable_pi_apply _;
      · refine' measurable_pi_iff.mpr _;
        intro a; induction a using Fin.lastCases <;> simp +decide [ *, Fin.snoc ] ;
        · exact measurable_fst;
        · exact measurable_pi_apply _ |> Measurable.comp <| measurable_snd;
    · intro s hs;
      rw [ MeasureTheory.Measure.map_apply ];
      · simp +decide [ Set.preimage, Fin.snoc ];
        rw [ show { x : ℝ × ( Fin n → ℝ ) | ∀ i : Fin ( n + 1 ), ( if h : ( i : ℕ ) < n then x.2 ( i.castLT h ) else x.1 ) ∈ s i } = ( s ( Fin.last n ) ) ×ˢ ( Set.pi Set.univ fun i : Fin n => s ( Fin.castSucc i ) ) from ?_ ];
        · simp +decide [ Fin.prod_univ_castSucc, MeasureTheory.MeasureSpace.volume ];
          ring;
        · ext ⟨x, y⟩; simp [Fin.last];
          exact ⟨ fun h => ⟨ by simpa using h ⟨ n, Nat.lt_succ_self _ ⟩, fun i => by simpa using h ⟨ i, Nat.lt_succ_of_lt i.2 ⟩ ⟩, fun h i => by cases i using Fin.lastCases <;> aesop ⟩;
      · refine' measurable_pi_iff.mpr _;
        intro i; induction i using Fin.lastCases <;> simp +decide [ *, Fin.snoc ] ;
        · exact measurable_fst;
        · exact measurable_pi_apply _ |> Measurable.comp <| measurable_snd;
      · exact MeasurableSet.univ_pi hs

/-
The snoc map is a measurable equivalence between the product of n-dimensional Euclidean space and the real line, and (n+1)-dimensional Euclidean space.
-/
def snocMeasurableEquiv (n : ℕ) : (EuclideanSpace ℝ (Fin n) × ℝ) ≃ᵐ EuclideanSpace ℝ (Fin (n + 1)) where
  toEquiv := {
    toFun := fun p => Fin.snoc p.1 p.2
    invFun := fun x => (Fin.init x, x (Fin.last n))
    left_inv := fun p => by simp [Fin.snoc, Fin.init, Fin.last]
    right_inv := fun x => by
      ext i
      by_cases h : i < n
      · simp [Fin.snoc, Fin.init, Fin.last, h]
      · rw [Fin.eq_last_of_not_lt h]
        simp [Fin.snoc]
  }
  measurable_toFun := by
    refine measurable_pi_iff.mpr (fun i => ?_)
    by_cases h : i.val < n
    · simp [Fin.snoc, h]
      exact (measurable_pi_apply (⟨i.val, h⟩ : Fin n)).comp measurable_fst
    · simp [Fin.snoc, h]
      exact measurable_snd
  measurable_invFun := by
    refine Measurable.prodMk ?_ ?_
    · refine measurable_pi_iff.mpr (fun i => ?_)
      simp [Fin.init]
      exact measurable_pi_apply _
    · exact measurable_pi_apply _

#check snocMeasurableEquiv

/-
The standard simplex in n+1 dimensions is the image of a specific set in the product space under the snoc map.
-/
lemma stdSimplexInRn_succ_eq_image_snocMeasurableEquiv (n : ℕ) :
  stdSimplexInRn (n + 1) = (snocMeasurableEquiv n).toEquiv '' {p : EuclideanSpace ℝ (Fin n) × ℝ | 0 ≤ p.2 ∧ p.2 ≤ 1 ∧ p.1 ∈ stdSimplexInRn_scaled n (1 - p.2)} := by
    ext x; simp [snocMeasurableEquiv];
    constructor <;> intro hx;
    · use Fin.init x, x (Fin.last n);
      refine' ⟨ ⟨ _, _, _ ⟩, _ ⟩;
      · exact hx.1 _;
      · exact le_trans ( Finset.single_le_sum ( fun a _ => hx.1 a ) ( Finset.mem_univ ( Fin.last n ) ) ) hx.2;
      · refine' ⟨ fun i => hx.1 ( Fin.castSucc i ), _ ⟩;
        have := hx.2;
        rw [ Fin.sum_univ_castSucc ] at this ; linarith!;
      · exact Fin.snoc_init_self x;
    · obtain ⟨ a, b, ⟨ hb₀, hb₁, ha ⟩, rfl ⟩ := hx; simp_all +decide [ stdSimplexInRn, stdSimplexInRn_scaled ] ;
      exact ⟨ fun i => by cases i using Fin.lastCases <;> simp +decide [ * ], by linarith ⟩

#check @MeasurableEquiv.piFinSuccAbove

#check @MeasurableEquiv.prodComm

/-
The snoc measurable equivalence is the composition of swapping the product components and the symmetric of the piFinSuccAbove equivalence.
-/
lemma snocMeasurableEquiv_eq_trans_prodComm_symm_piFinSuccAbove (n : ℕ) :
  snocMeasurableEquiv n = MeasurableEquiv.trans MeasurableEquiv.prodComm (MeasurableEquiv.piFinSuccAbove (fun _ : Fin (n + 1) => ℝ) (Fin.last n)).symm := by
    -- By definition of `snocMeasurableEquiv`, we can write it as the composition of `prodComm` and the inverse of `piFinSuccAbove`.
    ext ⟨y, t⟩; simp [snocMeasurableEquiv, MeasurableEquiv.prodComm, MeasurableEquiv.piFinSuccAbove];
    exact?

#check @MeasureTheory.Measure.prod_swap

/-
Mapping the product of volumes by prodComm results in the product of volumes (swapped).
-/
lemma map_prodComm_volume_volume (n : ℕ) :
  MeasureTheory.Measure.map MeasurableEquiv.prodComm (MeasureTheory.Measure.prod (MeasureTheory.volume : MeasureTheory.Measure (EuclideanSpace ℝ (Fin n))) (MeasureTheory.volume : MeasureTheory.Measure ℝ)) = MeasureTheory.Measure.prod (MeasureTheory.volume : MeasureTheory.Measure ℝ) (MeasureTheory.volume : MeasureTheory.Measure (EuclideanSpace ℝ (Fin n))) := by
    convert MeasureTheory.Measure.prod_swap ..;
    · infer_instance;
    · infer_instance

/-
If the image of a measure under a measurable equivalence is another measure, then the image of that other measure under the inverse equivalence is the original measure.
-/
lemma MeasureTheory.Measure.map_symm_eq_self_of_map_eq {α β : Type*} [MeasurableSpace α] [MeasurableSpace β] (e : α ≃ᵐ β) (μ : MeasureTheory.Measure α) (ν : MeasureTheory.Measure β) (h : MeasureTheory.Measure.map e μ = ν) :
  MeasureTheory.Measure.map e.symm ν = μ := by
    aesop

/-
The map of the product measure (volume on R, volume on R^n) under the symmetric product commutator is the product measure (volume on R^n, volume on R).
-/
lemma map_prodComm_symm_prod (n : ℕ) :
  MeasureTheory.Measure.map MeasurableEquiv.prodComm.symm (MeasureTheory.Measure.prod (MeasureTheory.volume : MeasureTheory.Measure ℝ) (MeasureTheory.volume : MeasureTheory.Measure (EuclideanSpace ℝ (Fin n)))) = MeasureTheory.Measure.prod (MeasureTheory.volume : MeasureTheory.Measure (EuclideanSpace ℝ (Fin n))) (MeasureTheory.volume : MeasureTheory.Measure ℝ) := by
    ext s hs;
    rw [ MeasureTheory.Measure.map_apply ];
    · rw [ ← MeasureTheory.Measure.prod_swap ];
      convert MeasureTheory.Measure.map_apply _ _ using 1;
      · exact measurable_swap;
      · exact hs.preimage ( MeasurableEquiv.measurable _ );
    · exact measurable_snd.prodMk measurable_fst;
    · exact hs

/-
The inverse of the snoc equivalence is the composition of the piFinSuccAbove equivalence and the symmetric product commutator.
-/
lemma snocMeasurableEquiv_symm_eq (n : ℕ) : (snocMeasurableEquiv n).symm = (MeasurableEquiv.piFinSuccAbove (fun _ : Fin (n + 1) => ℝ) (Fin.last n)).trans MeasurableEquiv.prodComm.symm := by
  convert congr_arg _ ( snocMeasurableEquiv_eq_trans_prodComm_symm_piFinSuccAbove n ) using 1

/-
The measure map of a composition of measurable equivalences is the composition of the measure maps.
-/
lemma map_measurableEquiv_trans {α β γ : Type*} [MeasurableSpace α] [MeasurableSpace β] [MeasurableSpace γ]
  (e1 : α ≃ᵐ β) (e2 : β ≃ᵐ γ) (μ : MeasureTheory.Measure α) :
  MeasureTheory.Measure.map (e1.trans e2) μ = MeasureTheory.Measure.map e2 (MeasureTheory.Measure.map e1 μ) := by
    rw [ MeasureTheory.Measure.map_map ];
    · rfl;
    · exact e2.measurable;
    · exact e1.measurable

/-
The inverse of the `piFinSuccAbove` equivalence maps the product measure (volume on R^n and R) back to the volume measure on R^(n+1).
-/
open scoped BigOperators Real Nat Classical Pointwise

lemma map_piFinSuccAbove_symm_volume (n : ℕ) :
  MeasureTheory.Measure.map (MeasurableEquiv.piFinSuccAbove (fun _ : Fin (n + 1) => ℝ) (Fin.last n)).symm (MeasureTheory.Measure.prod MeasureTheory.volume MeasureTheory.volume) = MeasureTheory.volume := by
    rw [ ← volume_piFinSuccAbove_eq_prod ];
    convert MeasureTheory.Measure.map_symm_eq_self_of_map_eq _ _ _ _;
    convert rfl

/-
The volume measure on (n+1)-dimensional Euclidean space, mapped by the piFinSuccAbove equivalence, is the product of the volume on the real line and the volume on n-dimensional Euclidean space.
-/
lemma map_piFinSuccAbove_volume (n : ℕ) :
  MeasureTheory.Measure.map (MeasurableEquiv.piFinSuccAbove (fun _ : Fin (n + 1) => ℝ) (Fin.last n)) MeasureTheory.volume = MeasureTheory.Measure.prod MeasureTheory.volume MeasureTheory.volume := by
    convert volume_piFinSuccAbove_eq_prod n using 1

#check simplexVolume

#check @MeasurableEquiv.piFinSuccAbove
#check @MeasureTheory.Measure.prod

#check MeasureTheory.Measure.map_map
#check map_measurableEquiv_trans

/-
The scaled standard simplex is a measurable set.
-/
lemma measurableSet_stdSimplexInRn_scaled (n : ℕ) (r : ℝ) : MeasurableSet (stdSimplexInRn_scaled n r) := by
  refine' MeasurableSet.inter ( _ ) ( _ );
  · exact MeasurableSet.congr ( MeasurableSet.iInter fun i => measurableSet_le measurable_const ( measurable_pi_apply i ) ) ( by aesop );
  · exact measurableSet_le ( Finset.measurable_sum _ fun i _ => measurable_pi_apply i ) measurable_const

#check MeasureTheory.volume_preserving_piFinSuccAbove
#check MeasureTheory.Measure.prod_swap

#check MeasurableEquiv.piFinSuccAbove
#check snocMeasurableEquiv

/-
Fin.snoc is the inverse of piFinSuccAbove (swapped).
-/
lemma snoc_eq_swap_piFinSuccAbove (n : ℕ) (x : Fin n → ℝ) (t : ℝ) :
  Fin.snoc x t = (MeasurableEquiv.piFinSuccAbove (fun _ : Fin (n + 1) => ℝ) (Fin.last n)).symm (t, x) := by
    -- By definition of `MeasurableEquiv.piFinSuccAbove`, we have that applying `(MeasurableEquiv.piFinSuccAbove (fun _ => ℝ) (Fin.last n))` to `x` results in `(t, x)`
    simp [MeasurableEquiv.piFinSuccAbove, Fin.snoc];
    exact?

/-
The volume on Euclidean space is the product measure.
-/
lemma volume_euclideanSpace_eq_pi_volume (n : ℕ) :
  (MeasureTheory.volume : MeasureTheory.Measure (EuclideanSpace ℝ (Fin n))) = MeasureTheory.Measure.pi (fun _ => MeasureTheory.volume) := by
    -- The orthonormal basis `e` is the identity map, so the transformation preserves volume.
    have h_id : (stdOrthonormalBasis ℝ (EuclideanSpace ℝ (Fin n))).toBasis.addHaar = MeasureTheory.Measure.map (WithLp.toLp 2) (MeasureTheory.Measure.pi fun _ : Fin n => (stdOrthonormalBasis ℝ ℝ).toBasis.addHaar) := by
      convert ( PiLp.volume_preserving_toLp _ ) |> MeasureTheory.MeasurePreserving.map_eq;
      any_goals exact Fin n;
      exact?
    generalize_proofs at *; (
    convert h_id using 1
    generalize_proofs at *; (
    refine' MeasureTheory.Measure.pi_eq _;
    intro s hs; erw [ MeasureTheory.Measure.map_apply ] ;
    · convert MeasureTheory.Measure.pi_pi _ _ using 1
      generalize_proofs at *; (
      exact?);
    · exact?;
    · exact MeasurableSet.univ_pi hs))

/-
The snoc map preserves the product volume measure.
-/
lemma measurePreserving_snocMeasurableEquiv (n : ℕ) : MeasureTheory.MeasurePreserving (snocMeasurableEquiv n) (MeasureTheory.Measure.prod MeasureTheory.volume MeasureTheory.volume) MeasureTheory.volume := by
  -- The product of two measure-preserving maps is measure-preserving.
  have h_prod : MeasureTheory.MeasurePreserving (fun p : (Fin n → ℝ) × ℝ => (p.2, p.1)) (MeasureTheory.Measure.prod (MeasureTheory.volume : MeasureTheory.Measure (Fin n → ℝ)) (MeasureTheory.volume : MeasureTheory.Measure ℝ)) (MeasureTheory.Measure.prod (MeasureTheory.volume : MeasureTheory.Measure ℝ) (MeasureTheory.volume : MeasureTheory.Measure (Fin n → ℝ))) := by
    refine' ⟨ _, _ ⟩;
    · exact measurable_snd.prodMk measurable_fst;
    · ext s hs;
      rw [ MeasureTheory.Measure.map_apply ];
      · erw [ MeasureTheory.Measure.prod_apply ];
        · exact?;
        · exact hs.preimage ( measurable_snd.prodMk measurable_fst );
      · exact measurable_snd.prodMk measurable_fst;
      · exact hs;
  have h_comp : MeasureTheory.MeasurePreserving (fun p : ℝ × (Fin n → ℝ) => (MeasurableEquiv.piFinSuccAbove (fun _ : Fin (n + 1) => ℝ) (Fin.last n)).symm p) (MeasureTheory.Measure.prod (MeasureTheory.volume : MeasureTheory.Measure ℝ) (MeasureTheory.volume : MeasureTheory.Measure (Fin n → ℝ))) (MeasureTheory.volume : MeasureTheory.Measure (Fin (n + 1) → ℝ)) := by
    convert MeasureTheory.MeasurePreserving.symm _ _ using 1;
    convert MeasureTheory.volume_preserving_piFinSuccAbove _ _ using 1;
    exact?;
  convert h_comp.comp h_prod using 1;
  · ext ⟨x, t⟩; simp [snocMeasurableEquiv];
  · congr! 1;
    convert volume_euclideanSpace_eq_pi_volume n;
  · convert volume_euclideanSpace_eq_pi_volume ( n + 1 ) using 1

/-
The 0-dimensional standard simplex is the whole space.
-/
lemma stdSimplexInRn_zero_eq_univ : stdSimplexInRn 0 = Set.univ := by
  -- By definition of `stdSimplexInRn`, we know that `stdSimplexInRn 0` is the set of points in `EuclideanSpace ℝ (Fin 0)` that satisfy the given conditions.
  ext x
  simp [stdSimplexInRn]

/-
The volume of the whole 0-dimensional Euclidean space is 1.
-/
lemma volume_euclideanSpace_zero : MeasureTheory.volume (Set.univ : Set (EuclideanSpace ℝ (Fin 0))) = 1 := by
  have h_volume : (MeasureTheory.volume : MeasureTheory.Measure (EuclideanSpace ℝ (Fin 0))) = MeasureTheory.Measure.dirac (0 : EuclideanSpace ℝ (Fin 0)) := by
    exact?;
  exact h_volume.symm ▸ by norm_num;

/-
The volume of the standard simplex in n dimensions is 1/n!.
-/
theorem volume_stdSimplexInRn (n : ℕ) :
  MeasureTheory.volume (stdSimplexInRn n) = ENNReal.ofReal (1 / (Nat.factorial n)) := by
    induction' n with n ih;
    · convert volume_euclideanSpace_zero using 1;
      · exact congr_arg _ ( stdSimplexInRn_zero_eq_univ );
      · norm_num [ Nat.factorial ];
    · -- The volume of the standard simplex in (n+1) dimensions is the integral of the volume of the scaled simplices in n dimensions over the interval [0, 1].
      have h_volume_succ : MeasureTheory.volume (stdSimplexInRn (n + 1)) = ∫⁻ t in Set.Icc (0 : ℝ) 1, MeasureTheory.volume (stdSimplexInRn_scaled n (1 - t)) := by
        -- By Fubini's theorem, we can interchange the order of integration.
        have h_fubini : MeasureTheory.volume (stdSimplexInRn (n + 1)) = ∫⁻ (p : EuclideanSpace ℝ (Fin n) × ℝ), (if 0 ≤ p.2 ∧ p.2 ≤ 1 ∧ p.1 ∈ stdSimplexInRn_scaled n (1 - p.2) then 1 else 0) ∂(MeasureTheory.volume.prod MeasureTheory.volume) := by
          rw [ MeasureTheory.lintegral_congr_ae, MeasureTheory.lintegral_indicator ];
          change MeasureTheory.volume ( stdSimplexInRn ( n + 1 ) ) = ∫⁻ x in { p : EuclideanSpace ℝ ( Fin n ) × ℝ | 0 ≤ p.2 ∧ p.2 ≤ 1 ∧ p.1 ∈ stdSimplexInRn_scaled n ( 1 - p.2 ) }, 1 ∂MeasureTheory.volume.prod MeasureTheory.volume;
          · have h_volume_succ : MeasureTheory.volume (stdSimplexInRn (n + 1)) = MeasureTheory.volume ((snocMeasurableEquiv n).toEquiv '' {p : EuclideanSpace ℝ (Fin n) × ℝ | 0 ≤ p.2 ∧ p.2 ≤ 1 ∧ p.1 ∈ stdSimplexInRn_scaled n (1 - p.2)}) := by
              exact congr_arg _ ( stdSimplexInRn_succ_eq_image_snocMeasurableEquiv n );
            have h_volume_succ : MeasureTheory.volume ((snocMeasurableEquiv n).toEquiv '' {p : EuclideanSpace ℝ (Fin n) × ℝ | 0 ≤ p.2 ∧ p.2 ≤ 1 ∧ p.1 ∈ stdSimplexInRn_scaled n (1 - p.2)}) = MeasureTheory.volume {p : EuclideanSpace ℝ (Fin n) × ℝ | 0 ≤ p.2 ∧ p.2 ≤ 1 ∧ p.1 ∈ stdSimplexInRn_scaled n (1 - p.2)} := by
              have h_volume_succ : MeasureTheory.MeasurePreserving (snocMeasurableEquiv n) (MeasureTheory.Measure.prod MeasureTheory.volume MeasureTheory.volume) MeasureTheory.volume := by
                exact?;
              rw [ ← h_volume_succ.measure_preimage ];
              · simp +decide [ Set.preimage ];
                exact?;
              · refine' MeasurableSet.nullMeasurableSet _;
                rw [ ← stdSimplexInRn_succ_eq_image_snocMeasurableEquiv ];
                exact measurableSet_stdSimplexInRn_scaled _ _ |> MeasurableSet.preimage <| measurable_pi_iff.mpr fun _ => measurable_pi_apply _;
            aesop;
          · refine' MeasurableSet.inter ( measurableSet_le measurable_const measurable_snd ) ( MeasurableSet.inter ( measurableSet_le measurable_snd measurable_const ) _ );
            refine' MeasurableSet.inter _ _;
            · exact MeasurableSet.congr ( MeasurableSet.iInter fun _ => measurableSet_le measurable_const ( measurable_pi_apply _ |> Measurable.comp <| measurable_fst ) ) ( by aesop );
            · exact measurableSet_le ( Finset.measurable_sum _ fun i _ => measurable_pi_apply i |> Measurable.comp <| measurable_fst ) ( measurable_const.sub measurable_snd );
          · norm_num [ Filter.EventuallyEq, Set.indicator ];
        rw [ h_fubini, MeasureTheory.lintegral_prod ];
        · rw [ MeasureTheory.lintegral_lintegral_swap ];
          · rw [ ← MeasureTheory.lintegral_indicator ] <;> norm_num [ Set.indicator ];
            congr with y ; by_cases hy : 0 ≤ y <;> by_cases hy' : y ≤ 1 <;> simp +decide [ hy, hy' ];
            erw [ MeasureTheory.lintegral_indicator ] ; aesop;
            exact measurableSet_stdSimplexInRn_scaled n ( 1 - y );
          · refine' Measurable.aemeasurable _;
            refine' Measurable.ite _ measurable_const measurable_const;
            refine' MeasurableSet.inter ( measurableSet_le measurable_const measurable_snd ) ( MeasurableSet.inter ( measurableSet_le measurable_snd measurable_const ) _ );
            refine' MeasurableSet.inter _ _;
            · exact MeasurableSet.congr ( MeasurableSet.iInter fun _ => measurableSet_le measurable_const ( measurable_pi_apply _ |> Measurable.comp <| measurable_fst ) ) ( by aesop );
            · exact measurableSet_le ( Finset.measurable_sum _ fun i _ => measurable_pi_apply i |> Measurable.comp <| measurable_fst ) ( measurable_const.sub measurable_snd );
        · refine' Measurable.aemeasurable _;
          refine' Measurable.ite _ measurable_const measurable_const;
          refine' MeasurableSet.inter ( measurableSet_le measurable_const measurable_snd ) ( MeasurableSet.inter ( measurableSet_le measurable_snd measurable_const ) _ );
          refine' MeasurableSet.inter _ _;
          · exact MeasurableSet.congr ( MeasurableSet.iInter fun _ => measurableSet_le measurable_const ( measurable_pi_apply _ |> Measurable.comp <| measurable_fst ) ) ( by aesop );
          · exact measurableSet_le ( Finset.measurable_sum _ fun i _ => measurable_pi_apply i |> Measurable.comp <| measurable_fst ) ( measurable_const.sub measurable_snd );
      -- Using the induction hypothesis, we can simplify the integral.
      have h_integral_simplified : ∫⁻ t in Set.Icc (0 : ℝ) 1, MeasureTheory.volume (stdSimplexInRn_scaled n (1 - t)) = ∫⁻ t in Set.Icc (0 : ℝ) 1, ENNReal.ofReal ((1 - t) ^ n) * MeasureTheory.volume (stdSimplexInRn n) := by
        have h_integral_simplified : ∀ t ∈ Set.Icc (0 : ℝ) 1, MeasureTheory.volume (stdSimplexInRn_scaled n (1 - t)) = ENNReal.ofReal ((1 - t) ^ n) * MeasureTheory.volume (stdSimplexInRn n) := by
          intro t ht
          have h_volume_scaled : MeasureTheory.volume (stdSimplexInRn_scaled n (1 - t)) = ENNReal.ofReal ((1 - t) ^ n) * MeasureTheory.volume (stdSimplexInRn_scaled n 1) := by
            convert volume_stdSimplexInRn_scaled_eq_pow_mul_volume n ( 1 - t ) ( sub_nonneg.mpr ht.2 ) using 1;
          convert h_volume_scaled using 3;
        rw [ MeasureTheory.lintegral_congr_ae ( Filter.eventually_of_mem ( MeasureTheory.ae_restrict_mem measurableSet_Icc ) h_integral_simplified ) ];
      -- Evaluate the integral $\int_{0}^{1} (1-t)^n \, dt$.
      have h_integral_eval : ∫⁻ t in Set.Icc (0 : ℝ) 1, ENNReal.ofReal ((1 - t) ^ n) = ENNReal.ofReal (1 / (n + 1)) := by
        rw [ ← MeasureTheory.ofReal_integral_eq_lintegral_ofReal ];
        · rw [ MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le zero_le_one, intervalIntegral.integral_comp_sub_left fun x => x ^ n ] ; norm_num;
        · exact Continuous.integrableOn_Icc ( by continuity );
        · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Icc ] with t ht using pow_nonneg ( sub_nonneg.2 ht.2 ) _;
      simp_all +decide [ Nat.factorial_succ, mul_comm, MeasureTheory.lintegral_const_mul' ]

/-
The volume of a simplex is the absolute determinant of its side matrix divided by n!.
-/
theorem simplexVolume_eq_abs_det_simplexSideMatrix_div_factorial {n : ℕ} (s : Affine.Simplex ℝ (EuclideanSpace ℝ (Fin n)) n) :
  simplexVolume s = |(simplexSideMatrix s).det| / (Nat.factorial n) := by
    -- The formula holds as a matrix equality because both sides are equal as matrices.
    have hj_eq : (MeasureTheory.volume (convexHull ℝ (Set.range s.points))) = ENNReal.ofReal (abs (Matrix.det (simplexSideMatrix s))) * (ENNReal.ofReal (1 / (Nat.factorial n))) := by
      -- The volume of the image of a set under a linear transformation is the absolute value of the determinant of the transformation times the volume of the original set.
      have h_volume_image : ∀ (T : EuclideanSpace ℝ (Fin n) →ₗ[ℝ] EuclideanSpace ℝ (Fin n)) (S : Set (EuclideanSpace ℝ (Fin n))), MeasureTheory.volume (T '' S) = ENNReal.ofReal (abs (LinearMap.det T)) * MeasureTheory.volume S := by
        exact?;
      have h_volume_image : MeasureTheory.volume (convexHull ℝ (Set.range s.points)) = MeasureTheory.volume (Set.image (fun x : EuclideanSpace ℝ (Fin n) => s.points 0 + ∑ i, x i • (s.points (Fin.succ i) - s.points 0)) (stdSimplexInRn n)) := by
        congr with x;
        constructor;
        · intro hx
          obtain ⟨w, hw⟩ : ∃ w : Fin (n + 1) → ℝ, (∀ i, 0 ≤ w i) ∧ (∑ i, w i = 1) ∧ x = ∑ i, w i • s.points i := by
            rw [ convexHull_eq ] at hx;
            obtain ⟨ ι, t, w, z, hw₁, hw₂, hw₃, rfl ⟩ := hx;
            choose! f hf using hw₃;
            refine' ⟨ fun i => ∑ j ∈ t.filter ( fun j => f j = i ), w j, _, _, _ ⟩ <;> simp_all +decide [ Finset.centerMass ];
            · exact fun i => Finset.sum_nonneg fun j hj => hw₁ j <| Finset.mem_filter.mp hj |>.1;
            · rw [ ← hw₂, Finset.sum_fiberwise ];
            · simp +decide [ Finset.sum_filter, Finset.sum_smul, hf ];
              rw [ Finset.sum_comm, Finset.sum_congr rfl ] ; aesop;
          use fun i => w (Fin.succ i);
          simp_all +decide [ Fin.sum_univ_succ, stdSimplexInRn ];
          simp_all +decide [ Finset.sum_sub_distrib, smul_sub, sub_smul ];
          simp_all +decide [ ← Finset.sum_smul, ← eq_sub_iff_add_eq' ];
          ext ; norm_num ; ring;
        · rintro ⟨ y, ⟨ hy₁, hy₂ ⟩, rfl ⟩;
          -- By definition of convex hull, we need to show that the point is a convex combination of the points in the range of s.points.
          have h_convex_comb : ∃ (w : Fin (n + 1) → ℝ), (∀ i, 0 ≤ w i) ∧ (∑ i, w i = 1) ∧ (s.points 0 + ∑ i, y i • (s.points (Fin.succ i) - s.points 0)) = ∑ i, w i • s.points i := by
            refine' ⟨ Fin.cons ( 1 - ∑ i, y i ) y, _, _, _ ⟩ <;> simp_all +decide [ Fin.sum_univ_succ ];
            · exact fun i => Fin.cases ( sub_nonneg.2 hy₂ ) ( fun i => hy₁ i ) i;
            · simp +decide [ sub_smul, Finset.sum_sub_distrib, smul_sub ];
              rw [ ← Finset.sum_smul ] ; abel1;
          rw [ convexHull_eq ];
          obtain ⟨ w, hw₁, hw₂, hw₃ ⟩ := h_convex_comb;
          use Fin (n + 1), Finset.univ, w, fun i => s.points i;
          simp_all +decide [ Finset.centerMass ];
      have h_volume_image : MeasureTheory.volume (Set.image (fun x : EuclideanSpace ℝ (Fin n) => s.points 0 + ∑ i, x i • (s.points (Fin.succ i) - s.points 0)) (stdSimplexInRn n)) = MeasureTheory.volume (Set.image (fun x : EuclideanSpace ℝ (Fin n) => ∑ i, x i • (s.points (Fin.succ i) - s.points 0)) (stdSimplexInRn n)) := by
        rw [ ← MeasureTheory.measure_preimage_add_right ];
        rw [ show ( fun h => h + s.points 0 ) ⁻¹' ( ( fun x => s.points 0 + ∑ i, x i • ( s.points i.succ - s.points 0 ) ) '' stdSimplexInRn n ) = ( fun x => ∑ i, x i • ( s.points i.succ - s.points 0 ) ) '' stdSimplexInRn n from ?_ ];
        ext; simp [Set.mem_preimage, Set.mem_image];
        grind;
      have h_volume_image : MeasureTheory.volume (Set.image (fun x : EuclideanSpace ℝ (Fin n) => ∑ i, x i • (s.points (Fin.succ i) - s.points 0)) (stdSimplexInRn n)) = ENNReal.ofReal (abs (Matrix.det (Matrix.of (fun i j => (s.points (Fin.succ j) - s.points 0) i)))) * MeasureTheory.volume (stdSimplexInRn n) := by
        convert ‹∀ ( T : EuclideanSpace ℝ ( Fin n ) →ₗ[ℝ] EuclideanSpace ℝ ( Fin n ) ) ( S : Set ( EuclideanSpace ℝ ( Fin n ) ) ), MeasureTheory.volume ( T '' S ) = ENNReal.ofReal |LinearMap.det T| * MeasureTheory.volume S› ( show ( EuclideanSpace ℝ ( Fin n ) →ₗ[ℝ] EuclideanSpace ℝ ( Fin n ) ) from ( Matrix.toLin' ( Matrix.of fun i j => ( s.points j.succ - s.points 0 ) i ) ) ) ( stdSimplexInRn n ) using 1;
        · congr! 2;
          ext i; simp +decide [ Matrix.mulVec, dotProduct, Finset.mul_sum _ _ _ ] ;
          erw [ Matrix.toLin'_apply ] ; simp +decide [ Matrix.mulVec, dotProduct, Finset.mul_sum _ _ _ ];
          rw [ Finset.sum_apply ] ; simp +decide [ mul_comm ];
        · erw [ LinearMap.det_toLin' ];
      convert h_volume_image using 1;
      · grind;
      · rw [ show MeasureTheory.volume ( stdSimplexInRn n ) = ENNReal.ofReal ( 1 / ( n ! : ℝ ) ) from ?_ ];
        · rfl;
        · convert volume_stdSimplexInRn n using 1;
    unfold simplexVolume; aesop;

/-
The Gram matrix of a simplex is the matrix of dot products of the vectors from the first vertex to the other vertices.
-/
noncomputable def simplexGramMatrix {n : ℕ} (s : Affine.Simplex ℝ (EuclideanSpace ℝ (Fin n)) n) : Matrix (Fin n) (Fin n) ℝ :=
  Matrix.of fun i j => inner ℝ (s.points i.succ - s.points 0) (s.points j.succ - s.points 0)

/-
The determinant of the Gram matrix of a simplex is the square of the determinant of its side matrix.
-/
theorem det_simplexGramMatrix_eq_sq_det_simplexSideMatrix {n : ℕ} (s : Affine.Simplex ℝ (EuclideanSpace ℝ (Fin n)) n) :
  (simplexGramMatrix s).det = (simplexSideMatrix s).det ^ 2 := by
    -- By definition of the Gram matrix, we have G = A^T * A.
    have h_gram : simplexGramMatrix s = (simplexSideMatrix s).transpose * simplexSideMatrix s := by
      ext i j; simp +decide [ simplexGramMatrix, simplexSideMatrix, Matrix.mul_apply ] ; ring;
      simp +decide [ Finset.sum_add_distrib, Finset.mul_sum _ _ _, Finset.sum_mul, sq, inner ] ; ring;
      simpa only [ ← Finset.sum_add_distrib, ← Finset.sum_sub_distrib, ← Finset.sum_neg_distrib ] using Finset.sum_congr rfl fun _ _ => by ring;
    rw [ h_gram, Matrix.det_mul, Matrix.det_transpose, sq ]

/-
The square of the volume of a simplex is the determinant of its Gram matrix divided by the square of n factorial.
-/
theorem simplexVolume_sq_eq_det_simplexGramMatrix_div_factorial_sq {n : ℕ} (s : Affine.Simplex ℝ (EuclideanSpace ℝ (Fin n)) n) :
  (simplexVolume s) ^ 2 = (simplexGramMatrix s).det / (Nat.factorial n) ^ 2 := by
    rw [ det_simplexGramMatrix_eq_sq_det_simplexSideMatrix ];
    convert congr_arg ( · ^ 2 ) ( simplexVolume_eq_abs_det_simplexSideMatrix_div_factorial s ) using 1 ; ring;
    norm_num [ mul_comm ]

/-
The reduced Cayley-Menger matrix is defined using pattern matching on indices. Row 0 is (0, 1, 0...0). Row 1 is (1, 0, |v_1|^2...|v_n|^2). Row i+2 is (0, |v_i|^2, -2 G_i,j).
-/
noncomputable def cayleyMengerReducedMatrix {n : ℕ} (s : Affine.Simplex ℝ (EuclideanSpace ℝ (Fin n)) n) : Matrix (Fin (n + 2)) (Fin (n + 2)) ℝ :=
  Matrix.of fun i j =>
    Fin.cases
      (Fin.cases 0 (fun _ => 0) j) -- Row 0: 0, 1, 0, ..., 0. Wait, the code says 0 then 0?
      (fun i_pred =>
        Fin.cases
          (Fin.cases 1 (fun j_pred => -- Row 1
             Fin.cases 0 (fun j_pred_pred => -- Col 1 is 0? No, Col 0 is 1. Col 1 is 0.
               dist (s.points (Fin.succ j_pred_pred)) (s.points 0) ^ 2
             ) j_pred
          ) j)
          (fun i_pred_pred => -- Row i >= 2
             Fin.cases 0 (fun j_pred => -- Col 0 is 0
               Fin.cases (dist (s.points (Fin.succ i_pred_pred)) (s.points 0) ^ 2) (fun j_pred_pred => -- Col 1 is |v|^2
                 -2 * inner ℝ (s.points (Fin.succ i_pred_pred) - s.points 0) (s.points (Fin.succ j_pred_pred) - s.points 0)
               ) j_pred
             ) j
          ) i_pred
      ) i

/-
The row subtraction matrix is a lower triangular matrix with 1s on the diagonal, so its determinant is 1.
-/
noncomputable def rowSubtractionMatrix (n : ℕ) : Matrix (Fin (n + 2)) (Fin (n + 2)) ℝ :=
  Matrix.of fun i j =>
    if i = j then 1
    else if j = 1 ∧ i > 1 then -1
    else 0

theorem det_rowSubtractionMatrix_eq_one (n : ℕ) : (rowSubtractionMatrix n).det = 1 := by
  have h_det_L : ∀ i j, i ≠ j → i < j → (rowSubtractionMatrix n i j) = 0 := by
    unfold rowSubtractionMatrix; aesop;
  rw [ ← Matrix.det_transpose, Matrix.det_of_upperTriangular ];
  · unfold rowSubtractionMatrix; aesop;
  · intro i j hij; aesop;

/-
The column subtraction matrix is an upper triangular matrix with 1s on the diagonal, so its determinant is 1.
-/
noncomputable def colSubtractionMatrix (n : ℕ) : Matrix (Fin (n + 2)) (Fin (n + 2)) ℝ :=
  Matrix.of fun i j =>
    if i = j then 1
    else if i = 1 ∧ j > 1 then -1
    else 0

theorem det_colSubtractionMatrix_eq_one (n : ℕ) : (colSubtractionMatrix n).det = 1 := by
  have h_upper_triangular : ∀ i j : Fin (n + 2), i > j → colSubtractionMatrix n i j = 0 := by
    intro i j hij; unfold colSubtractionMatrix; aesop;
  rw [ Matrix.det_of_upperTriangular ];
  · unfold colSubtractionMatrix; aesop;
  · exact fun i j hij => h_upper_triangular i j hij

/-
The intermediate Cayley-Menger matrix is obtained by subtracting the second row from all subsequent rows of the Cayley-Menger matrix.
-/
noncomputable def cayleyMengerIntermediateMatrix {n : ℕ} (s : Affine.Simplex ℝ (EuclideanSpace ℝ (Fin n)) n) : Matrix (Fin (n + 2)) (Fin (n + 2)) ℝ :=
  Matrix.of fun i j =>
    if i = 0 ∨ i = 1 then
      (cayleyMengerMatrix s) i j
    else
      (cayleyMengerMatrix s) i j - (cayleyMengerMatrix s) 1 j

/-
The intermediate Cayley-Menger matrix is the product of the row subtraction matrix and the Cayley-Menger matrix.
-/
theorem cayleyMengerIntermediateMatrix_eq_mul (n : ℕ) (s : Affine.Simplex ℝ (EuclideanSpace ℝ (Fin n)) n) :
  cayleyMengerIntermediateMatrix s = (rowSubtractionMatrix n) * (cayleyMengerMatrix s) := by
    unfold cayleyMengerIntermediateMatrix rowSubtractionMatrix; ext i j; simp +decide [ Matrix.mul_apply ] ;
    split_ifs <;> simp_all +decide [ Finset.sum_ite, Finset.filter_eq', Finset.filter_ne' ];
    · rcases ‹_› with ( rfl | rfl ) <;> simp +decide [ Finset.sum_filter ];
    · by_cases hi : 1 < i <;> simp_all +decide [ Finset.filter_eq', Finset.filter_and ];
      · rw [ Finset.sum_eq_single i ] <;> aesop;
      · rcases i with ⟨ _ | _ | i, hi ⟩ <;> tauto

/-
The determinant of the Cayley-Menger matrix is equal to the determinant of the intermediate Cayley-Menger matrix.
-/
theorem det_cayleyMengerMatrix_eq_det_cayleyMengerIntermediateMatrix {n : ℕ} (s : Affine.Simplex ℝ (EuclideanSpace ℝ (Fin n)) n) :
  (cayleyMengerMatrix s).det = (cayleyMengerIntermediateMatrix s).det := by
    erw [ cayleyMengerIntermediateMatrix_eq_mul ];
    rw [ Matrix.det_mul, det_rowSubtractionMatrix_eq_one ] ; norm_num

/-
The product of the intermediate Cayley-Menger matrix and the column subtraction matrix has entries equal to the intermediate matrix entries for the first two columns, and the difference between the entry and the second column entry for the other columns.
-/
theorem cayleyMengerIntermediateMatrix_mul_colSubtractionMatrix_apply {n : ℕ} (s : Affine.Simplex ℝ (EuclideanSpace ℝ (Fin n)) n) (i j : Fin (n + 2)) :
  ((cayleyMengerIntermediateMatrix s) * (colSubtractionMatrix n)) i j =
    if j = 0 ∨ j = 1 then
      (cayleyMengerIntermediateMatrix s) i j
    else
      (cayleyMengerIntermediateMatrix s) i j - (cayleyMengerIntermediateMatrix s) i 1 := by
        unfold cayleyMengerIntermediateMatrix colSubtractionMatrix;
        by_cases hj : j = 0 <;> by_cases hj' : j = 1 <;> simp +decide [ hj, hj', Matrix.mul_apply ];
        rcases lt_trichotomy j 1 with ( hj'' | rfl | hj'' ) <;> simp_all +decide [ Finset.sum_ite, Finset.filter_eq', Finset.filter_and ];
        rw [ if_neg ( Ne.symm hj' ) ] ; ring

/-
The 0-th column of the reduced Cayley-Menger matrix matches the 0-th column of the product of the intermediate matrix and the column subtraction matrix.
-/
theorem cayleyMengerReducedMatrix_eq_mul_col_zero {n : ℕ} (s : Affine.Simplex ℝ (EuclideanSpace ℝ (Fin n)) n) (i : Fin (n + 2)) :
  cayleyMengerReducedMatrix s i 0 = ((cayleyMengerIntermediateMatrix s) * (colSubtractionMatrix n)) i 0 := by
    rw [ cayleyMengerIntermediateMatrix_mul_colSubtractionMatrix_apply ];
    unfold cayleyMengerReducedMatrix cayleyMengerIntermediateMatrix;
    rcases i with ⟨ _ | _ | i, hi ⟩ <;> norm_num [ cayleyMengerMatrix ];
    · rfl;
    · exact?

/-
The correct reduced Cayley-Menger matrix. Row 0 is (0, 1, 0...0). Row 1 is (1, 0, |v_1|^2...|v_n|^2). Row i+2 is (0, |v_i|^2, -2 G_i,j).
-/
noncomputable def cayleyMengerReducedMatrixCorrect {n : ℕ} (s : Affine.Simplex ℝ (EuclideanSpace ℝ (Fin n)) n) : Matrix (Fin (n + 2)) (Fin (n + 2)) ℝ :=
  Matrix.of fun i j =>
    Fin.cases
      (Fin.cases 0 (fun j_pred => Fin.cases 1 (fun _ => 0) j_pred) j) -- Row 0: 0, 1, 0, ..., 0
      (fun i_pred =>
        Fin.cases
          (Fin.cases 1 (fun j_pred => -- Row 1
             Fin.cases 0 (fun j_pred_pred => -- Col 1 is 0
               dist (s.points (Fin.succ j_pred_pred)) (s.points 0) ^ 2
             ) j_pred
          ) j)
          (fun i_pred_pred => -- Row i >= 2
             Fin.cases 0 (fun j_pred => -- Col 0 is 0
               Fin.cases (dist (s.points (Fin.succ i_pred_pred)) (s.points 0) ^ 2) (fun j_pred_pred => -- Col 1 is |v|^2
                 -2 * inner ℝ (s.points (Fin.succ i_pred_pred) - s.points 0) (s.points (Fin.succ j_pred_pred) - s.points 0)
               ) j_pred
             ) j
          ) i_pred
      ) i

/-
The squared distance between x and y minus the squared norms of x and y is equal to -2 times the inner product of x and y.
-/
lemma dist_sq_sub_norm_sq_sub_norm_sq_eq_neg_two_mul_inner {V : Type*} [NormedAddCommGroup V] [InnerProductSpace ℝ V] (x y : V) :
  dist x y ^ 2 - ‖y‖ ^ 2 - ‖x‖ ^ 2 = -2 * inner ℝ x y := by
    rw [ dist_eq_norm, norm_sub_sq_real ] ; ring

/-
The bottom-right block of the product of the intermediate Cayley-Menger matrix and the column subtraction matrix contains the inner products of the simplex sides, scaled by -2.
-/
lemma cayleyMengerIntermediate_mul_colSubtraction_bottom_right (n : ℕ) (s : Affine.Simplex ℝ (EuclideanSpace ℝ (Fin n)) n) (i j : Fin n) :
  ((cayleyMengerIntermediateMatrix s) * (colSubtractionMatrix n)) (i.succ.succ) (j.succ.succ) = -2 * inner ℝ (s.points i.succ - s.points 0) (s.points j.succ - s.points 0) := by
    convert dist_sq_sub_norm_sq_sub_norm_sq_eq_neg_two_mul_inner ( s.points i.succ - s.points 0 ) ( s.points j.succ - s.points 0 ) using 1 ; norm_num [ dist_eq_norm, EuclideanSpace.norm_eq ] ; ring!;
    rw [ Real.sq_sqrt, Real.sq_sqrt, Real.sq_sqrt ] <;> norm_num [ Finset.sum_add_distrib, Finset.mul_sum _ _ _, Finset.sum_mul _ _ _, mul_assoc, mul_comm, mul_left_comm, sq ] <;> ring!;
    · rw [ cayleyMengerIntermediateMatrix_mul_colSubtractionMatrix_apply ] ; norm_num [ Fin.sum_univ_succ, dist_eq_norm, EuclideanSpace.norm_eq ] ; ring!;
      rw [ show cayleyMengerIntermediateMatrix s i.succ.succ j.succ.succ = dist ( s.points ( Fin.succ i ) ) ( s.points ( Fin.succ j ) ) ^ 2 - dist ( s.points 0 ) ( s.points ( Fin.succ j ) ) ^ 2 from ?_, show cayleyMengerIntermediateMatrix s i.succ.succ 1 = dist ( s.points ( Fin.succ i ) ) ( s.points 0 ) ^ 2 - dist ( s.points 0 ) ( s.points 0 ) ^ 2 from ?_ ] ; norm_num [ dist_eq_norm, EuclideanSpace.norm_eq ] ; ring!;
      · rw [ Real.sq_sqrt <| Finset.sum_nonneg fun _ _ => _, Real.sq_sqrt <| Finset.sum_nonneg fun _ _ => _, Real.sq_sqrt <| Finset.sum_nonneg fun _ _ => _ ] <;> norm_num [ Finset.sum_add_distrib, Finset.mul_sum _ _ _, Finset.sum_mul _ _ _, mul_assoc, mul_comm, mul_left_comm, sq ] ; ring!;
        · split_ifs <;> norm_num [ ← Finset.sum_mul _ _ _ ] ; ring!;
          · cases ‹_›;
          · ring;
        · exact fun x => by linarith [ sq_nonneg ( s.points i.succ x - s.points 0 x ) ] ;
        · exact fun x => by linarith [ sq_nonneg ( s.points j.succ x - s.points 0 x ) ] ;
        · exact fun x => by linarith [ sq_nonneg ( s.points i.succ x - s.points j.succ x ) ] ;
      · exact?;
      · exact?;
    · rw [ ← Finset.sum_neg_distrib ] ; rw [ ← Finset.sum_add_distrib, ← Finset.sum_add_distrib ] ; exact Finset.sum_nonneg fun _ _ => by nlinarith only [ sq_nonneg ( s.points i.succ ‹_› - s.points 0 ‹_› ) ] ;
    · rw [ neg_add_eq_sub, sub_add_eq_add_sub ];
      rw [ ← Finset.sum_add_distrib, ← Finset.sum_sub_distrib ];
      exact Finset.sum_nonneg fun _ _ => by linarith [ sq_nonneg ( s.points j.succ ‹_› - s.points 0 ‹_› ) ] ;
    · simpa only [ ← Finset.sum_add_distrib, ← Finset.sum_neg_distrib, ← Finset.sum_sub_distrib ] using Finset.sum_nonneg fun x _ => by linarith [ sq_nonneg ( s.points i.succ x - s.points j.succ x ), sq_nonneg ( s.points i.succ x + s.points j.succ x ) ] ;

/-
The 0-th row of the reduced Cayley-Menger matrix is equal to the 0-th row of the product of the intermediate matrix and the column subtraction matrix.
-/
lemma cayleyMengerReducedMatrixCorrect_row0 (n : ℕ) (s : Affine.Simplex ℝ (EuclideanSpace ℝ (Fin n)) n) (j : Fin (n + 2)) :
  cayleyMengerReducedMatrixCorrect s 0 j = ((cayleyMengerIntermediateMatrix s) * (colSubtractionMatrix n)) 0 j := by
    rcases j with ⟨ _ | _ | j, hj ⟩ <;> norm_num [ Fin.cases, Fin.sum_univ_succ ];
    · unfold cayleyMengerIntermediateMatrix cayleyMengerReducedMatrixCorrect colSubtractionMatrix; norm_num [ Fin.sum_univ_succ ] ;
      unfold cayleyMengerMatrix; norm_num [ Matrix.mul_apply ] ;
    · unfold cayleyMengerIntermediateMatrix colSubtractionMatrix cayleyMengerReducedMatrixCorrect; simp +decide [ Fin.sum_univ_succ, Matrix.mul_apply ] ;
      exact?;
    · simp +decide [ cayleyMengerReducedMatrixCorrect, cayleyMengerIntermediateMatrix, colSubtractionMatrix ];
      simp +decide [ Matrix.mul_apply, Finset.sum_ite ];
      simp +decide [ Finset.filter_eq', Finset.filter_and, Finset.filter_ne', Finset.sum_singleton, cayleyMengerMatrix ];
      split_ifs <;> simp_all +decide [ Fin.lt_iff_val_lt_val ];
      exact?

/-
The 1st row of the reduced Cayley-Menger matrix is identical to the 1st row of the original Cayley-Menger matrix.
-/
lemma cayleyMengerReducedMatrixCorrect_eq_cayleyMenger_row1 (n : ℕ) (s : Affine.Simplex ℝ (EuclideanSpace ℝ (Fin n)) n) (j : Fin (n + 2)) :
  cayleyMengerReducedMatrixCorrect s 1 j = cayleyMengerMatrix s 1 j := by
    unfold cayleyMengerReducedMatrixCorrect cayleyMengerMatrix; rcases j with ⟨ _ | _ | j, hj ⟩ <;> norm_num ; norm_cast;
    · simp +decide [ Fin.cases ];
      norm_num [ Fin.induction ];
      erw [ Fin.induction.go ] ; norm_num [ Fin.induction.go ];
      erw [ Fin.induction.go ] ; norm_num [ Fin.induction.go ];
      erw [ Fin.induction.go ] ; norm_num [ Fin.induction.go ];
      erw [ Fin.induction.go ] ; norm_num [ Fin.induction.go ];
    · norm_num [ Fin.ext_iff, dist_eq_norm ];
      erw [ norm_sub_rev ] ; ring;
      exact?

/-
The (1, 1) entry of the Cayley-Menger matrix is 0.
-/
lemma cayleyMengerMatrix_one_one_eq_zero (n : ℕ) (s : Affine.Simplex ℝ (EuclideanSpace ℝ (Fin n)) n) :
  cayleyMengerMatrix s 1 1 = 0 := by
    -- By definition of Cayley-Menger matrix, the (1, 1) entry is zero.
    simp [cayleyMengerMatrix];
    simp [Fin.cases];
    norm_num [ Fin.induction ] at *;
    erw [ Fin.induction.go ] ; norm_num;
    erw [ Fin.induction.go ] ; norm_num

/-
The 1st row of the product of the intermediate matrix and the column subtraction matrix is equal to the 1st row of the original Cayley-Menger matrix.
-/
lemma cayleyMengerIntermediate_mul_colSubtraction_row1 (n : ℕ) (s : Affine.Simplex ℝ (EuclideanSpace ℝ (Fin n)) n) (j : Fin (n + 2)) :
  ((cayleyMengerIntermediateMatrix s) * (colSubtractionMatrix n)) 1 j = cayleyMengerMatrix s 1 j := by
    unfold cayleyMengerIntermediateMatrix colSubtractionMatrix; simp +decide [ Fin.sum_univ_succ, Matrix.mul_apply ] ;
    rcases j with ⟨ _ | _ | j, hj ⟩ <;> simp_all +decide [ Fin.ext_iff, Fin.sum_univ_succ ];
    rw [ Finset.sum_eq_single ⟨ j, by linarith ⟩ ] <;> norm_num;
    · exact?;
    · exact fun b hb₁ hb₂ => False.elim <| hb₁ <| Fin.ext hb₂

/-
The (0, 0) entry of the Cayley-Menger matrix is 0.
-/
lemma cayleyMengerMatrix_apply_zero_zero (n : ℕ) (s : Affine.Simplex ℝ (EuclideanSpace ℝ (Fin n)) n) :
  cayleyMengerMatrix s 0 0 = 0 := by
    rfl

/-
The (0, j+1) entry of the Cayley-Menger matrix is 1.
-/
lemma cayleyMengerMatrix_apply_zero_succ (n : ℕ) (s : Affine.Simplex ℝ (EuclideanSpace ℝ (Fin n)) n) (j : Fin (n + 1)) :
  cayleyMengerMatrix s 0 j.succ = 1 := by
    exact?

/-
The (i+1, 0) entry of the Cayley-Menger matrix is 1.
-/
lemma cayleyMengerMatrix_apply_succ_zero (n : ℕ) (s : Affine.Simplex ℝ (EuclideanSpace ℝ (Fin n)) n) (i : Fin (n + 1)) :
  cayleyMengerMatrix s i.succ 0 = 1 := by
    exact?

/-
The (i+1, j+1) entry of the Cayley-Menger matrix is the squared distance between vertices i and j.
-/
lemma cayleyMengerMatrix_apply_succ_succ (n : ℕ) (s : Affine.Simplex ℝ (EuclideanSpace ℝ (Fin n)) n) (i j : Fin (n + 1)) :
  cayleyMengerMatrix s i.succ j.succ = dist (s.points i) (s.points j) ^ 2 := by
    cases i ; cases j ; aesop

/-
The (k+2, 0) entry of the Cayley-Menger matrix is 1.
-/
lemma cayleyMengerMatrix_apply_succ_succ_zero (n : ℕ) (s : Affine.Simplex ℝ (EuclideanSpace ℝ (Fin n)) n) (k : Fin n) :
  cayleyMengerMatrix s k.succ.succ 0 = 1 := by
    exact?

/-
The (1, 1) entry of the Cayley-Menger matrix is 0.
-/
lemma cayleyMengerMatrix_apply_one_one_eq_zero (n : ℕ) (s : Affine.Simplex ℝ (EuclideanSpace ℝ (Fin n)) n) :
  cayleyMengerMatrix s 1 1 = 0 := by
    exact?

/-
An index i in Fin (n+2) is >= 2 iff it is the double successor of some k in Fin n.
-/
lemma fin_ge_two_iff_exists_succ_succ {n : ℕ} (i : Fin (n + 2)) : 2 ≤ i.val ↔ ∃ k : Fin n, i = k.succ.succ := by
  exact ⟨ fun hi => ⟨ ⟨ i - 2, by omega ⟩, by rcases i with ⟨ _ | _ | i, hi ⟩ <;> trivial ⟩, by rintro ⟨ k, rfl ⟩ ; exact Nat.le_add_left _ _ ⟩

/-
If i.val >= 2 in Fin (n+2), then i is the double successor of some k in Fin n.
-/
lemma exists_succ_succ_of_ge_two_val {n : ℕ} (i : Fin (n + 2)) (hi : 2 ≤ i.val) : ∃ k : Fin n, i = k.succ.succ := by
  exact?

/-
For rows i with value >= 2, the 0-th column of the Cayley-Menger matrix is 1.
-/
lemma cayleyMengerMatrix_apply_ge_two_zero (n : ℕ) (s : Affine.Simplex ℝ (EuclideanSpace ℝ (Fin n)) n) (i : Fin (n + 2)) (hi : 2 ≤ i.val) :
  cayleyMengerMatrix s i 0 = 1 := by
    -- Since $i.val \ �ge�q 2$, by `exists_succ_succ_of_ge_two_val`, there exists $k$ such that $i = k.succ.succ$.
    obtain ⟨k, rfl⟩ : ∃ k : Fin n, i = k.succ.succ := by
      exact?;
    exact?

/-
The 0-th column of the column subtraction matrix is 1 at index 0 and 0 elsewhere.
-/
lemma colSubtractionMatrix_apply_zero (n : ℕ) (k : Fin (n + 2)) :
  colSubtractionMatrix n k 0 = if k = 0 then 1 else 0 := by
    unfold colSubtractionMatrix; aesop;

/-
If i.val >= 2, then i is neither 0 nor 1.
-/
lemma ne_zero_and_ne_one_of_ge_two_val {n : ℕ} (i : Fin (n + 2)) (hi : 2 ≤ i.val) : i ≠ 0 ∧ i ≠ 1 := by
  exact ⟨ by rintro rfl; contradiction, by rintro rfl; contradiction ⟩

/-
The (1, 0) entry of the Cayley-Menger matrix is 1.
-/
lemma cayleyMengerMatrix_apply_one_zero (n : ℕ) (s : Affine.Simplex ℝ (EuclideanSpace ℝ (Fin n)) n) :
  cayleyMengerMatrix s 1 0 = 1 := by
    exact?

/-
For rows i with value >= 2, the intermediate Cayley-Menger matrix entry is the difference of the Cayley-Menger matrix entries.
-/
lemma cayleyMengerIntermediateMatrix_apply_ge_two_val (n : ℕ) (s : Affine.Simplex ℝ (EuclideanSpace ℝ (Fin n)) n) (i j : Fin (n + 2)) (hi : 2 ≤ i.val) :
  cayleyMengerIntermediateMatrix s i j = cayleyMengerMatrix s i j - cayleyMengerMatrix s 1 j := by
    unfold cayleyMengerIntermediateMatrix; aesop;

/-
The corrected reduced Cayley-Menger matrix is the product of the intermediate Cayley-Menger matrix and the column subtraction matrix.
-/
theorem cayleyMengerReducedMatrixCorrect_eq_mul {n : ℕ} (s : Affine.Simplex ℝ (EuclideanSpace ℝ (Fin n)) n) :
  cayleyMengerReducedMatrixCorrect s = (cayleyMengerIntermediateMatrix s) * (colSubtractionMatrix n) := by
    ext i j; by_cases hi : 2 ≤ i.val <;> by_cases hj : 2 ≤ j.val <;> simp_all +decide [ Fin.forall_fin_succ, Matrix.mul_apply ] ;
    · -- Let's simplify the goal using � the� definitions of `cayleyMengerReducedMatrixCorrect` and `cayleyMengerIntermediateMatrix`.
      obtain ⟨k, rfl⟩ : ∃ k : Fin n, i = k.succ.succ := by
        exact ⟨ ⟨ i - 2, by omega ⟩, by rcases i with ⟨ _ | _ | i, hi ⟩ <;> trivial ⟩
      obtain ⟨l, rfl⟩ : ∃ l : Fin n, j = l.succ.succ := by
        exact ⟨ ⟨ j - 2, by omega ⟩, by rcases j with ⟨ _ | _ | j, hj ⟩ <;> trivial ⟩
      generalize_proofs at *;
      convert cayleyMengerIntermediate_mul_colSubtraction_bottom_right n s k l using 1;
      · rw [ cayleyMengerIntermediate_mul_colSubtraction_bottom_right ];
        unfold cayleyMengerReducedMatrixCorrect; aesop;
      · convert cayleyMengerIntermediate_mul_colSubtraction_bottom_right n s k l using 1;
    · rw [ Finset.sum_eq_single 1 ] <;> simp_all +decide [ Finset.sum_range_succ', cayleyMengerReducedMatrixCorrect ];
      · interval_cases _ : ( j : ℕ ) <;> simp_all +decide [ colSubtractionMatrix ];
        · rcases i with ⟨ _ | _ | i, hi ⟩ <;> tauto;
        · rcases i with ⟨ _ | _ | i, hi ⟩ <;> rcases j with ⟨ _ | _ | j, hj ⟩ <;> norm_cast;
          · simp +decide [ cayleyMengerIntermediateMatrix ];
            simp +decide [ cayleyMengerMatrix_apply_succ_succ, cayleyMengerMatrix_apply_one_one_eq_zero ];
            exact?;
          · grind;
      · intro b hb; by_cases hb' : b = 0 <;> by_cases hb'' : b = 1 <;> simp_all +decide [ colSubtractionMatrix ] ;
        · rw [ cayleyMengerIntermediateMatrix_apply_ge_two_val ];
          · exact Or.inl ( sub_eq_zero_of_eq <| by rw [ cayleyMengerMatrix_apply_ge_two_zero _ _ _ hi, cayleyMengerMatrix_apply_one_zero ] );
          · linarith;
        · exact Or.inr ( by rintro rfl; exact hb'' ( by rcases b with ⟨ _ | _ | b, hb ⟩ <;> tauto ) );
    · interval_cases _ : ( i : ℕ ) <;> simp_all +decide [ Fin.forall_fin_succ, Matrix.mul_apply ];
      · convert cayleyMengerReducedMatrixCorrect_row0 n s j using 1;
      · -- Apply the lemma that states the equality for the case � when� i = 1.
        apply Eq.symm; exact (by
        convert cayleyMengerIntermediate_mul_colSubtraction_row1 n s j using 1;
        · rw [ Finset.sum_congr rfl fun x hx => by rw [ show i = 1 from Fin.ext ‹_› ] ] ; aesop;
        · convert cayleyMengerReducedMatrixCorrect_eq_cayleyMenger_row1 n s j using 1
          generalize_proofs at *; (
          congr ; aesop));
    · interval_cases i : ( i : ℕ ) <;> interval_cases j : ( j : ℕ ) <;> simp_all +decide [ Fin.sum_univ_succ, Matrix.mul_apply, cayleyMengerReducedMatrixCorrect, cayleyMengerIntermediateMatrix, colSubtractionMatrix ] ;
      · exact?;
      · rename_i k; rcases k with ⟨ _ | _ | k, hk ⟩ <;> norm_num [ Fin.ext_iff ] at * ; aesop;
      · rw [ show ( _ : Fin ( n + 2 ) ) = 1 from Fin.ext i ] ; simp +decide [ cayleyMengerMatrix ] ;
        rfl;
      · rename_i k l;
        rcases k with ⟨ _ | _ | k, hk ⟩ <;> rcases l with ⟨ _ | _ | l, hl ⟩ <;> norm_cast;
        · simp +decide [ Fin.ext_iff, cayleyMengerMatrix_apply_one_one_eq_zero ];
          rfl;
        · cases j;
        · cases i;
        · cases i

/-
The determinant of the corrected reduced Cayley-Menger matrix is equal to the determinant of the original Cayley-Menger matrix.
-/
theorem det_cayleyMengerReducedMatrixCorrect_eq_det_cayleyMengerMatrix {n : ℕ} (s : Affine.Simplex ℝ (EuclideanSpace ℝ (Fin n)) n) :
  (cayleyMengerReducedMatrixCorrect s).det = (cayleyMengerMatrix s).det := by
    -- By definition of $cayleyMengerReducedMatrixCorrect$, we have $cayleyMengerReducedMatrixCorrect s = (cayleyMengerIntermediateMatrix s) * (colSubtractionMatrix n)$.
    have h_def : cayleyMengerReducedMatrixCorrect s = (cayleyMengerIntermediateMatrix s) * (colSubtractionMatrix n) := by
      exact?;
    rw [ h_def, Matrix.det_mul, det_colSubtractionMatrix_eq_one ];
    rw [ mul_one, det_cayleyMengerMatrix_eq_det_cayleyMengerIntermediateMatrix ]

/-
The determinant of the corrected reduced Cayley-Menger matrix is (-1)^(n+1) * 2^n * det(Gram matrix).
-/
theorem det_cayleyMengerReducedMatrixCorrect_eq_neg_one_pow_succ_mul_two_pow_mul_det_simplexGramMatrix {n : ℕ} (s : Affine.Simplex ℝ (EuclideanSpace ℝ (Fin n)) n) :
  (cayleyMengerReducedMatrixCorrect s).det = (-1)^(n+1) * (2:ℝ)^n * (simplexGramMatrix s).det := by
    -- The submatrix is `subminor` corresponds to removing rows 0 and 1, and columns 0 and 1.
    let M := fun i j : Fin n => cayleyMengerReducedMatrixCorrect s (i.succ.succ) (j.succ.succ);
    -- By definition of $M$, we know that $M = -2 \cdot simplexGramMatrix$.
    have hM : M = -2 • simplexGramMatrix s := by
      ext i j; simp [M, cayleyMengerReducedMatrixCorrect];
      unfold simplexGramMatrix; norm_num [ two_mul ] ;
    -- The determinant of the Cayley-Menger matrix is equal to the determinant of its reduced version.
    have h_det_eq : (cayleyMengerReducedMatrixCorrect s).det = (-1 : ℝ) * Matrix.det M := by
      rw [ Matrix.det_succ_row_zero ];
      rw [ Finset.sum_eq_single ⟨ 1, by linarith ⟩ ] <;> norm_num;
      · rw [ Matrix.det_succ_column_zero ];
        rw [ Finset.sum_eq_single ⟨ 0, by linarith ⟩ ] <;> norm_num;
        · rw [ show ( cayleyMengerReducedMatrixCorrect s 0 1 : ℝ ) = 1 by rfl, show ( cayleyMengerReducedMatrixCorrect s 1 0 : ℝ ) = 1 by rfl ] ; norm_num;
          congr! 1;
        · intro b hb; rw [ show cayleyMengerReducedMatrixCorrect s b.succ 0 = 0 from ?_ ] ; norm_num;
          cases b using Fin.inductionOn <;> aesop;
      · rintro ⟨ _ | _ | i, hi ⟩ hi' <;> norm_num [ hi' ];
        · exact Or.inl rfl;
        · contradiction;
        · exact Or.inl ( by rfl );
    simp_all +decide [ Matrix.det_neg, Matrix.det_smul ] ; ring;
    erw [ Matrix.det_diagonal ] ; norm_num ; ring

/-
The square of the volume of a simplex is equal to `(-1)^(n+1) / (2^n * (n!)^2)` times the determinant of its Cayley-Menger matrix.
-/
theorem simplexVolume_sq_eq_neg_one_pow_succ_div_two_pow_mul_factorial_sq_mul_det_cayleyMengerMatrix {n : ℕ} (s : Affine.Simplex ℝ (EuclideanSpace ℝ (Fin n)) n) :
  (simplexVolume s) ^ 2 = ((-1 : ℝ) ^ (n + 1) / ((2 : ℝ) ^ n * (Nat.factorial n : ℝ) ^ 2)) * (cayleyMengerMatrix s).det := by
    rw [ simplexVolume_sq_eq_det_simplexGramMatrix_div_factorial_sq ];
    rw [ ← det_cayleyMengerReducedMatrixCorrect_eq_det_cayleyMengerMatrix ];
    rw [ div_mul_eq_mul_div, div_eq_div_iff ] <;> first | positivity | rw [ det_cayleyMengerReducedMatrixCorrect_eq_neg_one_pow_succ_mul_two_pow_mul_det_simplexGramMatrix ] ; ring;
    norm_num [ pow_mul' ]

/-
Checking for Fin.castPred and Fin.lastCases
-/
#check Fin.castPred
#check Fin.lastCases

/-
The extended matrix of a simplex is the matrix whose columns are the vertices of the simplex appended with a 1.
-/
noncomputable def simplexExtendedMatrix {n : ℕ} (s : Affine.Simplex ℝ (EuclideanSpace ℝ (Fin n)) n) : Matrix (Fin (n + 1)) (Fin (n + 1)) ℝ :=
  Matrix.of fun i j =>
    if h : i = Fin.last n then
      1
    else
      s.points j (Fin.castPred i h)

/-
The intermediate extended matrix is obtained by subtracting the first column from all other columns.
-/
noncomputable def simplexExtendedMatrixIntermediate {n : ℕ} (s : Affine.Simplex ℝ (EuclideanSpace ℝ (Fin n)) n) : Matrix (Fin (n + 1)) (Fin (n + 1)) ℝ :=
  Matrix.of fun i j =>
    if j = 0 then
      simplexExtendedMatrix s i 0
    else
      simplexExtendedMatrix s i j - simplexExtendedMatrix s i 0

/-
The determinant of the extended matrix is equal to the determinant of the intermediate extended matrix.
-/
theorem det_simplexExtendedMatrix_eq_det_simplexExtendedMatrixIntermediate {n : ℕ} (s : Affine.Simplex ℝ (EuclideanSpace ℝ (Fin n)) n) :
  (simplexExtendedMatrix s).det = (simplexExtendedMatrixIntermediate s).det := by
    -- By definition of $T$, we know that $T$ is upper triangular with 1s on the diagonal, so its determinant is 1.
    have hT_det : Matrix.det (Matrix.of (fun i j => if i = j then 1 else if i = 0 ∧ j > 0 then -1 else 0 : Fin (n + 1) → Fin (n + 1) → ℝ)) = 1 := by
      erw [ Matrix.det_of_upperTriangular ] <;> norm_num;
      intro i j hij; aesop;
    -- By definition of $T$, we know that $M * T = M'$.
    have hM_T : (simplexExtendedMatrix s) * (Matrix.of (fun i j => if i = j then 1 else if i = 0 ∧ j > 0 then -1 else 0 : Fin (n + 1) → Fin (n + 1) → ℝ)) = simplexExtendedMatrixIntermediate s := by
      ext i j; by_cases hj : j = 0 <;> simp +decide [ *, Matrix.mul_apply ] ;
      · unfold simplexExtendedMatrixIntermediate; aesop;
      · simp +decide [ Finset.sum_ite, Finset.filter_ne', Finset.filter_eq', hj ];
        simp +decide [ Finset.sum_filter, Finset.filter_erase, hj, simplexExtendedMatrixIntermediate ];
        rw [ Finset.sum_eq_single 0 ] <;> aesop;
    rw [ ← hM_T, Matrix.det_mul, hT_det, mul_one ]

/-
The submatrix of the intermediate extended matrix obtained by removing the last row and the first column is equal to the side matrix.
-/
lemma submatrix_simplexExtendedMatrixIntermediate_eq_simplexSideMatrix {n : ℕ} (s : Affine.Simplex ℝ (EuclideanSpace ℝ (Fin n)) n) :
  (simplexExtendedMatrixIntermediate s).submatrix Fin.castSucc Fin.succ = simplexSideMatrix s := by
    -- By definition of the intermediate matrix, its submatrix is the side matrix.
    ext i j; simp [simplexExtendedMatrixIntermediate, simplexSideMatrix];
    unfold simplexExtendedMatrix; aesop;

/-
The determinant of the extended matrix is `(-1)^n` times the determinant of the side matrix.
-/
theorem det_simplexExtendedMatrix_eq_neg_one_pow_n_mul_det_simplexSideMatrix {n : ℕ} (s : Affine.Simplex ℝ (EuclideanSpace ℝ (Fin n)) n) :
  (simplexExtendedMatrix s).det = (-1 : ℝ) ^ n * (simplexSideMatrix s).det := by
    convert det_simplexExtendedMatrix_eq_det_simplexExtendedMatrixIntermediate s using 1;
    rw [ ← submatrix_simplexExtendedMatrixIntermediate_eq_simplexSideMatrix ];
    -- By definition of matrix multiplication and the properties of determinants, we can expand the determinant of the intermediate extended matrix along the last row.
    have h_expand : (simplexExtendedMatrixIntermediate s).det = ∑ j : Fin (n + 1), (simplexExtendedMatrixIntermediate s (Fin.last n) j) * (-1)^(n + j.val) * (Matrix.submatrix (simplexExtendedMatrixIntermediate s) (Fin.castSucc) (Fin.succAbove j)).det := by
      rw [ Matrix.det_succ_row _ ( Fin.last n ) ];
      simp +decide [ mul_assoc, mul_comm, mul_left_comm, Fin.ext_iff ];
    rw [ h_expand, Finset.sum_eq_single 0 ] <;> norm_num;
    · unfold simplexExtendedMatrixIntermediate; norm_num;
      exact Or.inl ( by unfold simplexExtendedMatrix; aesop );
    · unfold simplexExtendedMatrixIntermediate;
      unfold simplexExtendedMatrix; aesop;

/-
The volume of a simplex is the absolute determinant of its extended matrix divided by n!.
-/
theorem simplexVolume_eq_abs_det_simplexExtendedMatrix_div_factorial {n : ℕ} (s : Affine.Simplex ℝ (EuclideanSpace ℝ (Fin n)) n) :
  simplexVolume s = |(simplexExtendedMatrix s).det| / (Nat.factorial n) := by
    rw [ simplexVolume_eq_abs_det_simplexSideMatrix_div_factorial, det_simplexExtendedMatrix_eq_neg_one_pow_n_mul_det_simplexSideMatrix ];
    norm_num [ abs_mul ]
