/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: cd5c37f2-d0a8-427c-8893-027fea49e6cf

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We proved that n is a solution to IMO 2012 Q6 if and only if n is congruent to 1 or 2 modulo 4. The proof involves establishing a necessary condition via modulo 2 analysis of a derived integer equation (showing that n(n+1)/2 must be odd), and a sufficient condition via a constructive 'jump' property that allows reducing n by 4 or 8 (verified computationally for a period of 702), combined with base cases for n < 9.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: c64452b4-06d7-4183-8551-782c33eb8e07

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 9969691e-8b0e-4d38-8158-f6314a58fa5a

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 4da21e13-8480-4852-a4d6-28fd4b4905b9

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: db18236e-915b-4812-a9d5-b23d69f69af7

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: e233c410-3b39-4d86-aa5f-f81bb54f46a9

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: c2a9ed09-15d2-4077-9dde-53174ca53167

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
IMO 2012 Question 6 predicate: n is a solution if there exists a sequence a_1, ..., a_n of non-negative integers such that sum(1/2^a_i) = 1 and sum(i/3^a_i) = 1. Note that the problem uses 1-based indexing for the second sum, so we use (i + 1) since Fin n is 0-indexed.
-/
open BigOperators

def IMO2012Q6 (n : ℕ) : Prop :=
  ∃ a : Fin n → ℕ,
    (∑ i : Fin n, (1 : ℚ) / (2 ^ (a i) : ℚ)) = 1 ∧
    (∑ i : Fin n, ((i : ℚ) + 1) / (3 ^ (a i) : ℚ)) = 1

/-
n=1 and n=2 are solutions to IMO 2012 Q6. For n=1, take a_1=0. For n=2, take a_1=1, a_2=1.
-/
theorem IMO2012Q6_1 : IMO2012Q6 1 := by
  use (fun _ => 0)
  simp

theorem IMO2012Q6_2 : IMO2012Q6 2 := by
  use (fun _ => 1)
  simp
  norm_num

/-
n=3 is not a solution to IMO 2012 Q6.
-/
theorem not_IMO2012Q6_3 : ¬ IMO2012Q6 3 := by
  rintro ⟨ a, ha₁, ha₂ ⟩;
  rw [ Fin.sum_univ_three ] at *;
  -- Let's simplify the equations given the assumption that $a_0$, $a_1$, and $a_2$ are non-negative integers.
  field_simp at ha₁ ha₂;
  norm_cast at *;
  apply_fun fun x => x % 2 at ha₁ ha₂ ; norm_num [ Nat.add_mod, Nat.mul_mod, Nat.pow_mod ] at ha₁ ha₂

/-
Necessary condition for IMO 2012 Q6: If n is a solution, then n is congruent to 1 or 2 modulo 4.
Proof sketch:
From the second equation, sum (i+1)/3^{a_i} = 1.
Multiply by 3^K where K = max(a_i).
sum (i+1) * 3^{K-a_i} = 3^K.
Reduce modulo 2.
Since 3 = 1 mod 2, 3^x = 1 mod 2.
So sum (i+1) = 1 mod 2.
sum_{j=1}^n j = n(n+1)/2.
So n(n+1)/2 is odd.
This implies n = 1 or 2 mod 4.
-/
theorem IMO2012Q6_necessary (n : ℕ) (h : IMO2012Q6 n) : n % 4 = 1 ∨ n % 4 = 2 := by
  -- From the second equation, sum (i+1)/3^{a_i} = 1, we multiply by 3^K where K = max(a_i).
  obtain ⟨a, ha⟩ := h
  set K := Finset.univ.sup a with hK
  have h_sum_mod2 : (∑ i : (Fin n), ((i.val + 1) : ℕ) * 3 ^ (K - a i)) = 3 ^ K := by
    -- Multiply both sides of the equation by $3^K$.
    have h_mul : (∑ i : (Fin n), ((i.val + 1) : ℚ) * 3 ^ (K - a i)) = 3 ^ K := by
      convert congr_arg ( · * 3 ^ K ) ha.2 using 1 <;> norm_num [ Finset.sum_mul _ _ _ ];
      exact Finset.sum_congr rfl fun i _ => by rw [ div_mul_eq_mul_div, eq_div_iff ( by positivity ) ] ; rw [ mul_assoc, ← pow_add, Nat.sub_add_cancel ( Finset.le_sup ( f := a ) ( Finset.mem_univ i ) ) ] ;
    exact_mod_cast h_mul;
  -- Reduce modulo 2.
  have h_mod2 : (∑ i : (Fin n), ((i.val + 1) : ℕ)) % 2 = (3 ^ K) % 2 := by
    norm_num [ ← h_sum_mod2, Finset.sum_nat_mod, Nat.mul_mod, Nat.pow_mod ];
  -- Since $\sum_{i=1}^n (i+1) = \frac{n(n+1)}{2}$, we have $\frac{n(n+1)}{2} \equiv 1 \pmod{2}$.
  have h_sum_formula : (∑ i : Fin n, ((i.val + 1) : ℕ)) = n * (n + 1) / 2 := by
    convert Finset.sum_range_id ( n + 1 ) using 1 <;> simp +arith +decide [ mul_comm, Finset.sum_range, Fin.sum_univ_succ ];
  rw [ ← Nat.mod_add_div n 4 ] at *; norm_num [ Nat.add_mod, Nat.mul_mod, Nat.pow_mod, h_sum_formula ] at *; have := Nat.mod_lt n zero_lt_four; interval_cases n % 4 <;> norm_num at *;
  · norm_num [ mul_assoc, Nat.mul_div_assoc ] at h_mod2;
    omega;
  · grind

/-
n=5 and n=6 are solutions to IMO 2012 Q6.
For n=5, a = [2, 2, 2, 3, 3].
For n=6, a = [2, 2, 3, 3, 3, 3].
-/
theorem IMO2012Q6_5 : IMO2012Q6 5 := by
  -- Let's choose the sequence $a = [2, 2, 2, 3, 3]$.
  use ![2, 2, 2, 3, 3];
  native_decide +revert

theorem IMO2012Q6_6 : IMO2012Q6 6 := by
  -- Let's choose the sequence $a = [2, 2, 3, 3, 3, 3]$.
  use ![2, 2, 3, 3, 3, 3];
  native_decide +revert

/-
n=9 is a solution to IMO 2012 Q6.
-/
theorem IMO2012Q6_9 : IMO2012Q6 9 := by
  -- We need to find a sequence of length 9.
  -- Based on previous patterns, it likely involves 2s, 3s, 4s.
  -- Let's try to let the ATP find the coefficients.
  -- We can represent the sequence by the counts of each number.
  -- Let x be count of 2, y count of 3, z count of 4.
  -- x/4 + y/8 + z/16 = 1 => 4x + 2y + z = 16.
  -- x + y + z = 9.
  -- Subtract: 3x + y = 7.
  -- Possible (x, y): (0, 7) -> z=2. Seq: 3(7), 4(2). Sum2 = 101/81.
  -- (1, 4) -> z=4. Seq: 2(1), 3(4), 4(4).
  -- (2, 1) -> z=6. Seq: 2(2), 3(1), 4(6).
  -- Let's check these candidates.
  -- Candidate 1: 2(1), 3(4), 4(4).
  -- Permutations matter.
  -- We need sum (i+1)/3^{a_i} = 1.
  -- Let's try to find a permutation.
  use ![2, 3, 3, 3, 3, 4, 4, 4, 4] -- This is just one ordering
  -- We need to check if this or some permutation works.
  -- Actually, let's just ask the ATP to find the sequence.
  native_decide +revert

/-
Helper property for IMO 2012 Q6: For any n >= 1, there exists k < n and a permutation p of {k, n, n+1, n+2, n+3} such that 27*p_0 + 9*p_1 + 3*p_2 + p_3 + p_4 = 81*k + 40.
-/
def IMO2012Q6_helper_prop (n : ℕ) : Prop :=
  ∃ k < n, ∃ p : Fin 5 → ℕ,
    Function.Injective p ∧
    (∀ i, p i ∈ ({k, n, n+1, n+2, n+3} : Finset ℕ)) ∧
    (27 * p 0 + 9 * p 1 + 3 * p 2 + p 3 + p 4 = 81 * k + 40)

/-
Definition of the next sequence and proof that it satisfies the first condition (sum of 1/2^a_i = 1).
The sequence is constructed by replacing a_k with a_k+1, a_k+2, a_k+3, a_k+4, a_k+4.
Wait, the construction in `IMO2012Q6_next_seq` seems to assign fixed values based on indices $n, n+1, n+2, n+3$.
But the helper property uses a permutation $p$ of indices.
The exponents should be assigned to the indices $p_0, p_1, p_2, p_3, p_4$.
My previous construction was:
$a'_{p_0} = a_k+1$
$a'_{p_1} = a_k+2$
$a'_{p_2} = a_k+3$
$a'_{p_3} = a_k+4$
$a'_{p_4} = a_k+4$
And for $j \notin \{p_0, \dots, p_4\}$, $a'_j = a_j$ (with appropriate index mapping).
The indices involved are $k, n, n+1, n+2, n+3$.
The permutation $p$ maps $\{0, 1, 2, 3, 4\}$ to $\{k, n, n+1, n+2, n+3\}$.
So I should define the sequence such that:
If $i = p_0$, value is $a_k+1$.
If $i = p_1$, value is $a_k+2$.
If $i = p_2$, value is $a_k+3$.
If $i = p_3$, value is $a_k+4$.
If $i = p_4$, value is $a_k+4$.
If $i \notin \{p_0, \dots, p_4\}$, value is $a_i$ (if $i < n$) or undefined (but $i$ must be $< n$ since the new indices are $n, \dots, n+3$).
Wait, the new indices are $n, n+1, n+2, n+3$.
The set of indices for the new sequence is $Fin (n+4) = \{0, \dots, n+3\}$.
The set of indices modified/added is $\{k, n, n+1, n+2, n+3\}$.
For $j \in Fin (n+4) \setminus \{k, n, n+1, n+2, n+3\}$, we have $j < n$ and $j \neq k$, so $a'_j = a_j$.
So the definition should be:
Find $x \in Fin 5$ such that $p x = i$. If found, assign value based on $x$.
Else, $a'_i = a_i$.
This requires inverting $p$. Since $p$ is injective on a finite domain, it's invertible on its range.
I will redefine `IMO2012Q6_next_seq` to use this logic.
-/
def IMO2012Q6_next_seq (n : ℕ) (a : Fin n → ℕ) (k : Fin n) (p : Fin 5 → ℕ) : Fin (n + 4) → ℕ :=
  fun i =>
    if h : i.val < n then
      if i.val = k.val then a k + 1
      else a ⟨i.val, h⟩
    else
      if i.val - n = 0 then a k + 2
      else if i.val - n = 1 then a k + 3
      else if i.val - n = 2 then a k + 4
      else a k + 4

theorem IMO2012Q6_next_seq_sum1 (n : ℕ) (a : Fin n → ℕ) (k : Fin n) (p : Fin 5 → ℕ)
  (ha : ∑ i : Fin n, (1 : ℚ) / (2 ^ (a i) : ℚ) = 1) :
  ∑ i : Fin (n + 4), (1 : ℚ) / (2 ^ (IMO2012Q6_next_seq n a k p i) : ℚ) = 1 := by
    unfold IMO2012Q6_next_seq;
    norm_num [ Fin.sum_univ_add ] at *;
    norm_num [ Fin.sum_univ_succ ] at *;
    rw [ Finset.sum_eq_add_sum_diff_singleton ( Finset.mem_univ k ) ] at *;
    rw [ Finset.sum_congr rfl fun x hx => by rw [ if_neg ( by simpa [ Fin.ext_iff ] using hx ) ] ] ; norm_num [ pow_add ] at * ; linarith

/-
Lemma: The sum of 1/2^{a'_i} over the indices in p is equal to 1/2^{a_k}.
The values of a' at p_0, p_1, p_2, p_3, p_4 are a_k+1, a_k+2, a_k+3, a_k+4, a_k+4 respectively.
Sum = 1/2^{a_k+1} + 1/2^{a_k+2} + 1/2^{a_k+3} + 1/2^{a_k+4} + 1/2^{a_k+4}
    = 1/2^{a_k} * (1/2 + 1/4 + 1/8 + 1/16 + 1/16)
    = 1/2^{a_k} * (16/32 + 8/32 + 4/32 + 2/32 + 2/32)
    = 1/2^{a_k} * (32/32) = 1/2^{a_k}.
The ATP should be able to verify this calculation.
-/
def IMO2012Q6_next_seq_perm (n : ℕ) (a : Fin n → ℕ) (k : Fin n) (p : Fin 5 → ℕ) : Fin (n + 4) → ℕ :=
  fun i =>
    if i.val = p 0 then a k + 1
    else if i.val = p 1 then a k + 2
    else if i.val = p 2 then a k + 3
    else if i.val = p 3 then a k + 4
    else if i.val = p 4 then a k + 4
    else
      if h : i.val < n then a ⟨i.val, h⟩
      else 0

theorem IMO2012Q6_next_seq_perm_sum_subset (n : ℕ) (a : Fin n → ℕ) (k : Fin n) (p : Fin 5 → ℕ)
  (hp_inj : Function.Injective p)
  (hp_mem : ∀ i, p i ∈ ({(k : ℕ), n, n+1, n+2, n+3} : Finset ℕ)) :
  (1 : ℚ) / 2 ^ (IMO2012Q6_next_seq_perm n a k p ⟨p 0, by specialize hp_mem 0; simp at hp_mem; rcases hp_mem with h|h|h|h|h <;> linarith [k.isLt]⟩) +
  (1 : ℚ) / 2 ^ (IMO2012Q6_next_seq_perm n a k p ⟨p 1, by specialize hp_mem 1; simp at hp_mem; rcases hp_mem with h|h|h|h|h <;> linarith [k.isLt]⟩) +
  (1 : ℚ) / 2 ^ (IMO2012Q6_next_seq_perm n a k p ⟨p 2, by specialize hp_mem 2; simp at hp_mem; rcases hp_mem with h|h|h|h|h <;> linarith [k.isLt]⟩) +
  (1 : ℚ) / 2 ^ (IMO2012Q6_next_seq_perm n a k p ⟨p 3, by specialize hp_mem 3; simp at hp_mem; rcases hp_mem with h|h|h|h|h <;> linarith [k.isLt]⟩) +
  (1 : ℚ) / 2 ^ (IMO2012Q6_next_seq_perm n a k p ⟨p 4, by specialize hp_mem 4; simp at hp_mem; rcases hp_mem with h|h|h|h|h <;> linarith [k.isLt]⟩) =
  (1 : ℚ) / 2 ^ (a k) := by
    unfold IMO2012Q6_next_seq_perm;
    simp +decide [ hp_inj.eq_iff ];
    ring

/-
Proof of the first condition for the next sequence.
We split the sum over Fin (n+4) into the sum over the indices in p (which are k, n, n+1, n+2, n+3) and the rest.
The sum over the indices in p is 1/2^{a_k} by the lemma `IMO2012Q6_next_seq_perm_sum_subset`.
The sum over the rest corresponds to the sum over Fin n excluding k.
The total sum is thus the sum over Fin n excluding k plus 1/2^{a_k}, which is the sum over Fin n, which is 1.
The ATP needs to handle the set equality and the sum splitting.
-/
theorem IMO2012Q6_next_seq_perm_sum1 (n : ℕ) (a : Fin n → ℕ) (k : Fin n) (p : Fin 5 → ℕ)
  (hp_inj : Function.Injective p)
  (hp_mem : ∀ i, p i ∈ ({(k : ℕ), n, n+1, n+2, n+3} : Finset ℕ))
  (ha : ∑ i : Fin n, (1 : ℚ) / (2 ^ (a i) : ℚ) = 1) :
  ∑ i : Fin (n + 4), (1 : ℚ) / (2 ^ (IMO2012Q6_next_seq_perm n a k p i) : ℚ) = 1 := by
    -- Split the sum over Fin (n+4) into the sum over the image of p and the complement.
    let S := Finset.image p Finset.univ
    have hS_card : S.card = 5 := by
      rw [Finset.card_image_of_injective _ hp_inj]; simp
    have hS_subset : S ⊆ {k.val, n, n+1, n+2, n+3} := by
      intro x hx; rcases Finset.mem_image.mp hx with ⟨y, _, rfl⟩; apply hp_mem
    have hS_eq : S = {k.val, n, n+1, n+2, n+3} := by
      refine Finset.eq_of_subset_of_card_le hS_subset ?_
      simp [hS_card];
      -- We need to know that k, n, n+1, n+2, n+3 are distinct.
      -- This requires n > k, which is true since k : Fin n.
      -- Also need n >= 1? Yes, implicit in k : Fin n.
      exact Finset.card_insert_le _ _ |> le_trans <| add_le_add_right ( Finset.card_insert_le _ _ |> le_trans <| add_le_add_right ( Finset.card_insert_le _ _ |> le_trans <| add_le_add_right ( Finset.card_insert_le _ _ ) _ ) _ ) _
    -- The sum over S is 1/2^{a_k} by the previous lemma.
    -- The sum over the complement is sum_{j != k} 1/2^{a_j}.
    -- Total sum is sum_{j != k} 1/2^{a_j} + 1/2^{a_k} = 1.
    have h_sum_S : (∑ i ∈ Finset.filter (fun i => i.val ∈ S) (Finset.univ : Finset (Fin (n + 4))), (1 : ℚ) / (2 ^ (IMO2012Q6_next_seq_perm n a k p i) : ℚ)) = (1 : ℚ) / (2 ^ (a k) : ℚ) := by
      have h_sum_S : (∑ i ∈ Finset.image (fun i : Fin 5 => ⟨p i, by
        grind⟩ : Fin 5 → Fin (n + 4)) Finset.univ, (1 : ℚ) / (2 ^ (IMO2012Q6_next_seq_perm n a k p i) : ℚ)) = (1 : ℚ) / (2 ^ (a k) : ℚ) := by
        rw [ Finset.sum_image ] <;> norm_num [ hp_inj.eq_iff ];
        have := IMO2012Q6_next_seq_perm_sum_subset n a k p hp_inj hp_mem; norm_num [ Fin.sum_univ_five ] at * ; aesop;
      convert h_sum_S using 2;
      ext ⟨ i, hi ⟩ ; simp +decide [ Finset.mem_image, Finset.mem_filter ] ;
      exact ⟨ fun hi => Finset.mem_image.mp hi |> Exists.imp fun x hx => hx.2, fun ⟨ x, hx ⟩ => hx ▸ Finset.mem_image_of_mem _ ( Finset.mem_univ _ ) ⟩;
    have h_sum_not_S : (∑ i ∈ Finset.univ \ Finset.filter (fun i => i.val ∈ S) (Finset.univ : Finset (Fin (n + 4))), (1 : ℚ) / (2 ^ (IMO2012Q6_next_seq_perm n a k p i) : ℚ)) = (∑ i ∈ Finset.univ \ {k}, (1 : ℚ) / (2 ^ (a i) : ℚ)) := by
      apply Finset.sum_bij (fun i hi => ⟨i.val, by
        grind⟩);
      · grind;
      · simp +contextual [ Fin.ext_iff ];
      · intro b hb; use ⟨ b, by linarith [ Fin.is_lt b ] ⟩ ; simp_all +decide [ Fin.ext_iff ] ;
        grind;
      · intro i hi; unfold IMO2012Q6_next_seq_perm; simp_all +decide [ Finset.mem_sdiff, Finset.mem_filter ] ;
        grind;
    simp_all +decide [ Finset.sum_sub_distrib, Finset.sum_singleton ]

/-
Lemma: The weighted sum over the indices in p is equal to (k+1)/3^{a_k}.
The values of a' at p_0, p_1, p_2, p_3, p_4 are a_k+1, a_k+2, a_k+3, a_k+4, a_k+4 respectively.
Sum = (p_0+1)/3^{a_k+1} + (p_1+1)/3^{a_k+2} + (p_2+1)/3^{a_k+3} + (p_3+1)/3^{a_k+4} + (p_4+1)/3^{a_k+4}
    = 1/3^{a_k+4} * (27(p_0+1) + 9(p_1+1) + 3(p_2+1) + (p_3+1) + (p_4+1))
    = 1/3^{a_k+4} * (27p_0 + 27 + 9p_1 + 9 + 3p_2 + 3 + p_3 + 1 + p_4 + 1)
    = 1/3^{a_k+4} * (27p_0 + 9p_1 + 3p_2 + p_3 + p_4 + 41)
    = 1/3^{a_k+4} * (81k + 40 + 41)
    = 1/3^{a_k+4} * (81k + 81)
    = 1/3^{a_k+4} * 81(k+1)
    = 1/3^{a_k+4} * 3^4(k+1)
    = (k+1)/3^{a_k}.
The ATP should be able to verify this calculation using the helper equation `hp_eq`.
-/
theorem IMO2012Q6_next_seq_perm_sum2_subset (n : ℕ) (a : Fin n → ℕ) (k : Fin n) (p : Fin 5 → ℕ)
  (hp_inj : Function.Injective p)
  (hp_mem : ∀ i, p i ∈ ({(k : ℕ), n, n+1, n+2, n+3} : Finset ℕ))
  (hp_eq : 27 * p 0 + 9 * p 1 + 3 * p 2 + p 3 + p 4 = 81 * k + 40) :
  ((p 0 : ℚ) + 1) / 3 ^ (IMO2012Q6_next_seq_perm n a k p ⟨p 0, by specialize hp_mem 0; simp at hp_mem; rcases hp_mem with h|h|h|h|h <;> linarith [k.isLt]⟩) +
  ((p 1 : ℚ) + 1) / 3 ^ (IMO2012Q6_next_seq_perm n a k p ⟨p 1, by specialize hp_mem 1; simp at hp_mem; rcases hp_mem with h|h|h|h|h <;> linarith [k.isLt]⟩) +
  ((p 2 : ℚ) + 1) / 3 ^ (IMO2012Q6_next_seq_perm n a k p ⟨p 2, by specialize hp_mem 2; simp at hp_mem; rcases hp_mem with h|h|h|h|h <;> linarith [k.isLt]⟩) +
  ((p 3 : ℚ) + 1) / 3 ^ (IMO2012Q6_next_seq_perm n a k p ⟨p 3, by specialize hp_mem 3; simp at hp_mem; rcases hp_mem with h|h|h|h|h <;> linarith [k.isLt]⟩) +
  ((p 4 : ℚ) + 1) / 3 ^ (IMO2012Q6_next_seq_perm n a k p ⟨p 4, by specialize hp_mem 4; simp at hp_mem; rcases hp_mem with h|h|h|h|h <;> linarith [k.isLt]⟩) =
  ((k : ℚ) + 1) / 3 ^ (a k) := by
    norm_num [ IMO2012Q6_next_seq_perm ];
    simp +decide [ hp_inj.eq_iff, pow_add ];
    field_simp;
    norm_cast; linarith;

/-
Lemma: The sum over the complement of the permuted indices equals the sum over the original indices excluding k.
The set of permuted indices S is {k, n, n+1, n+2, n+3}.
The complement in Fin (n+4) is {0, ..., n-1} \ {k}.
For these indices, the sequence a' is defined as a'_i = a_i.
The term (i+1)/3^{a'_i} is thus (i+1)/3^{a_i}.
The sum is therefore the same.
The ATP should be able to handle the set logic and the definition of the sequence.
-/
theorem IMO2012Q6_next_seq_perm_sum_complement (n : ℕ) (a : Fin n → ℕ) (k : Fin n) (p : Fin 5 → ℕ)
  (hp_inj : Function.Injective p)
  (hp_mem : ∀ i, p i ∈ ({(k : ℕ), n, n+1, n+2, n+3} : Finset ℕ)) :
  let S := Finset.image p Finset.univ
  ∑ i ∈ Finset.univ.filter (fun x : Fin (n + 4) => x.val ∉ S), ((i : ℚ) + 1) / (3 ^ (IMO2012Q6_next_seq_perm n a k p i) : ℚ) =
  ∑ i ∈ Finset.univ.erase k, ((i : ℚ) + 1) / (3 ^ (a i) : ℚ) := by
    -- The complement of S in Fin (n + 4) is {0, ..., n-1} \ {k}.
    set S : Finset ℕ := Finset.image p Finset.univ
    have h_compl : Finset.filter (fun i : Fin (n + 4) => (i.val ∉ S)) Finset.univ = Finset.image (fun i : Fin n => ⟨i.val, by linarith [Fin.is_lt i]⟩) (Finset.univ.erase k) := by
      ext ⟨i, hi⟩; simp [S, hp_mem];
      constructor <;> intro h <;> contrapose! h <;> simp_all +decide [ Fin.ext_iff ];
      · by_cases hi' : i = k.val ∨ i = n ∨ i = n + 1 ∨ i = n + 2 ∨ i = n + 3;
        · have := Finset.eq_of_subset_of_card_le ( show Finset.image p Finset.univ ⊆ { ( k : ℕ ), n, n + 1, n + 2, n + 3 } from Finset.image_subset_iff.mpr fun i _ => by simpa using hp_mem i ) ; simp_all +decide [ Finset.card_image_of_injective _ hp_inj ] ;
          specialize this ( by exact le_trans ( Finset.card_insert_le _ _ ) ( by linarith [ Finset.card_insert_le ( n : ℕ ) { n + 1, n + 2, n + 3 }, Finset.card_insert_le ( n + 1 : ℕ ) { n + 2, n + 3 }, Finset.card_insert_le ( n + 2 : ℕ ) { n + 3 }, Finset.card_singleton ( n + 3 : ℕ ) ] ) ) ; replace this := Finset.ext_iff.mp this i ; aesop;
        · exact False.elim <| h ⟨ i, by omega ⟩ ( by aesop ) rfl;
      · grind;
    simp_all +decide [ Finset.sum_image, Function.Injective ];
    rw [ Finset.sum_image ];
    · rw [ ← Finset.sum_erase_add _ _ ( Finset.mem_univ k ), add_tsub_cancel_right ];
      refine' Finset.sum_congr rfl fun x hx => _;
      rw [ IMO2012Q6_next_seq_perm ];
      replace h_compl := Finset.ext_iff.mp h_compl ⟨ x, by linarith [ Fin.is_lt x ] ⟩ ; simp_all +decide [ Finset.mem_image ] ;
      grind;
    · exact fun i hi j hj hij => by simpa [ Fin.ext_iff ] using hij;;

/-
Proof of the second condition for the next sequence.
We split the sum over Fin (n+4) into the sum over the indices in p (which are k, n, n+1, n+2, n+3) and the rest.
The sum over the indices in p is shown to be equal to (k+1)/3^{a_k} using the helper equation.
The sum over the rest is 1 - (k+1)/3^{a_k}.
Thus the total sum is 1.
The ATP should be able to handle the algebraic manipulation and sum splitting.
-/
theorem IMO2012Q6_next_seq_perm_sum2 (n : ℕ) (a : Fin n → ℕ) (k : Fin n) (p : Fin 5 → ℕ)
  (hp_inj : Function.Injective p)
  (hp_mem : ∀ i, p i ∈ ({(k : ℕ), n, n+1, n+2, n+3} : Finset ℕ))
  (hp_eq : 27 * p 0 + 9 * p 1 + 3 * p 2 + p 3 + p 4 = 81 * k + 40)
  (ha : ∑ i : Fin n, ((i : ℚ) + 1) / (3 ^ (a i) : ℚ) = 1) :
  ∑ i : Fin (n + 4), ((i : ℚ) + 1) / (3 ^ (IMO2012Q6_next_seq_perm n a k p i) : ℚ) = 1 := by
    have h_split : ∑ i : Fin (n + 4), ((i : ℚ) + 1) / (3 ^ (IMO2012Q6_next_seq_perm n a k p i) : ℚ) =
      (∑ i ∈ Finset.univ.filter (fun x : Fin (n + 4) => x.val ∈ Finset.image p Finset.univ), ((i : ℚ) + 1) / (3 ^ (IMO2012Q6_next_seq_perm n a k p i) : ℚ)) +
      (∑ i ∈ Finset.univ.filter (fun x : Fin (n + 4) => x.val ∉ Finset.image p Finset.univ), ((i : ℚ) + 1) / (3 ^ (IMO2012Q6_next_seq_perm n a k p i) : ℚ)) := by
        rw [ Finset.sum_filter_add_sum_filter_not ];
    have h_sum_perm : ∑ i ∈ Finset.univ.filter (fun x : Fin (n + 4) => x.val ∈ Finset.image p Finset.univ), ((i : ℚ) + 1) / (3 ^ (IMO2012Q6_next_seq_perm n a k p i) : ℚ) =
      ((k : ℚ) + 1) / (3 ^ (a k) : ℚ) := by
        have h_sum_perm : ∑ x ∈ Finset.univ.image p, ((x : ℚ) + 1) / (3 ^ (if x = p 0 then a k + 1 else if x = p 1 then a k + 2 else if x = p 2 then a k + 3 else if x = p 3 then a k + 4 else a k + 4) : ℚ) =
          ((k : ℚ) + 1) / (3 ^ (a k) : ℚ) := by
            rw [ Finset.sum_image <| by simpa [ hp_inj.eq_iff ] ];
            convert IMO2012Q6_next_seq_perm_sum2_subset n a k p hp_inj ( fun i => by simpa using hp_mem i ) ( by linarith ) using 1;
            simp +decide [ Fin.sum_univ_five ];
            simp +decide [ IMO2012Q6_next_seq_perm, hp_inj.eq_iff ];
        rw [ ← h_sum_perm, Finset.sum_filter ];
        rw [ ← Finset.sum_filter ];
        refine' Finset.sum_bij ( fun x hx => x ) _ _ _ _ <;> simp +decide [ hp_inj.eq_iff ];
        · exact fun a₁ x hx a₂ y hy h => Fin.ext h;
        · intro i; use ⟨ p i, by specialize hp_mem i; simp at hp_mem; rcases hp_mem with h|h|h|h|h <;> linarith [ k.2 ] ⟩ ; aesop;
        · intro i x hx; unfold IMO2012Q6_next_seq_perm; simp +decide [ hx.symm ] ;
          fin_cases x <;> simp +decide [ hp_inj.eq_iff ];
    have h_sum_complement : ∑ i ∈ Finset.univ.filter (fun x : Fin (n + 4) => x.val ∉ Finset.image p Finset.univ), ((i : ℚ) + 1) / (3 ^ (IMO2012Q6_next_seq_perm n a k p i) : ℚ) =
      ∑ i ∈ Finset.univ.erase k, ((i : ℚ) + 1) / (3 ^ (a i) : ℚ) := by
        convert IMO2012Q6_next_seq_perm_sum_complement n a k p hp_inj hp_mem using 1;
    simp_all +decide [ Finset.sum_erase ]

/-
Lemma: The filtered set of indices in Fin (n+4) is equal to the image of p cast to Fin (n+4).
The set of indices in Fin (n+4) whose values are in the image of p is exactly the set of values of p, viewed as elements of Fin (n+4).
This is true because all values in the image of p are less than n+4 (since they are in {k, n, n+1, n+2, n+3} and k < n).
The ATP should be able to prove this set equality.
-/
theorem IMO2012Q6_filter_eq_image (n : ℕ) (k : Fin n) (p : Fin 5 → ℕ)
  (hp_mem : ∀ i, p i ∈ ({(k : ℕ), n, n+1, n+2, n+3} : Finset ℕ)) :
  Finset.filter (fun i : Fin (n + 4) => (i : ℕ) ∈ Finset.image p Finset.univ) Finset.univ =
  Finset.image (fun i : Fin 5 => ⟨p i, by specialize hp_mem i; simp at hp_mem; rcases hp_mem with h|h|h|h|h <;> linarith [k.isLt]⟩) Finset.univ := by
    aesop

/-
Proof of the second condition for the next sequence (retry).
We split the sum into the filter and complement parts.
The complement part is handled by `IMO2012Q6_next_seq_perm_sum_complement`.
The filter part is rewritten using `IMO2012Q6_filter_eq_image` to be a sum over an image.
Then we use `Finset.sum_image` to pull it back to a sum over `Fin 5`.
This sum matches the one in `IMO2012Q6_next_seq_perm_sum2_subset` (after expanding with `Fin.sum_univ_five`).
Finally, we combine everything and use `ha` to conclude the result.
-/
theorem IMO2012Q6_next_seq_perm_sum2_proof (n : ℕ) (a : Fin n → ℕ) (k : Fin n) (p : Fin 5 → ℕ)
  (hp_inj : Function.Injective p)
  (hp_mem : ∀ i, p i ∈ ({(k : ℕ), n, n+1, n+2, n+3} : Finset ℕ))
  (hp_eq : 27 * p 0 + 9 * p 1 + 3 * p 2 + p 3 + p 4 = 81 * k + 40)
  (ha : ∑ i : Fin n, ((i : ℚ) + 1) / (3 ^ (a i) : ℚ) = 1) :
  ∑ i : Fin (n + 4), ((i : ℚ) + 1) / (3 ^ (IMO2012Q6_next_seq_perm n a k p i) : ℚ) = 1 := by
    convert IMO2012Q6_next_seq_perm_sum2 n a k p hp_inj hp_mem hp_eq ha using 1

/-
Lemma: The sum over the image of p corresponds to the sum over Fin 5.
We use `Finset.sum_image` to transform the sum over the image to a sum over `Fin 5`.
Since `p` is injective, the mapping is a bijection.
The sum over `Fin 5` can then be expanded using `Fin.sum_univ_five`.
The ATP should be able to handle the injectivity and the expansion.
-/
theorem IMO2012Q6_sum_image_eq_sum_fin5 (n : ℕ) (a : Fin n → ℕ) (k : Fin n) (p : Fin 5 → ℕ)
  (hp_inj : Function.Injective p)
  (hp_mem : ∀ i, p i ∈ ({(k : ℕ), n, n+1, n+2, n+3} : Finset ℕ)) :
  ∑ i ∈ Finset.image (fun i : Fin 5 => (⟨p i, by specialize hp_mem i; simp at hp_mem; rcases hp_mem with h|h|h|h|h <;> linarith [k.isLt]⟩ : Fin (n + 4))) Finset.univ, ((i : ℚ) + 1) / (3 ^ (IMO2012Q6_next_seq_perm n a k p i) : ℚ) =
  ((p 0 : ℚ) + 1) / 3 ^ (IMO2012Q6_next_seq_perm n a k p ⟨p 0, by specialize hp_mem 0; simp at hp_mem; rcases hp_mem with h|h|h|h|h <;> linarith [k.isLt]⟩) +
  ((p 1 : ℚ) + 1) / 3 ^ (IMO2012Q6_next_seq_perm n a k p ⟨p 1, by specialize hp_mem 1; simp at hp_mem; rcases hp_mem with h|h|h|h|h <;> linarith [k.isLt]⟩) +
  ((p 2 : ℚ) + 1) / 3 ^ (IMO2012Q6_next_seq_perm n a k p ⟨p 2, by specialize hp_mem 2; simp at hp_mem; rcases hp_mem with h|h|h|h|h <;> linarith [k.isLt]⟩) +
  ((p 3 : ℚ) + 1) / 3 ^ (IMO2012Q6_next_seq_perm n a k p ⟨p 3, by specialize hp_mem 3; simp at hp_mem; rcases hp_mem with h|h|h|h|h <;> linarith [k.isLt]⟩) +
  ((p 4 : ℚ) + 1) / 3 ^ (IMO2012Q6_next_seq_perm n a k p ⟨p 4, by specialize hp_mem 4; simp at hp_mem; rcases hp_mem with h|h|h|h|h <;> linarith [k.isLt]⟩) := by
    rw [ Finset.sum_image ] <;> simp +decide [ Fin.sum_univ_five, hp_inj.eq_iff ]

/-
Proof of the second condition for the next sequence (final attempt with new name).
We split the sum into the filter and complement parts.
The complement part is handled by `IMO2012Q6_next_seq_perm_sum_complement`.
The filter part is rewritten using `IMO2012Q6_filter_eq_image`, `IMO2012Q6_sum_image_eq_sum_fin5`, and `IMO2012Q6_next_seq_perm_sum2_subset`.
Finally, we combine everything and use `ha` to conclude the result.
-/
theorem IMO2012Q6_next_seq_perm_sum2_final (n : ℕ) (a : Fin n → ℕ) (k : Fin n) (p : Fin 5 → ℕ)
  (hp_inj : Function.Injective p)
  (hp_mem : ∀ i, p i ∈ ({(k : ℕ), n, n+1, n+2, n+3} : Finset ℕ))
  (hp_eq : 27 * p 0 + 9 * p 1 + 3 * p 2 + p 3 + p 4 = 81 * k + 40)
  (ha : ∑ i : Fin n, ((i : ℚ) + 1) / (3 ^ (a i) : ℚ) = 1) :
  ∑ i : Fin (n + 4), ((i : ℚ) + 1) / (3 ^ (IMO2012Q6_next_seq_perm n a k p i) : ℚ) = 1 := by
    convert IMO2012Q6_next_seq_perm_sum2 n a k p hp_inj hp_mem hp_eq ha using 1

/-
Proof of the second condition for the next sequence (final attempt with new name).
We split the sum into the filter and complement parts.
The complement part is handled by `IMO2012Q6_next_seq_perm_sum_complement`.
The filter part is rewritten using `IMO2012Q6_filter_eq_image`, `IMO2012Q6_sum_image_eq_sum_fin5`, and `IMO2012Q6_next_seq_perm_sum2_subset`.
Finally, we combine everything and use `ha` to conclude the result.
-/
theorem IMO2012Q6_next_seq_perm_sum2_final_v2 (n : ℕ) (a : Fin n → ℕ) (k : Fin n) (p : Fin 5 → ℕ)
  (hp_inj : Function.Injective p)
  (hp_mem : ∀ i, p i ∈ ({(k : ℕ), n, n+1, n+2, n+3} : Finset ℕ))
  (hp_eq : 27 * p 0 + 9 * p 1 + 3 * p 2 + p 3 + p 4 = 81 * k + 40)
  (ha : ∑ i : Fin n, ((i : ℚ) + 1) / (3 ^ (a i) : ℚ) = 1) :
  ∑ i : Fin (n + 4), ((i : ℚ) + 1) / (3 ^ (IMO2012Q6_next_seq_perm n a k p i) : ℚ) = 1 := by
    convert IMO2012Q6_next_seq_perm_sum2_final n a k p hp_inj hp_mem hp_eq ha using 1

/-
Proof of the second condition for the next sequence (final attempt with new name v3).
We split the sum into the filter and complement parts.
The complement part is handled by `IMO2012Q6_next_seq_perm_sum_complement`.
The filter part is rewritten using `IMO2012Q6_filter_eq_image`, `IMO2012Q6_sum_image_eq_sum_fin5`, and `IMO2012Q6_next_seq_perm_sum2_subset`.
Finally, we combine everything and use `ha` to conclude the result.
-/
theorem IMO2012Q6_next_seq_perm_sum2_final_v3 (n : ℕ) (a : Fin n → ℕ) (k : Fin n) (p : Fin 5 → ℕ)
  (hp_inj : Function.Injective p)
  (hp_mem : ∀ i, p i ∈ ({(k : ℕ), n, n+1, n+2, n+3} : Finset ℕ))
  (hp_eq : 27 * p 0 + 9 * p 1 + 3 * p 2 + p 3 + p 4 = 81 * k + 40)
  (ha : ∑ i : Fin n, ((i : ℚ) + 1) / (3 ^ (a i) : ℚ) = 1) :
  ∑ i : Fin (n + 4), ((i : ℚ) + 1) / (3 ^ (IMO2012Q6_next_seq_perm n a k p i) : ℚ) = 1 := by
    convert IMO2012Q6_next_seq_perm_sum2_final_v2 n a k p hp_inj hp_mem hp_eq ha using 1

/-
Recurrence step: If n is a solution and the helper property holds for n, then n+4 is a solution.
We use the helper property to find k and p.
We construct the new sequence using `IMO2012Q6_next_seq_perm`.
We apply the two sum lemmas to show that the new sequence satisfies the conditions.
The first condition is satisfied by `IMO2012Q6_next_seq_perm_sum1`.
The second condition is satisfied by `IMO2012Q6_next_seq_perm_sum2_final_v3`.
This completes the proof of the recurrence step.
-/
theorem IMO2012Q6_recurrence_step (n : ℕ) (h : IMO2012Q6 n) (h_helper : IMO2012Q6_helper_prop n) : IMO2012Q6 (n + 4) := by
  obtain ⟨a, ha1, ha2⟩ := h
  obtain ⟨k, hk, p, hp_inj, hp_mem, hp_eq⟩ := h_helper
  use IMO2012Q6_next_seq_perm n a ⟨k, hk⟩ p
  constructor
  · apply IMO2012Q6_next_seq_perm_sum1 n a ⟨k, hk⟩ p hp_inj
    · intro i; specialize hp_mem i; simp at hp_mem; simp [hp_mem]
    · exact ha1
  · apply IMO2012Q6_next_seq_perm_sum2_final_v3 n a ⟨k, hk⟩ p hp_inj
    · intro i; specialize hp_mem i; simp at hp_mem; simp [hp_mem]
    · exact hp_eq
    · exact ha2

/-
Coefficients for the linear combination.
-/
def IMO2012Q6_coeffs : Fin 5 → ℕ := ![27, 9, 3, 1, 1]

/-
Modulus for the covering argument.
-/
def IMO2012Q6_modulus (j : Fin 5) : ℕ :=
  (41 - IMO2012Q6_coeffs j) + 40

/-
Possible values of K for the covering argument.
-/
def IMO2012Q6_K_values (j : Fin 5) : Finset ℕ :=
  let c_list : List ℕ := (List.finRange 5).filter (· ≠ j) |>.map IMO2012Q6_coeffs
  let perms : List (List ℕ) := [[0,1,2,3], [0,1,3,2], [0,2,1,3], [0,2,3,1], [0,3,1,2], [0,3,2,1],
                                [1,0,2,3], [1,0,3,2], [1,2,0,3], [1,2,3,0], [1,3,0,2], [1,3,2,0],
                                [2,0,1,3], [2,0,3,1], [2,1,0,3], [2,1,3,0], [2,3,0,1], [2,3,1,0],
                                [3,0,1,2], [3,0,2,1], [3,1,0,2], [3,1,2,0], [3,2,0,1], [3,2,1,0]]
  perms.foldr (fun p acc => insert (List.zipWith (· * ·) c_list p).sum acc) ∅

/-
Check function for the covering argument.
-/
def IMO2012Q6_check_n (n : ℕ) : Prop :=
  ∃ j : Fin 5,
    let M := IMO2012Q6_modulus j
    let S := 41 - IMO2012Q6_coeffs j
    ∃ K ∈ IMO2012Q6_K_values j,
      K % M = (40 * n + 40) % M ∧
      40 * n + 40 ≥ K ∧
      S * n + K > 40

/-
Boolean check function.
-/
def IMO2012Q6_check_n_bool (n : ℕ) : Bool :=
  (List.finRange 5).any fun j =>
    let M := IMO2012Q6_modulus j
    let S := 41 - IMO2012Q6_coeffs j
    let rhs := (40 * n + 40) % M
    (IMO2012Q6_K_values j).toList.any fun K =>
      K % M == rhs && K < 40 * n + 40 && S * n + K >= 40

/-
Corrected check function.
-/
def IMO2012Q6_check_n_prop (n : ℕ) : Prop :=
  ∃ j : Fin 5,
    let M := IMO2012Q6_modulus j
    let S := 41 - IMO2012Q6_coeffs j
    ∃ K ∈ IMO2012Q6_K_values j,
      K % M = (40 * n + 40) % M ∧
      K < 40 * n + 40 ∧
      S * n + K ≥ 40

/-
Equivalence of boolean and corrected propositional check functions.
-/
theorem IMO2012Q6_check_n_iff_corrected (n : ℕ) : IMO2012Q6_check_n_bool n = true ↔ IMO2012Q6_check_n_prop n := by
  unfold IMO2012Q6_check_n_bool IMO2012Q6_check_n_prop; aesop;

/-
Structure of K values.
-/
theorem IMO2012Q6_K_structure (j : Fin 5) (K : ℕ) (hK : K ∈ IMO2012Q6_K_values j) :
  ∃ δ : Fin 4 → Fin 4, Function.Bijective δ ∧ K = ∑ i : Fin 4, IMO2012Q6_coeffs (j.succAbove i) * (δ i : ℕ) := by
    native_decide +revert

/-
Checking Fin.predAbove.
-/
#check Fin.predAbove

/-
Checking Fin.succAbove.
-/
#check Fin.succAbove

/-
Construction of the permutation p.
-/
def IMO2012Q6_construct_p (n : ℕ) (j : Fin 5) (k : ℕ) (δ : Fin 4 → Fin 4) (i : Fin 5) : ℕ :=
  if h : i = j then k
  else
    let i' : Fin 4 :=
      if h_lt : i < j then
        ⟨i.val, by
          exact Nat.lt_of_lt_of_le h_lt ( Fin.le_last _ )⟩
      else
        ⟨i.val - 1, by
          fin_cases i <;> simp +decide at h_lt ⊢⟩
    n + (δ i' : ℕ)

/-
Range of the constructed permutation.
-/
theorem IMO2012Q6_construct_p_range (n : ℕ) (j : Fin 5) (k : ℕ) (δ : Fin 4 → Fin 4) (i : Fin 5) :
  IMO2012Q6_construct_p n j k δ i ∈ ({k, n, n+1, n+2, n+3} : Finset ℕ) := by
    unfold IMO2012Q6_construct_p;
    grind

/-
Sum property of the constructed permutation.
-/
theorem IMO2012Q6_construct_p_sum (n : ℕ) (j : Fin 5) (k : ℕ) (δ : Fin 4 → Fin 4)
  (h_bij : Function.Bijective δ)
  (K : ℕ)
  (hK_eq : K = ∑ i : Fin 4, IMO2012Q6_coeffs (j.succAbove i) * (δ i : ℕ))
  (h_eqn : (41 - IMO2012Q6_coeffs j) * n + K = ((41 - IMO2012Q6_coeffs j) + 40) * k + 40) :
  ∑ i : Fin 5, IMO2012Q6_coeffs i * IMO2012Q6_construct_p n j k δ i = 81 * k + 40 := by
    convert congr_arg ( fun x : ℕ => x + IMO2012Q6_coeffs j * k ) h_eqn using 1;
    · fin_cases j <;> simp +decide [ *, Fin.sum_univ_succ ] <;> ring!;
      · simp +decide [ IMO2012Q6_coeffs, IMO2012Q6_construct_p ] ; ring!;
      · unfold IMO2012Q6_coeffs IMO2012Q6_construct_p; simp +decide [ Fin.sum_univ_succ ] ; ring;
      · simp +decide [ IMO2012Q6_coeffs, IMO2012Q6_construct_p ] ; ring!;
      · simp +decide [ IMO2012Q6_coeffs, IMO2012Q6_construct_p ] ; ring!;
      · simp +decide [ IMO2012Q6_coeffs, IMO2012Q6_construct_p ] ; ring!;
    · fin_cases j <;> simp +decide [ IMO2012Q6_coeffs ] <;> ring

/-
Injectivity of the constructed permutation.
-/
theorem IMO2012Q6_construct_p_injective (n : ℕ) (j : Fin 5) (k : ℕ) (δ : Fin 4 → Fin 4)
  (h_bij : Function.Bijective δ)
  (hk_lt : k < n) :
  Function.Injective (IMO2012Q6_construct_p n j k δ) := by
    intro x y hxy;
    by_cases hx : x = j <;> by_cases hy : y = j <;> simp_all +decide [ IMO2012Q6_construct_p ];
    · linarith;
    · native_decide +revert

/-
Lower bound for the constructed permutation at non-j indices.
-/
theorem IMO2012Q6_construct_p_ge_n (n : ℕ) (j : Fin 5) (k : ℕ) (δ : Fin 4 → Fin 4) (i : Fin 5) (h : i ≠ j) :
  IMO2012Q6_construct_p n j k δ i ≥ n := by
    unfold IMO2012Q6_construct_p; aesop;

/-
Existence and properties of k.
-/
theorem IMO2012Q6_k_properties (n : ℕ) (j : Fin 5) (K : ℕ)
  (h_mod : K % IMO2012Q6_modulus j = (40 * n + 40) % IMO2012Q6_modulus j)
  (h_bound1 : K < 40 * n + 40)
  (h_bound2 : (41 - IMO2012Q6_coeffs j) * n + K ≥ 40) :
  ∃ k : ℕ,
    (41 - IMO2012Q6_coeffs j) * n + K = IMO2012Q6_modulus j * k + 40 ∧
    k < n := by
      obtain ⟨k, hk⟩ : ∃ k, (41 - IMO2012Q6_coeffs j) * n + K = IMO2012Q6_modulus j * k + 40 := by
        have h_div : (41 - IMO2012Q6_coeffs j) * n + K - 40 ≡ 0 [MOD IMO2012Q6_modulus j] := by
          simp_all +decide [ ← ZMod.natCast_eq_natCast_iff', Nat.cast_sub h_bound2 ];
          simp_all +decide [ ← ZMod.natCast_eq_natCast_iff, IMO2012Q6_modulus ];
          fin_cases j <;> simp +decide [ IMO2012Q6_coeffs ] <;> ring;
          · exact?;
          · exact?;
          · erw [ show ( 78 : ZMod 78 ) = 0 by rfl ] ; norm_num;
          · erw [ show ( 80 : ZMod 80 ) = 0 by rfl ] ; norm_num;
          · exact?;
        exact ⟨ ( ( 41 - IMO2012Q6_coeffs j ) * n + K - 40 ) / IMO2012Q6_modulus j, by rw [ Nat.mul_div_cancel' ( Nat.dvd_of_mod_eq_zero h_div ), Nat.sub_add_cancel h_bound2 ] ⟩;
      refine' ⟨ k, hk, _ ⟩;
      fin_cases j <;> simp +decide [ IMO2012Q6_modulus, IMO2012Q6_coeffs ] at * <;> linarith!

/-
The check property implies the helper property.
-/
theorem IMO2012Q6_check_implies_helper (n : ℕ) (h : IMO2012Q6_check_n_prop n) : IMO2012Q6_helper_prop n := by
  obtain ⟨ j, K, h_mem, h_mod, h_bound1, h_bound2 ⟩ := h;
  -- Use `IMO2012Q6_k_properties` to find `k` such that `(41 - c_j) * n + K = M * k + 40` and `k < n`.
  obtain ⟨ k, hk_eq, hk_lt ⟩ := IMO2012Q6_k_properties n j K h_mod h_bound1 h_bound2;
  -- Use `IMO2012Q6_K_structure` to find `δ` such that `K` is the weighted sum.
  obtain ⟨ δ, hδ_bij, hδ_eq ⟩ := IMO2012Q6_K_structure j K h_mem;
  use k, hk_lt, fun i => IMO2012Q6_construct_p n j k δ i;
  refine' ⟨ _, _, _ ⟩;
  · exact IMO2012Q6_construct_p_injective n j k δ hδ_bij hk_lt;
  · exact fun i => IMO2012Q6_construct_p_range n j k δ i;
  · convert IMO2012Q6_construct_p_sum n j k δ hδ_bij K hδ_eq hk_eq using 1;
    fin_cases j <;> simp +decide [ Fin.sum_univ_succ ] <;> ring!;
    · simp +decide [ IMO2012Q6_coeffs ];
    · simp +decide [ IMO2012Q6_coeffs ];
    · simp +decide [ IMO2012Q6_coeffs ];
    · simp +decide [ IMO2012Q6_coeffs ];
    · simp +decide [ IMO2012Q6_coeffs ]

/-
Upper bound on K.
-/
theorem IMO2012Q6_K_bound (j : Fin 5) (K : ℕ) (hK : K ∈ IMO2012Q6_K_values j) : K ≤ 123 := by
  fin_cases j <;> revert K <;> native_decide

/-
Inequalities hold for large n.
-/
theorem IMO2012Q6_inequalities_large_n (n : ℕ) (hn : n ≥ 3) (j : Fin 5) (K : ℕ) (hK : K ∈ IMO2012Q6_K_values j) :
  K < 40 * n + 40 ∧ (41 - IMO2012Q6_coeffs j) * n + K ≥ 40 := by
    -- Apply the bounds from the hypotheses.
    apply And.intro (by
    linarith [ IMO2012Q6_K_bound j K hK ]) (by
    exact le_add_of_le_of_nonneg ( by nlinarith [ show 41 - IMO2012Q6_coeffs j ≥ 14 by fin_cases j <;> decide ] ) ( Nat.zero_le _ ))

/-
Modular check definitions.
-/
def IMO2012Q6_residues (j : Fin 5) : Finset ℕ :=
  (IMO2012Q6_K_values j).image (fun K => K % IMO2012Q6_modulus j)

def IMO2012Q6_mod_check (n : ℕ) : Bool :=
  (List.finRange 5).any fun j =>
    ((40 * n + 40) % IMO2012Q6_modulus j) ∈ IMO2012Q6_residues j

/-
Modular check implies propositional check for large n.
-/
theorem IMO2012Q6_mod_check_implies_prop (n : ℕ) (hn : n ≥ 3) (h : IMO2012Q6_mod_check n = true) :
  IMO2012Q6_check_n_prop n := by
    -- By definition of `IMO2012Q6_mod_check`, if `IMO2012Q6_mod_check n` is true, there exists `j` such that `(40 * n + 40) % IMO2012Q6_modulus j` is in `IMO2012Q6_residues j`.
    obtain ⟨j, hj⟩ : ∃ j : Fin 5, ((40 * n + 40) % IMO2012Q6_modulus j) ∈ IMO2012Q6_residues j := by
      unfold IMO2012Q6_mod_check at h; aesop;
    -- By definition of `IMO2012Q6_residues`, there exists some `K` in `IMO2012Q6_K_values j` such that `K % IMO2012Q6_modulus j = (40 * n + 40) % IMO2012Q6_modulus j`.
    obtain ⟨K, hK⟩ : ∃ K ∈ IMO2012Q6_K_values j, K % IMO2012Q6_modulus j = (40 * n + 40) % IMO2012Q6_modulus j := by
      exact Finset.mem_image.mp hj |> fun ⟨ K, hK₁, hK₂ ⟩ => ⟨ K, hK₁, hK₂ ⟩;
    exact ⟨ j, K, hK.1, hK.2, by linarith [ IMO2012Q6_inequalities_large_n n hn j K hK.1 ], by linarith [ IMO2012Q6_inequalities_large_n n hn j K hK.1 ] ⟩

/-
Period of the modular check.
-/
def IMO2012Q6_period : ℕ := 702

/-
Periodicity of the modular check.
-/
theorem IMO2012Q6_mod_check_periodic (n : ℕ) :
  IMO2012Q6_mod_check (n + IMO2012Q6_period) = IMO2012Q6_mod_check n := by
    -- We show that for each $j$, the term $(40 * n + 40) \% M_j$ is periodic with period $P$.
    have h_periodic : ∀ j : Fin 5, (40 * (n + IMO2012Q6_period) + 40) % IMO2012Q6_modulus j = (40 * n + 40) % IMO2012Q6_modulus j := by
      intro j
      have h_mod_periodic : IMO2012Q6_period * 40 % IMO2012Q6_modulus j = 0 := by
        fin_cases j <;> trivial;
      simp +decide [ mul_add, add_assoc, Nat.add_mod, h_mod_periodic ];
      simp +decide [ mul_comm, Nat.add_mod, h_mod_periodic ];
    unfold IMO2012Q6_mod_check; aesop;

/-
Check function for the entire period.
-/
def IMO2012Q6_check_all_period : Bool :=
  (List.range 702).all IMO2012Q6_mod_check

/-
Find failure.
-/
def IMO2012Q6_find_failure : Option ℕ :=
  (List.range 702).find? (fun n => ¬ IMO2012Q6_mod_check n)

/-
Evaluate failure.
-/
#eval IMO2012Q6_find_failure

/-
Find failure for n >= 1.
-/
def IMO2012Q6_find_failure_pos : Option ℕ :=
  (List.range 703).find? (fun n => n ≥ 1 ∧ ¬ IMO2012Q6_mod_check n)

/-
Evaluate failure.
-/
#eval IMO2012Q6_find_failure_pos

/-
Find failure for relevant n.
-/
def IMO2012Q6_find_failure_relevant : Option ℕ :=
  (List.range 703).find? (fun n => n ≥ 1 ∧ (n % 4 == 1 ∨ n % 4 == 2) ∧ ¬ IMO2012Q6_mod_check n)

/-
Evaluate failure for relevant n.
-/
#eval IMO2012Q6_find_failure_relevant

/-
List all relevant failures in the period.
-/
def IMO2012Q6_relevant_failures_list : List ℕ :=
  (List.range 703).filter (fun n => n ≥ 1 ∧ (n % 4 == 1 ∨ n % 4 == 2) ∧ ¬ IMO2012Q6_mod_check n)

/-
Evaluate the list of failures.
-/
#eval IMO2012Q6_relevant_failures_list

/-
Generalized K values.
-/
def IMO2012Q6_gen_K_values (j : Fin 5) (offsets : List ℕ) : Finset ℕ :=
  let c_list : List ℕ := (List.finRange 5).filter (· ≠ j) |>.map IMO2012Q6_coeffs
  let perms : List (List ℕ) := offsets.permutations
  perms.foldr (fun p acc => insert (List.zipWith (· * ·) c_list p).sum acc) ∅

/-
Check function for step 8.
-/
def IMO2012Q6_coeffs8 : List ℕ := [6561, 2187, 729, 243, 81, 27, 9, 3, 1]

def IMO2012Q6_check8_n (n : ℕ) : Bool :=
  let sum_c := 9842
  let target_k_coeff := 19683
  let target_const := 9842
  let offsets := List.range 8
  let perms := offsets.permutations
  (List.range 9).any fun j =>
    let c_j := IMO2012Q6_coeffs8.get! j
    let other_coeffs := IMO2012Q6_coeffs8.eraseIdx j
    let M := target_k_coeff - c_j
    let S := sum_c - c_j
    -- Equation: S * n + K = M * k + target_const
    -- K = M * k + target_const - S * n
    -- K ≡ target_const - S * n (mod M)
    let rhs := (target_const + M * n - (S * n % M)) % M -- careful with subtraction
    -- Actually, just iterate K
    perms.any fun p =>
      let K := (List.zipWith (· * ·) other_coeffs p).sum
      if K % M == rhs then
        let num := S * n + K
        if num >= target_const then
           let k := (num - target_const) / M
           k < n
        else false
      else false

/-
Evaluate check8 for failure cases.
-/
#eval [10, 14, 22, 38, 41, 45].map IMO2012Q6_check8_n

/-
Coefficient expansion function.
-/
def IMO2012Q6_expand_coeffs (coeffs : List ℕ) : List (List ℕ) :=
  (List.range coeffs.length).map fun i =>
    let c := coeffs.get! i
    let new_terms := [27 * c, 9 * c, 3 * c, c, c]
    (coeffs.eraseIdx i) ++ new_terms

/-
Evaluate check8 for predecessors of failures.
-/
#eval [10, 18, 34, 37, 41, 45, 46, 49, 50, 54, 58, 73, 81, 85].map IMO2012Q6_check8_n

/-
Coefficient generation for steps.
-/
def IMO2012Q6_step_coeffs (k : ℕ) : List (List ℕ) :=
  match k with
  | 0 => []
  | 1 => [[27, 9, 3, 1, 1]]
  | k + 1 =>
    let prev := IMO2012Q6_step_coeffs k
    let expanded := prev.map IMO2012Q6_expand_coeffs
    expanded.foldl (· ++ ·) []

/-
Modular check function for step 4k.
-/
def IMO2012Q6_mod_check_step (k : ℕ) (n : ℕ) : Bool :=
  let coeffs_list := IMO2012Q6_step_coeffs k
  let P := 3^(4*k)
  let num_offsets := 4*k
  let offsets := List.range num_offsets
  let perms := offsets.permutations
  coeffs_list.any fun coeffs =>
    let S := coeffs.sum
    let C := P - S
    (List.range coeffs.length).any fun j =>
      let c_j := coeffs.get! j
      let other_coeffs := coeffs.eraseIdx j
      let S_other := S - c_j
      let M := P - c_j
      let target := (C + M * n - (S_other * n % M)) % M
      perms.any fun p =>
        let K := (List.zipWith (· * ·) other_coeffs p).sum
        K % M == target

/-
Checking IMO2012Q6_step_coeffs.
-/
#check IMO2012Q6_step_coeffs

/-
Coefficient generation for steps (v2).
-/
def IMO2012Q6_step_coeffs_v2 (k : ℕ) : List (List ℕ) :=
  match k with
  | 0 => []
  | 1 => [[27, 9, 3, 1, 1]]
  | k + 1 => (IMO2012Q6_step_coeffs_v2 k).flatMap IMO2012Q6_expand_coeffs

/-
Modular check function for step 4k (v2).
-/
def IMO2012Q6_mod_check_step_v2 (k : ℕ) (n : ℕ) : Bool :=
  let coeffs_list := IMO2012Q6_step_coeffs_v2 k
  let P := 3^(4*k)
  let num_offsets := 4*k
  let offsets := List.range num_offsets
  let perms := offsets.permutations
  coeffs_list.any fun coeffs =>
    let S := coeffs.sum
    let C := P - S
    (List.range coeffs.length).any fun j =>
      let c_j := coeffs.get! j
      let other_coeffs := coeffs.eraseIdx j
      let S_other := S - c_j
      let M := P - c_j
      let target := (C + M * n - (S_other * n % M)) % M
      perms.any fun p =>
        let K := (List.zipWith (· * ·) other_coeffs p).sum
        K % M == target

/-
Evaluate modular check for step 2 on failures of step 1.
-/
#eval [14, 22, 38, 41, 45, 49, 50, 53, 54, 58, 62, 77, 85, 89].map (IMO2012Q6_mod_check_step 2)

/-
Failures of step 1.
-/
def IMO2012Q6_failures_step1 : List ℕ :=
  (List.range 702).filter (fun n => n ≥ 1 ∧ (n % 4 == 1 ∨ n % 4 == 2) ∧ ¬ IMO2012Q6_mod_check_step 1 n)

/-
Step 2 covers failures of step 1.
-/
theorem IMO2012Q6_step2_covers_failures : (IMO2012Q6_failures_step1.all (IMO2012Q6_mod_check_step 2)) = true := by native_decide

/-
Reverse check validity.
-/
def IMO2012Q6_reverse_check_valid (n : ℕ) : Bool :=
  if IMO2012Q6_mod_check_step 1 n then true
  else
    if n ≥ 4 then IMO2012Q6_mod_check_step 2 (n - 4)
    else false

/-
Evaluate reverse check on failures.
-/
#eval IMO2012Q6_failures_step1.map (fun n => (n, IMO2012Q6_reverse_check_valid n))

/-
Generalized helper property.
-/
def IMO2012Q6_helper_prop_gen (k : ℕ) (n : ℕ) : Prop :=
  ∃ m < n, ∃ p : Fin (4 * k + 1) → ℕ,
    Function.Injective p ∧
    (∀ i, p i ∈ insert m ((List.range (4 * k)).map (fun x => n + x)).toFinset) ∧
    ∃ coeffs ∈ IMO2012Q6_step_coeffs k,
      ∑ i : Fin (4 * k + 1), coeffs.get! i * p i = 3^(4 * k) * m + (3^(4 * k) - coeffs.sum)

/-
Coefficients are powers of 3.
-/
def IMO2012Q6_is_power_of_3 (n : ℕ) : Prop := ∃ k, n = 3^k

theorem IMO2012Q6_coeffs_are_powers_of_3 (k : ℕ) (coeffs : List ℕ) (h : coeffs ∈ IMO2012Q6_step_coeffs k) :
  ∀ c ∈ coeffs, IMO2012Q6_is_power_of_3 c := by
    revert coeffs;
    induction' k using Nat.strong_induction_on with k ih;
    rcases k with ( _ | _ | k ) <;> simp +arith +decide [ * ];
    · intro coeffs h_coeffs c hc; fin_cases h_coeffs; fin_cases hc <;> [ exact ⟨ 3, rfl ⟩ ; exact ⟨ 2, rfl ⟩ ; exact ⟨ 1, rfl ⟩ ; exact ⟨ 0, rfl ⟩ ; exact ⟨ 0, rfl ⟩ ] ;
    · intro coeffs h_coeffs c hc
      obtain ⟨coeffs', h_coeffs', h_expand⟩ : ∃ coeffs' ∈ IMO2012Q6_step_coeffs (k + 1), coeffs ∈ IMO2012Q6_expand_coeffs coeffs' := by
        have h_expand : ∀ {l : List (List ℕ)}, coeffs ∈ List.foldl (fun x1 x2 => x1 ++ x2) [] (List.map IMO2012Q6_expand_coeffs l) → ∃ coeffs' ∈ l, coeffs ∈ IMO2012Q6_expand_coeffs coeffs' := by
          intros l hl; induction' l using List.reverseRecOn with l ih <;> aesop;
        exact h_expand h_coeffs;
      unfold IMO2012Q6_expand_coeffs at h_expand;
      simp +zetaDelta at *;
      rcases h_expand with ⟨ a, ha, rfl ⟩ ; simp_all +decide [ List.mem_append, List.mem_cons ] ;
      rcases hc with ( hc | rfl | rfl | rfl | rfl );
      · exact ih _ ( Nat.lt_succ_self _ ) _ h_coeffs' _ ( List.mem_of_mem_eraseIdx hc ) |> fun ⟨ k, hk ⟩ => ⟨ k, hk ⟩;
      · obtain ⟨ k, hk ⟩ := ih ( k + 1 ) ( by linarith ) coeffs' h_coeffs' ( coeffs'[a] ) ( by simp ) ; exact ⟨ k + 3, by rw [ hk ] ; ring ⟩;
      · obtain ⟨ k, hk ⟩ := ih _ ( Nat.lt_succ_self _ ) _ h_coeffs' _ ( List.getElem_mem _ ) ; exact ⟨ k + 2, by rw [ hk ] ; ring ⟩ ;
      · obtain ⟨ k, hk ⟩ := ih _ ( Nat.lt_succ_self _ ) _ h_coeffs' _ ( show coeffs'[a] ∈ coeffs' from by simp ) ; exact ⟨ k + 1, by rw [ pow_succ', hk ] ⟩ ;
      · exact ih _ ( Nat.lt_succ_self _ ) _ h_coeffs' _ ( by simp )

/-
Check sum property.
-/
def IMO2012Q6_check_sum_powers_of_2 (k : ℕ) : Bool :=
  let coeffs_list := IMO2012Q6_step_coeffs k
  coeffs_list.all fun coeffs =>
    let sum_val : ℚ := (coeffs.map (fun c => (1 : ℚ) / 2^(4*k - Nat.log 3 c))).sum
    sum_val == 1

/-
Evaluate check.
-/
#eval (List.range 3).map IMO2012Q6_check_sum_powers_of_2

/-
Evaluate coefficients for k=2.
-/
#eval IMO2012Q6_step_coeffs 2

/-
Correct coefficient expansion.
-/
def IMO2012Q6_expand_coeffs_correct (coeffs : List ℕ) : List (List ℕ) :=
  (List.range coeffs.length).map fun i =>
    let c := coeffs.get! i
    let new_terms := [27 * c, 9 * c, 3 * c, c, c]
    let others := (coeffs.eraseIdx i).map (fun x => x * 81)
    others ++ new_terms

/-
Correct step coefficients generation.
-/
def IMO2012Q6_step_coeffs_correct (k : ℕ) : List (List ℕ) :=
  match k with
  | 0 => []
  | 1 => [[27, 9, 3, 1, 1]]
  | k + 1 => (IMO2012Q6_step_coeffs_correct k).flatMap IMO2012Q6_expand_coeffs_correct

/-
Check sum property with correct coefficients.
-/
def IMO2012Q6_check_sum_powers_of_2_correct (k : ℕ) : Bool :=
  let coeffs_list := IMO2012Q6_step_coeffs_correct k
  coeffs_list.all fun coeffs =>
    let sum_val : ℚ := (coeffs.map (fun c => (1 : ℚ) / 2^(4*k - Nat.log 3 c))).sum
    sum_val == 1

/-
Evaluate check.
-/
#eval (List.range 3).map IMO2012Q6_check_sum_powers_of_2_correct

/-
Sum invariance under coefficient expansion.
-/
theorem IMO2012Q6_sum_invariant (k : ℕ) (coeffs : List ℕ) (h_pos : ∀ c ∈ coeffs, c > 0)
  (h_log : ∀ c ∈ coeffs, Nat.log 3 c ≤ 4 * k) :
  ∀ coeffs' ∈ IMO2012Q6_expand_coeffs_correct coeffs,
    (coeffs'.map (fun c => (1 : ℚ) / 2^(4*(k+1) - Nat.log 3 c))).sum = (coeffs.map (fun c => (1 : ℚ) / 2^(4*k - Nat.log 3 c))).sum := by
      intro coeffs' h_coeffs'
      have h_expand : coeffs' ∈ List.map (fun i => (coeffs.eraseIdx i).map (fun x => x * 81) ++ [27 * (coeffs.get! i), 9 * (coeffs.get! i), 3 * (coeffs.get! i), (coeffs.get! i), (coeffs.get! i)]) (List.range coeffs.length) := by
        exact?;
      -- Let's choose any index `i �`� where the expansion occurs.
      obtain ⟨i, hi⟩ : ∃ i ∈ List.range coeffs.length, coeffs' = (coeffs.eraseIdx i).map (fun x => x * 81) ++ [27 * (coeffs.get! i), 9 * (coeffs.get! i), 3 * (coeffs.get! i), (coeffs.get! i), (coeffs.get! i)] := by
        rw [ List.mem_map ] at h_expand; tauto;
      -- By definition of `coeffs'`, we can split the sum into the sum of the terms in `coeffs.eraseIdx i` and the sum of the new terms.
      have h_split_sum : (List.map (fun c => (1 : ℚ) / 2 ^ (4 * (k + 1) - Nat.log 3 c)) coeffs').sum =
        (List.map (fun c => (1 : ℚ) / 2 ^ (4 * k - Nat.log 3 c)) (coeffs.eraseIdx i)).sum +
        (1 / 2 ^ (4 * k - Nat.log 3 (coeffs.get! i) + 1) + 1 / 2 ^ (4 * k - Nat.log 3 (coeffs.get! i) + 2) + 1 / 2 ^ (4 * k - Nat.log 3 (coeffs.get! i) + 3) + 1 / 2 ^ (4 * k - Nat.log 3 (coeffs.get! i) + 4) + 1 / 2 ^ (4 * k - Nat.log 3 (coeffs.get! i) + 4)) := by
          have h_split_sum : (List.map (fun c => (1 : ℚ) / 2 ^ (4 * (k + 1) - Nat.log 3 c)) (List.map (fun x => x * 81) (coeffs.eraseIdx i))).sum =
            (List.map (fun c => (1 : ℚ) / 2 ^ (4 * k - Nat.log 3 c)) (coeffs.eraseIdx i)).sum := by
              have h_split_sum : ∀ x ∈ coeffs.eraseIdx i, (1 : ℚ) / 2 ^ (4 * (k + 1) - Nat.log 3 (x * 81)) = (1 : ℚ) / 2 ^ (4 * k - Nat.log 3 x) := by
                intro x hx
                have h_log : Nat.log 3 (x * 81) = Nat.log 3 x + 4 := by
                  rw [ show x * 81 = x * 3 ^ 4 by ring, Nat.log_eq_iff ] <;> norm_num;
                  have := Nat.pow_log_le_self 3 ( show x ≠ 0 from ne_of_gt ( h_pos x ( List.mem_of_mem_eraseIdx hx ) ) ) ; ( have := Nat.lt_pow_succ_log_self ( by decide : 1 < 3 ) x; ( norm_num [ Nat.pow_succ', Nat.pow_mul ] at *; constructor <;> linarith; ) )
                rw [h_log]
                ring;
                rw [ Nat.add_sub_add_left ];
              exact congr_arg _ ( List.ext_get ( by aesop ) ( by aesop ) );
          simp_all +decide [ List.sum_append, List.sum_map_mul_right ];
          rw [ show Nat.log 3 ( 27 * coeffs[i] ) = Nat.log 3 coeffs[i] + 3 from ?_, show Nat.log 3 ( 9 * coeffs[i] ) = Nat.log 3 coeffs[i] + 2 from ?_, show Nat.log 3 ( 3 * coeffs[i] ) = Nat.log 3 coeffs[i] + 1 from ?_ ] <;> ring ; ring;
          · rw [ show 4 + k * 4 - ( 3 + Nat.log 3 coeffs[i] ) = k * 4 - Nat.log 3 coeffs[i] + 1 by rw [ Nat.sub_eq_of_eq_add ] ; linarith [ Nat.sub_add_cancel ( show Nat.log 3 coeffs[i] ≤ k * 4 from by linarith [ h_log coeffs[i] ( by simp ) ] ) ], show 4 + k * 4 - ( 2 + Nat.log 3 coeffs[i] ) = k * 4 - Nat.log 3 coeffs[i] + 2 by rw [ Nat.sub_eq_of_eq_add ] ; linarith [ Nat.sub_add_cancel ( show Nat.log 3 coeffs[i] ≤ k * 4 from by linarith [ h_log coeffs[i] ( by simp ) ] ) ], show 4 + k * 4 - ( 1 + Nat.log 3 coeffs[i] ) = k * 4 - Nat.log 3 coeffs[i] + 3 by rw [ Nat.sub_eq_of_eq_add ] ; linarith [ Nat.sub_add_cancel ( show Nat.log 3 coeffs[i] ≤ k * 4 from by linarith [ h_log coeffs[i] ( by simp ) ] ) ] ] ; ring;
            rw [ show 4 + k * 4 - Nat.log 3 coeffs[i] = k * 4 - Nat.log 3 coeffs[i] + 4 by rw [ Nat.sub_eq_of_eq_add ] ; linarith [ Nat.sub_add_cancel ( show Nat.log 3 coeffs[i] ≤ k * 4 from by linarith [ h_log coeffs[i] ( by simp ) ] ) ] ] ; ring;
          · rw [ Nat.log_eq_iff ] <;> norm_num;
            norm_num [ pow_add, pow_one, pow_mul ];
            exact ⟨ by linarith [ Nat.pow_log_le_self 3 ( show coeffs[i] ≠ 0 from ne_of_gt ( h_pos _ ( by simp ) ) ) ], by rw [ ← pow_succ' ] ; exact Nat.lt_pow_succ_log_self ( by decide ) _ ⟩;
          · rw [ Nat.log_eq_iff ] <;> norm_num;
            have := Nat.pow_log_le_self 3 ( show coeffs[i] ≠ 0 from ne_of_gt ( h_pos _ ( by simp ) ) ) ; ( have := Nat.lt_pow_succ_log_self ( by decide : 1 < 3 ) ( coeffs[i] ) ; ( norm_num [ Nat.pow_add, Nat.pow_mul ] at * ; constructor <;> linarith; ) );
          · rw [ Nat.log_eq_iff ] <;> norm_num;
            have := Nat.pow_log_le_self 3 ( show coeffs[i] ≠ 0 from ne_of_gt ( h_pos _ ( by simp ) ) ) ; ( have := Nat.lt_pow_succ_log_self ( by decide : 1 < 3 ) coeffs[i]; ( norm_num [ Nat.pow_add, Nat.pow_mul ] at * ; constructor <;> linarith; ) );
      -- By combining the results from h_split_sum and h_sum_eq, we can conclude that the sum of the terms in coeffs' is equal to the sum of the terms in coeffs.
      have h_final : (List.map (fun c => (1 : ℚ) / 2 ^ (4 * k - Nat.log 3 c)) coeffs).sum =
        (List.map (fun c => (1 : ℚ) / 2 ^ (4 * k - Nat.log 3 c)) (coeffs.eraseIdx i)).sum +
        (1 / 2 ^ (4 * k - Nat.log 3 (coeffs.get! i))) := by
          have h_final : ∀ (l : List ℕ) (i : ℕ), i < l.length → (List.map (fun c => (1 : ℚ) / 2 ^ (4 * k - Nat.log 3 c)) l).sum =
            (List.map (fun c => (1 : ℚ) / 2 ^ (4 * k - Nat.log 3 c)) (l.eraseIdx i)).sum +
            (1 / 2 ^ (4 * k - Nat.log 3 (l.get! i))) := by
              intros l i hi;
              induction' l with hd tl ih generalizing i <;> simp_all +decide [ List.eraseIdx ];
              rcases i with ( _ | i ) <;> simp_all +decide [ List.eraseIdx ];
              · ring;
              · rw [ ih i hi, add_assoc ];
          exact h_final coeffs i ( List.mem_range.mp hi.1 );
      grind

/-
Definition of the next sequence.
-/
def IMO2012Q6_exponent_offset (k : ℕ) (c : ℕ) : ℕ := 4 * k - Nat.log 3 c

noncomputable def IMO2012Q6_next_seq_gen (n k : ℕ) (a : Fin n → ℕ) (m : Fin n) (p : Fin (4 * k + 1) → ℕ) (coeffs : List ℕ) : Fin (n + 4 * k) → ℕ :=
  fun i =>
    if h : ∃ j : Fin (4 * k + 1), p j = i then
      let j := Classical.choose h
      a m + IMO2012Q6_exponent_offset k (coeffs.get! j)
    else
      if h_lt : i.val < n then a ⟨i.val, h_lt⟩ else 0

/-
Coefficients are positive.
-/
theorem IMO2012Q6_coeffs_pos (k : ℕ) (coeffs : List ℕ) (h : coeffs ∈ IMO2012Q6_step_coeffs_correct k) :
  ∀ c ∈ coeffs, c > 0 := by
    revert coeffs h;
    induction' k with k ih;
    · decide +kernel;
    · intro coeffs h_coeffs c hc;
      -- By definition of `IMO2012Q6_expand_coeffs_correct`, each element in the expanded list is either a multiple of a positive coefficient from the previous step or a new term from the expansion of a coefficient.
      have h_expand_pos : ∀ coeffs ∈ IMO2012Q6_step_coeffs_correct k, ∀ coeffs' ∈ IMO2012Q6_expand_coeffs_correct coeffs, ∀ c ∈ coeffs', c > 0 := by
        intros coeffs h_coeffs coeffs' h_coeffs' c hc
        simp [IMO2012Q6_expand_coeffs_correct] at h_coeffs' hc;
        rcases h_coeffs' with ⟨ a, ha, rfl ⟩ ; simp_all +decide [ List.mem_append, List.mem_map ] ;
        rcases hc with ( ⟨ x, hx, rfl ⟩ | rfl | rfl | rfl | rfl ) <;> [ exact mul_pos ( ih _ h_coeffs _ ( List.mem_of_mem_eraseIdx hx ) ) ( by decide ) ; exact mul_pos ( by decide ) ( ih _ h_coeffs _ ( by simp ) ) ; exact mul_pos ( by decide ) ( ih _ h_coeffs _ ( by simp ) ) ; exact mul_pos ( by decide ) ( ih _ h_coeffs _ ( by simp ) ) ; exact ih _ h_coeffs _ ( by simp ) ];
      unfold IMO2012Q6_step_coeffs_correct at h_coeffs; aesop;

/-
Logarithm bound preservation step.
-/
theorem IMO2012Q6_log_bound_step (k : ℕ) (coeffs : List ℕ) (h : ∀ c ∈ coeffs, Nat.log 3 c ≤ 4 * k) :
  ∀ coeffs' ∈ IMO2012Q6_expand_coeffs_correct coeffs, ∀ c' ∈ coeffs', Nat.log 3 c' ≤ 4 * (k + 1) := by
    intros coeffs' h_coeffs' c' hc'
    simp [IMO2012Q6_expand_coeffs_correct] at h_coeffs';
    -- Let's consider the two cases for c' in coeffs'.
    obtain ⟨a, ha₁, ha₂⟩ := h_coeffs'
    by_cases h_case : c' ∈ List.map (fun x => x * 81) (coeffs.eraseIdx a);
    · obtain ⟨ c, hc₁, rfl ⟩ := List.mem_map.mp h_case;
      have := h c ( List.mem_of_mem_eraseIdx hc₁ );
      by_cases hc : c = 0;
      · norm_num [ hc ];
      · refine' Nat.le_of_lt_succ ( Nat.log_lt_of_lt_pow _ _ );
        · positivity;
        · have := Nat.lt_pow_of_log_lt ( by decide ) ( show Nat.log 3 c < 4 * k + 1 from Nat.lt_succ_of_le this ) ; norm_num [ Nat.pow_succ', Nat.pow_mul ] at * ; linarith;
    · -- Since $c'$ is not in the list of elements multiplied by 81, it must be one of the new terms generated from $coeffs[a]$.
      obtain ⟨hc'_new⟩ : c' = 27 * coeffs[a]?.getD 0 ∨ c' = 9 * coeffs[a]?.getD 0 ∨ c' = 3 * coeffs[a]?.getD 0 ∨ c' = coeffs[a]?.getD 0 := by
        grind +ring
      generalize_proofs at *; (
      rcases x : coeffs[a]? with ( _ | ⟨ c, hc ⟩ ) <;> simp_all +decide [ Nat.log_eq_iff ];
      have := h _ ( show coeffs[a] ∈ coeffs from by simp ) ; simp_all +decide [ Nat.log_eq_iff ] ;
      refine' Nat.le_of_lt_succ ( Nat.log_lt_of_lt_pow _ _ ) <;> norm_num [ Nat.pow_succ', Nat.pow_mul ] at *;
      have := Nat.lt_pow_of_log_lt ( by norm_num ) ( show Nat.log 3 ( ‹_› + 1 ) < 4 * k + 1 from Nat.lt_succ_of_le this ) ; norm_num [ Nat.pow_succ', Nat.pow_mul ] at * ; linarith [ pow_pos ( by norm_num : 0 < 81 ) k ] ;);
      rcases ‹_› with ( rfl | rfl | rfl ) <;> norm_num [ Nat.log_mul_base ] at *;
      · rcases n : coeffs.get? a with ( _ | n ) <;> simp_all +decide [ Nat.log_eq_iff ];
        have := h _ ( show coeffs[a] ∈ coeffs from by simp ) ; simp_all +decide [ Nat.log_eq_iff ] ;
        refine' Nat.le_trans ( Nat.log_mono_right <| show 9 * _ ≤ 3 ^ ( 4 * k + 3 ) from _ ) _;
        · have := Nat.lt_pow_of_log_lt ( by norm_num ) ( show Nat.log 3 ‹_› < 4 * k + 1 from Nat.lt_succ_of_le this ) ; norm_num [ Nat.pow_add, Nat.pow_mul ] at * ; linarith;
        · rw [ Nat.log_pow ] <;> norm_num ; linarith;
      · rw [ Nat.log ];
        norm_num [ Nat.mul_div_cancel_left _ ( by decide : 0 < 3 ) ];
        grind;
      · exact le_trans ( h _ <| by rw [ List.getElem?_eq_getElem ha₁ ] ; exact List.getElem_mem _ ) ( by linarith )

/-
Logarithm bound for coefficients.
-/
theorem IMO2012Q6_coeffs_log_bound (k : ℕ) (coeffs : List ℕ) (h : coeffs ∈ IMO2012Q6_step_coeffs_correct k) :
  ∀ c ∈ coeffs, Nat.log 3 c ≤ 4 * k := by
    induction' k using Nat.strong_induction_on with k ih generalizing coeffs; ( rcases k with ( _ | _ | k ) <;> simp_all +arith +decide; ) ;
    · cases h;
    · native_decide +revert;
    · -- By definition of `IMO2012Q6_step_coeffs_correct`, `coeffs` is obtained by expanding some `prev_coeffs` in `IMO2012Q6_step_coeffs_correct (k + 1)`.
      obtain ⟨prev_coeffs, h_prev, h_expand⟩ : ∃ prev_coeffs ∈ IMO2012Q6_step_coeffs_correct (k + 1), coeffs ∈ IMO2012Q6_expand_coeffs_correct prev_coeffs := by
        contrapose! h; simp_all +decide [ IMO2012Q6_step_coeffs_correct ] ;
      have := IMO2012Q6_log_bound_step ( k + 1 ) prev_coeffs ( fun c hc => ih ( k + 1 ) ( by linarith ) prev_coeffs h_prev c hc ) ; aesop;

/-
Sum property of coefficients.
-/
theorem IMO2012Q6_sum_property (k : ℕ) (coeffs : List ℕ) (h : coeffs ∈ IMO2012Q6_step_coeffs_correct k) :
  (coeffs.map (fun c => (1 : ℚ) / 2^(4*k - Nat.log 3 c))).sum = 1 := by
    have h_ind : ∀ k, ∀ coeffs' ∈ IMO2012Q6_step_coeffs_correct (k + 1), (coeffs'.map (fun c => (1 : ℚ) / 2^(4*(k+1) - Nat.log 3 c))).sum = 1 := by
      intro k
      induction' k with k ih;
      · native_decide +revert;
      · intro coeffs' h_coeffs';
        have h_expand : ∀ coeffs ∈ IMO2012Q6_step_coeffs_correct (k + 1), ∀ coeffs' ∈ IMO2012Q6_expand_coeffs_correct coeffs, (coeffs'.map (fun c => (1 : ℚ) / 2^(4*(k+2) - Nat.log 3 c))).sum = (coeffs.map (fun c => (1 : ℚ) / 2^(4*(k+1) - Nat.log 3 c))).sum := by
          intros coeffs h_coeffs coeffs' h_coeffs';
          apply IMO2012Q6_sum_invariant;
          · exact IMO2012Q6_coeffs_pos _ _ h_coeffs;
          · exact?;
          · assumption;
        unfold IMO2012Q6_step_coeffs_correct at h_coeffs'; aesop;
    rcases k with ( _ | k ) <;> simp_all +decide [ Nat.mul_succ ];
    cases h

/-
Length of coefficient list.
-/
theorem IMO2012Q6_coeffs_length (k : ℕ) (coeffs : List ℕ) (h : coeffs ∈ IMO2012Q6_step_coeffs_correct k) :
  coeffs.length = 4 * k + 1 := by
    -- We can prove this by induction on $k$.
    induction' k with k ih generalizing coeffs;
    · contradiction;
    · -- By definition of `IMO2012Q6_expand_coeffs_correct`, each element in the expanded list has length 4*(k+1) + 1.
      have h_length : ∀ coeffs ∈ IMO2012Q6_step_coeffs_correct k, ∀ coeffs' ∈ IMO2012Q6_expand_coeffs_correct coeffs, coeffs'.length = 4 * (k + 1) + 1 := by
        intros coeffs h_coeffs coeffs' h_coeffs'
        simp [IMO2012Q6_expand_coeffs_correct] at h_coeffs' ⊢;
        grind;
      unfold IMO2012Q6_step_coeffs_correct at h; aesop;

/-
First sum condition for recurrence.
-/
theorem IMO2012Q6_recurrence_sum1 (n k : ℕ) (a : Fin n → ℕ) (m : Fin n) (p : Fin (4 * k + 1) → ℕ) (coeffs : List ℕ)
  (h_coeffs : coeffs ∈ IMO2012Q6_step_coeffs_correct k)
  (hp_inj : Function.Injective p)
  (hp_range : ∀ i, p i ∈ insert (m : ℕ) ((List.range (4 * k)).map (fun x => n + x)).toFinset)
  (ha_sum : ∑ i : Fin n, (1 : ℚ) / 2 ^ (a i) = 1) :
  let a' := IMO2012Q6_next_seq_gen n k a m p coeffs
  ∑ i : Fin (n + 4 * k), (1 : ℚ) / 2 ^ (a' i) = 1 := by
    -- Split the sum into the sum over the indices in the image of `p` and the sum over the indices not in the image.
    have h_split_sum : ∑ i : Fin (n + 4 * k), (1 / 2 ^ (IMO2012Q6_next_seq_gen n k a m p coeffs i) : ℚ) =
      ∑ i ∈ Finset.image (fun i : Fin (4 * k + 1) => ⟨p i, by
        simp +zetaDelta at *;
        cases hp_range i <;> omega⟩ : Fin (4 * k + 1) → Fin (n + 4 * k)) Finset.univ, (1 / 2 ^ (IMO2012Q6_next_seq_gen n k a m p coeffs i) : ℚ) +
      ∑ i ∈ Finset.univ \ Finset.image (fun i : Fin (4 * k + 1) => ⟨p i, by
        simp +zetaDelta at *;
        cases hp_range i <;> omega⟩ : Fin (4 * k + 1) → Fin (n + 4 * k)) Finset.univ, (1 / 2 ^ (IMO2012Q6_next_seq_gen n k a m p coeffs i) : ℚ) := by
        rw [ ← Finset.sum_union ] <;> norm_num [ Finset.disjoint_sdiff ];
        rw [ Finset.union_eq_right.mpr ];
        exact Finset.subset_univ _
    generalize_proofs at *;
    -- For indices in the image of `p`, `a' (p j) = a m + 4k - log3 (coeffs[j])`.
    have h_image_sum : ∑ i ∈ Finset.image (fun i : Fin (4 * k + 1) => ⟨p i, by
      solve_by_elim⟩ : Fin (4 * k + 1) → Fin (n + 4 * k)) Finset.univ, (1 / 2 ^ (IMO2012Q6_next_seq_gen n k a m p coeffs i) : ℚ) =
      (1 / 2 ^ (a m) : ℚ) * ∑ i : Fin (4 * k + 1), (1 / 2 ^ (IMO2012Q6_exponent_offset k (coeffs.get! i)) : ℚ) := by
        rw [ Finset.sum_image <| by intros i hi j hj hij; simpa [ Fin.ext_iff ] using hp_inj <| by simpa [ Fin.ext_iff ] using hij ] ; norm_num [ Finset.mul_sum _ _ _, IMO2012Q6_next_seq_gen ] ; ring;
        congr! 2
        generalize_proofs at *;
        rename_i i _ _ _; have := Classical.choose_spec ‹∃ j, p j = p i›; have := hp_inj this; aesop;
    generalize_proofs at *;
    -- For indices not in the image of `p`, `a' i = a i`.
    have h_non_image_sum : ∑ i ∈ Finset.univ \ Finset.image (fun i : Fin (4 * k + 1) => ⟨p i, by
      solve_by_elim⟩ : Fin (4 * k + 1) → Fin (n + 4 * k)) Finset.univ, (1 / 2 ^ (IMO2012Q6_next_seq_gen n k a m p coeffs i) : ℚ) =
      ∑ i ∈ Finset.univ.erase m, (1 / 2 ^ (a i) : ℚ) := by
        refine' Finset.sum_bij ( fun i hi => ⟨ i, by
          exact lt_of_not_ge fun hi' => Finset.mem_sdiff.mp hi |>.2 <| Finset.mem_image.mpr <| by
            cases' Finset.mem_image.mp ( show ( i : ℕ ) ∈ Finset.image p Finset.univ from by
                                          have h_image : Finset.image p Finset.univ = Finset.Ico n (n + 4 * k) ∪ {↑m} := by
                                            refine' Finset.eq_of_subset_of_card_le ( fun x hx => _ ) _ <;> simp_all +decide [ Finset.card_image_of_injective _ hp_inj ];
                                            grind +ring
                                            skip
                                          generalize_proofs at *;
                                          exact h_image.symm ▸ Finset.mem_union_left _ ( Finset.mem_Ico.mpr ⟨ hi', by linarith [ Fin.is_lt i ] ⟩ ) ) with x hx ; use x ; aesop
            skip
          skip ⟩ ) _ _ _ _ <;> simp +decide
        all_goals generalize_proofs at *;
        · intro a ha; specialize ha ( Classical.choose ( show ∃ i : Fin ( 4 * k + 1 ), p i = m from by
                                                          have h_card : Finset.card (Finset.image p Finset.univ) = 4 * k + 1 := by
                                                            rw [ Finset.card_image_of_injective _ hp_inj, Finset.card_fin ]
                                                          generalize_proofs at *;
                                                          contrapose! h_card
                                                          generalize_proofs at *;
                                                          have h_card : Finset.image p Finset.univ ⊆ Finset.image (fun x => n + x) (Finset.range (4 * k)) := by
                                                            simp_all +decide [ Finset.subset_iff ]
                                                          generalize_proofs at *;
                                                          exact ne_of_lt ( lt_of_le_of_lt ( Finset.card_le_card h_card ) ( lt_of_le_of_lt ( Finset.card_image_le ) ( by simp +arith +decide ) ) ) ) ) ; simp_all +decide [ Fin.ext_iff ] ;
          generalize_proofs at *;
          intro h; specialize ha ( Classical.choose ( show ∃ i : Fin ( 4 * k + 1 ), p i = m from by
                                                        by_contra h_contra; push_neg at h_contra; (
                                                        have h_image : Finset.image p Finset.univ = Finset.Ico 0 n ∪ Finset.Ico n (n + 4 * k) := by
                                                          refine' Finset.eq_of_subset_of_card_le ( fun x hx => _ ) _ <;> simp_all +decide [ Finset.card_image_of_injective _ hp_inj ];
                                                          · exact Classical.or_iff_not_imp_left.2 fun h => ⟨ by linarith [ hx.choose_spec, ‹∀ i : Fin ( 4 * k + 1 ), p i < n + 4 * k› hx.choose ], by linarith [ hx.choose_spec, ‹∀ i : Fin ( 4 * k + 1 ), p i < n + 4 * k› hx.choose ] ⟩;
                                                          · exact absurd ( Finset.card_le_card ( show Finset.image p Finset.univ ⊆ Finset.Ico n ( n + 4 * k ) from Finset.image_subset_iff.mpr fun i _ => Finset.mem_Ico.mpr ⟨ by obtain ⟨ a, ha, ha' ⟩ := hp_range i; linarith, by obtain ⟨ a, ha, ha' ⟩ := hp_range i; linarith [ ‹∀ i : Fin ( 4 * k + 1 ), p i < n + 4 * k› i ] ⟩ ) ) ( by simp +decide [ Finset.card_image_of_injective _ hp_inj ] )
                                                        generalize_proofs at *;
                                                        replace h_image := Finset.ext_iff.mp h_image m ; simp_all +decide [ Finset.mem_union, Finset.mem_Ico ])
                                                        skip ) ) ; simp_all +decide [ Fin.ext_iff ] ;
          generalize_proofs at *;
          exact ha ( Classical.choose_spec ‹∃ x, p x = m› );
        · exact fun a₁ ha₁ a₂ ha₂ h => Fin.ext h;
        · intro b hb; use ⟨ b, by linarith [ Fin.is_lt b ] ⟩ ; simp +decide [ hb ] ;
          intro i hi; specialize hp_range i; simp_all +decide [ Finset.mem_insert, Finset.mem_range ] ;
          exact absurd ( hp_range.resolve_left ( by simpa [ Fin.ext_iff ] using hb ) ) ( by rintro ⟨ a, ha, ha' ⟩ ; linarith [ Fin.is_lt b ] );
        · intro i hi; unfold IMO2012Q6_next_seq_gen; simp +decide [ hi ] ;
          split_ifs <;> simp_all +decide [ Fin.ext_iff ];
          exact False.elim <| hi ( Classical.choose ‹∃ j, p j = i› ) <| Fin.ext <| by linarith [ Classical.choose_spec ‹∃ j, p j = i› ] ; ;
    generalize_proofs at *;
    -- By `IMO2012Q6_sum_property`, the inner sum is 1.
    have h_inner_sum : ∑ i : Fin (4 * k + 1), (1 / 2 ^ (IMO2012Q6_exponent_offset k (coeffs.get! i)) : ℚ) = 1 := by
      convert IMO2012Q6_sum_property k coeffs h_coeffs using 1
      generalize_proofs at *;
      have h_len : coeffs.length = 4 * k + 1 := by
        exact IMO2012Q6_coeffs_length k coeffs h_coeffs
      generalize_proofs at *;
      have h_len : List.map (fun c => 1 / 2 ^ (4 * k - Nat.log 3 c) : ℕ → ℚ) coeffs = List.map (fun i => 1 / 2 ^ (4 * k - Nat.log 3 (coeffs.get! i)) : Fin (4 * k + 1) → ℚ) (List.finRange (4 * k + 1)) := by
        refine' List.ext_get _ _ <;> aesop
        skip
      generalize_proofs at *;
      exact?
    generalize_proofs at *; aesop;

/-
Base case for sum property.
-/
theorem IMO2012Q6_sum_property_base :
  ∀ coeffs ∈ IMO2012Q6_step_coeffs_correct 1, (coeffs.map (fun c => (1 : ℚ) / 2^(4*1 - Nat.log 3 c))).sum = 1 := by
    exact?

/-
Bound on the values of the permutation p.
-/
theorem IMO2012Q6_p_lt_bound (n k : ℕ) (m : Fin n) (p : Fin (4 * k + 1) → ℕ)
  (hp_range : ∀ i, p i ∈ insert (m : ℕ) ((List.range (4 * k)).map (fun x => n + x)).toFinset)
  (j : Fin (4 * k + 1)) :
  p j < n + 4 * k := by
    specialize hp_range j; simp_all +decide [ List.foldr ] ;
    grind

/-
Value of the next sequence at permuted indices.
-/
theorem IMO2012Q6_next_seq_gen_at_p (n k : ℕ) (a : Fin n → ℕ) (m : Fin n) (p : Fin (4 * k + 1) → ℕ) (coeffs : List ℕ)
  (hp_inj : Function.Injective p)
  (hp_range : ∀ i, p i ∈ insert (m : ℕ) ((List.range (4 * k)).map (fun x => n + x)).toFinset)
  (j : Fin (4 * k + 1)) :
  let i : Fin (n + 4 * k) := ⟨p j, IMO2012Q6_p_lt_bound n k m p hp_range j⟩
  IMO2012Q6_next_seq_gen n k a m p coeffs i = a m + IMO2012Q6_exponent_offset k (coeffs.get! j) := by
    unfold IMO2012Q6_next_seq_gen; simp +decide [ hp_inj.eq_iff ] ;

/-
Coefficients in the correct step generation are powers of 3.
-/
theorem IMO2012Q6_coeffs_correct_are_powers_of_3 (k : ℕ) (coeffs : List ℕ) (h : coeffs ∈ IMO2012Q6_step_coeffs_correct k) :
  ∀ c ∈ coeffs, IMO2012Q6_is_power_of_3 c := by
    -- By induction on $k$, we can show that all coefficients in the list generated by $IMO2012Q6_step_coeffs_correct k$ are powers of 3.
    have h_ind : ∀ k, ∀ coeffs ∈ IMO2012Q6_step_coeffs_correct k, ∀ c ∈ coeffs, IMO2012Q6_is_power_of_3 c := by
      intro k coeffs hcoeffs
      induction' k with k ih generalizing coeffs;
      · cases hcoeffs;
      · rcases k with ( _ | k ) <;> simp_all +decide [ IMO2012Q6_step_coeffs_correct ];
        · exact ⟨ ⟨ 3, rfl ⟩, ⟨ 2, rfl ⟩, ⟨ 1, rfl ⟩, ⟨ 0, rfl ⟩ ⟩;
        · rcases hcoeffs with ⟨ a, ha, hcoeffs ⟩ ; unfold IMO2012Q6_expand_coeffs_correct at hcoeffs; simp_all +decide [ List.mem_flatMap ] ;
          rcases hcoeffs with ⟨ i, hi, rfl ⟩ ; intro c hc; simp_all +decide [ List.mem_append, List.mem_map ] ;
          rcases hc with ( ⟨ d, hd, rfl ⟩ | rfl | rfl | rfl | rfl ) <;> [ exact ih _ ha _ ( by aesop ) |> fun ⟨ k, hk ⟩ => ⟨ k + 4, by rw [ hk ] ⟩ ; exact ih _ ha _ ( by aesop ) |> fun ⟨ k, hk ⟩ => ⟨ k + 3, by rw [ hk ] ⟩ ; exact ih _ ha _ ( by aesop ) |> fun ⟨ k, hk ⟩ => ⟨ k + 2, by rw [ hk ] ⟩ ; exact ih _ ha _ ( by aesop ) |> fun ⟨ k, hk ⟩ => ⟨ k + 1, by rw [ hk ] ⟩ ; exact ih _ ha _ ( by aesop ) ] ;
          · exact ih _ ha _ ( List.mem_of_mem_eraseIdx hd ) |> fun ⟨ k, hk ⟩ => ⟨ k + 4, by rw [ hk ] ; ring ⟩;
          · obtain ⟨ k, hk ⟩ := ih a ha ( a[i] ) ( by simp ) ; exact ⟨ k + 3, by rw [ hk ] ; ring ⟩ ;
          · obtain ⟨ k, hk ⟩ := ih a ha ( a[i] ) ( by simp ) ; exact ⟨ k + 2, by rw [ hk ] ; ring ⟩ ;
          · obtain ⟨ k, hk ⟩ := ih a ha ( a[i] ) ( by simp ) ; exact ⟨ k + 1, by rw [ hk ] ; ring ⟩ ;
    generalize_proofs at *; (exact h_ind k coeffs h)

/-
Sum over the subset of indices for the second condition.
-/
theorem IMO2012Q6_recurrence_sum2_subset (n k : ℕ) (a : Fin n → ℕ) (m : Fin n) (p : Fin (4 * k + 1) → ℕ) (coeffs : List ℕ)
  (h_coeffs : coeffs ∈ IMO2012Q6_step_coeffs_correct k)
  (hp_inj : Function.Injective p)
  (hp_range : ∀ i, p i ∈ insert (m : ℕ) ((List.range (4 * k)).map (fun x => n + x)).toFinset)
  (h_eq : ∑ i : Fin (4 * k + 1), coeffs.get! i * p i = 3^(4 * k) * m + (3^(4 * k) - coeffs.sum)) :
  let a' := IMO2012Q6_next_seq_gen n k a m p coeffs
  let S := Finset.image (fun j => (⟨p j, IMO2012Q6_p_lt_bound n k m p hp_range j⟩ : Fin (n + 4 * k))) Finset.univ
  ∑ i ∈ S, ((i : ℚ) + 1) / 3 ^ (a' i) = ((m : ℚ) + 1) / 3 ^ (a m) := by
    have h_sum_image : ∑ i ∈ Finset.image (fun j => ⟨p j, IMO2012Q6_p_lt_bound n k m p hp_range j⟩ : Fin (4 * k + 1) → Fin (n + 4 * k)) Finset.univ, (i.val + 1 : ℚ) / 3 ^ (IMO2012Q6_next_seq_gen n k a m p coeffs i) = (1 / (3 ^ (a m) * 3 ^ (4 * k))) * ∑ j : Fin (4 * k + 1), coeffs.get! j * (p j + 1) := by
      rw [ Finset.sum_image <| by intros i hi j hj hij; simpa [ hp_inj.eq_iff ] using hij ];
      -- Apply the definition of `IMO2012Q6_next_seq_gen` to each term in the sum.
      have h_term : ∀ j : Fin (4 * k + 1), (p j + 1 : ℚ) / 3 ^ (IMO2012Q6_next_seq_gen n k a m p coeffs ⟨p j, IMO2012Q6_p_lt_bound n k m p hp_range j⟩) = (coeffs.get! j * (p j + 1) : ℚ) / (3 ^ (a m) * 3 ^ (4 * k)) := by
        intros j
        have h_exp : IMO2012Q6_next_seq_gen n k a m p coeffs ⟨p j, IMO2012Q6_p_lt_bound n k m p hp_range j⟩ = a m + IMO2012Q6_exponent_offset k (coeffs.get! j) := by
          convert IMO2012Q6_next_seq_gen_at_p n k a m p coeffs hp_inj hp_range j using 1;
        have h_coeff : ∃ c : ℕ, coeffs.get! j = 3^c ∧ c ≤ 4 * k := by
          have h_coeff : coeffs.get! j ∈ coeffs ∧ coeffs.get! j > 0 ∧ Nat.log 3 (coeffs.get! j) ≤ 4 * k := by
            have h_coeff : coeffs.get! j ∈ coeffs ∧ coeffs.get! j > 0 := by
              have h_coeff : coeffs.get! j ∈ coeffs := by
                have h_len : coeffs.length = 4 * k + 1 := by
                  exact IMO2012Q6_coeffs_length k coeffs h_coeffs |> Eq.trans <| by simp +decide [ Finset.card_image_of_injective, hp_inj.eq_iff ] ;
                generalize_proofs at *; (
                simp +decide [ h_len, List.get?_eq_get ])
              have h_coeff_pos : coeffs.get! j > 0 := by
                exact IMO2012Q6_coeffs_pos k coeffs h_coeffs _ h_coeff
              exact ⟨h_coeff, h_coeff_pos⟩;
            exact ⟨ h_coeff.1, h_coeff.2, IMO2012Q6_coeffs_log_bound k coeffs h_coeffs _ h_coeff.1 ⟩;
          have h_coeff : IMO2012Q6_is_power_of_3 (coeffs.get! j) := by
            exact IMO2012Q6_coeffs_correct_are_powers_of_3 k coeffs h_coeffs _ h_coeff.1;
          obtain ⟨ c, hc ⟩ := h_coeff; use c; aesop;
        field_simp;
        rcases h_coeff with ⟨ c, hc₁, hc₂ ⟩ ; norm_cast ; simp_all +decide [ ← pow_add ] ; ring;
        unfold IMO2012Q6_exponent_offset; simp +decide [ hc₂ ] ; ring;
      simp_all +decide [ div_eq_inv_mul, Finset.mul_sum _ _ _ ];
    simp_all +decide [ mul_add, Finset.sum_add_distrib ];
    rw [ Nat.cast_sub ];
    · have h_sum_coeffs : ∑ j : Fin (4 * k + 1), (coeffs.get! j : ℚ) = coeffs.sum := by
        have h_sum_coeffs : coeffs.length = 4 * k + 1 := by
          exact?;
        have h_sum_coeffs : ∀ (l : List ℕ), (∑ j : Fin l.length, (l.get! j : ℚ)) = l.sum := by
          intro l; induction l <;> simp_all +decide [ Fin.sum_univ_succ ] ;
        convert h_sum_coeffs coeffs using 1;
        refine' Finset.sum_bij ( fun j _ => ⟨ j, by linarith [ Fin.is_lt j ] ⟩ ) _ _ _ _ <;> simp +decide [ Fin.ext_iff ];
        exact fun b => ⟨ ⟨ b, by linarith [ Fin.is_lt b ] ⟩, rfl ⟩;
      simp_all +decide [ div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm ];
      -- Combine like terms and simplify the expression.
      field_simp
      ring;
    · have := IMO2012Q6_sum_property k coeffs h_coeffs;
      have h_sum_le : (List.map (fun c => (1 : ℚ) / 2 ^ (4 * k - Nat.log 3 c)) coeffs).sum * 3 ^ (4 * k) ≥ coeffs.sum := by
        have h_sum_le : ∀ c ∈ coeffs, (c : ℚ) ≤ (1 / 2 ^ (4 * k - Nat.log 3 c)) * 3 ^ (4 * k) := by
          intro c hc; rw [ div_mul_eq_mul_div, le_div_iff₀ ] <;> norm_cast <;> norm_num;
          have h_log_bound : c ≤ 3 ^ (Nat.log 3 c) := by
            have h_log_bound : ∀ c ∈ coeffs, IMO2012Q6_is_power_of_3 c := by
              exact?;
            obtain ⟨ k, rfl ⟩ := h_log_bound c hc; norm_num [ Nat.log_pow ] ;
          refine le_trans ( Nat.mul_le_mul_right _ h_log_bound ) ?_;
          convert Nat.mul_le_mul_left ( 3 ^ Nat.log 3 c ) ( pow_le_pow_left' ( show 2 ≤ 3 by decide ) _ ) using 1 ; ring;
          rw [ ← pow_add, Nat.add_sub_of_le ( show Nat.log 3 c ≤ k * 4 from by linarith [ IMO2012Q6_coeffs_log_bound k coeffs h_coeffs c hc ] ) ];
        simpa [ List.sum_map_mul_right ] using List.sum_le_sum h_sum_le;
      exact_mod_cast ( by nlinarith [ pow_pos ( by decide : 0 < 3 ) ( 4 * k ) ] : ( coeffs.sum : ℚ ) ≤ 3 ^ ( 4 * k ) )

/-
The complement of the image of p is the set of original indices excluding m.
-/
theorem IMO2012Q6_complement_eq_image (n k : ℕ) (m : Fin n) (p : Fin (4 * k + 1) → ℕ)
  (hp_inj : Function.Injective p)
  (hp_range : ∀ i, p i ∈ insert (m : ℕ) ((List.range (4 * k)).map (fun x => n + x)).toFinset) :
  let S := Finset.image (fun j => (⟨p j, IMO2012Q6_p_lt_bound n k m p hp_range j⟩ : Fin (n + 4 * k))) Finset.univ
  Finset.univ.filter (fun x => x ∉ S) = (Finset.univ.erase m).image (Fin.castAdd (4 * k)) := by
    -- To prove equality of sets, we show each set is a subset of the other.
    apply Finset.ext
    intro x
    simp [Finset.mem_image, Finset.mem_erase];
    constructor;
    · intro hx
      by_cases hx_m : x.val < n;
      · by_cases hx_eq_m : x.val = m.val <;> simp_all +decide [ Fin.ext_iff ];
        · have h_card : Finset.card (Finset.image p Finset.univ) = 4 * k + 1 := by
            rw [ Finset.card_image_of_injective _ hp_inj, Finset.card_fin ];
          have h_card : Finset.card (Finset.image p Finset.univ) ≤ 4 * k := by
            have h_card : Finset.image p Finset.univ ⊆ Finset.image (fun x => n + x) (Finset.range (4 * k)) := by
              intro y hy; obtain ⟨ i, _, rfl ⟩ := Finset.mem_image.mp hy; specialize hp_range i; aesop;
            exact le_trans ( Finset.card_le_card h_card ) ( Finset.card_image_le.trans ( by simpa ) );
          grind;
        · exact ⟨ ⟨ x, by linarith ⟩, by simpa [ Fin.ext_iff ] using hx_eq_m, rfl ⟩;
      · -- Since $x$ is not in the image of $p$, it must be in the complement of the image of $p$, which is $\{n, n+1, ..., n+4k-1\}$.
        have hx_compl : ∃ j : Fin (4 * k), x.val = n + j := by
          exact ⟨ ⟨ x - n, by rw [ tsub_lt_iff_left ] <;> linarith [ Fin.is_lt x ] ⟩, by simp +decide [ Nat.add_sub_of_le ( le_of_not_gt hx_m ) ] ⟩;
        obtain ⟨ j, hj ⟩ := hx_compl;
        -- Since $p$ is injective and maps to a set of size $4k+1$, and the target set has size $4k+1$, the image is the whole target set.
        have h_image : Finset.image p Finset.univ = insert (m : ℕ) ((List.range (4 * k)).map (fun x => n + x)).toFinset := by
          refine' Finset.eq_of_subset_of_card_le ( Finset.image_subset_iff.mpr fun i _ => hp_range i ) _;
          rw [ Finset.card_image_of_injective _ hp_inj ] ; simp +arith +decide [ Finset.card_image_of_injective, Function.Injective ];
          refine' le_trans ( Finset.card_insert_le _ _ ) _ ; simp +arith +decide [ List.toFinset_card_of_nodup, List.nodup_range ];
          exact le_trans ( List.toFinset_card_le _ ) ( by simp +arith +decide );
        replace h_image := Finset.ext_iff.mp h_image ( n + j ) ; simp_all +decide [ Fin.ext_iff ] ;
    · rintro ⟨ a, ha, rfl ⟩ i hi; specialize hp_range i; simp_all +decide [ Fin.ext_iff ] ;
      linarith [ Fin.is_lt a, hp_range.choose_spec ]

/-
Sum over the subset of indices for the first condition.
-/
theorem IMO2012Q6_recurrence_sum1_subset (n k : ℕ) (a : Fin n → ℕ) (m : Fin n) (p : Fin (4 * k + 1) → ℕ) (coeffs : List ℕ)
  (h_coeffs : coeffs ∈ IMO2012Q6_step_coeffs_correct k)
  (hp_inj : Function.Injective p)
  (hp_range : ∀ i, p i ∈ insert (m : ℕ) ((List.range (4 * k)).map (fun x => n + x)).toFinset) :
  let a' := IMO2012Q6_next_seq_gen n k a m p coeffs
  let S := Finset.image (fun j => (⟨p j, IMO2012Q6_p_lt_bound n k m p hp_range j⟩ : Fin (n + 4 * k))) Finset.univ
  ∑ i ∈ S, (1 : ℚ) / 2 ^ (a' i) = (1 : ℚ) / 2 ^ (a m) := by
    field_simp;
    rw [ Finset.sum_image <| by intros i hi j hj hij; exact hp_inj <| by simpa using congr_arg Fin.val hij ];
    -- Apply the hypothesis `h_exp` to each term in the sum.
    have h_sum : ∑ j : Fin (4 * k + 1), (1 / 2 ^ (a m + IMO2012Q6_exponent_offset k (coeffs.get! j) : ℕ) : ℚ) = (1 / 2 ^ (a m : ℕ) : ℚ) * ∑ j : Fin (4 * k + 1), (1 / 2 ^ (IMO2012Q6_exponent_offset k (coeffs.get! j) : ℕ) : ℚ) := by
      rw [ Finset.mul_sum _ _ _ ] ; exact Finset.sum_congr rfl fun _ _ => by ring;
    convert congr_arg ( · * 2 ^ a m ) h_sum using 1;
    · congr! 2;
      exact congr_arg _ ( congr_arg _ ( IMO2012Q6_next_seq_gen_at_p n k a m p coeffs hp_inj hp_range _ ) );
    · field_simp;
      convert IMO2012Q6_sum_property k coeffs h_coeffs |> Eq.symm using 1;
      convert Finset.sum_range _ |> Eq.symm using 2;
      rotate_right;
      use fun i => 1 / 2 ^ ( IMO2012Q6_exponent_offset k ( coeffs.get! i ) : ℕ );
      · norm_cast;
      · have h_sum_eq : coeffs.length = 4 * k + 1 := by
          exact?;
        refine' congr_arg _ ( List.ext_get _ _ ) <;> aesop

/-
Second sum condition for the generalized recurrence.
-/
theorem IMO2012Q6_recurrence_sum2 (n k : ℕ) (a : Fin n → ℕ) (m : Fin n) (p : Fin (4 * k + 1) → ℕ) (coeffs : List ℕ)
  (h_coeffs : coeffs ∈ IMO2012Q6_step_coeffs_correct k)
  (hp_inj : Function.Injective p)
  (hp_range : ∀ i, p i ∈ insert (m : ℕ) ((List.range (4 * k)).map (fun x => n + x)).toFinset)
  (h_eq : ∑ i : Fin (4 * k + 1), coeffs.get! i * p i = 3^(4 * k) * m + (3^(4 * k) - coeffs.sum))
  (ha_sum : ∑ i : Fin n, ((i : ℚ) + 1) / 3 ^ (a i) = 1) :
  let a' := IMO2012Q6_next_seq_gen n k a m p coeffs
  ∑ i : Fin (n + 4 * k), ((i : ℚ) + 1) / 3 ^ (a' i) = 1 := by
    have h_image_complement : let S := Finset.image (fun j => (⟨p j, IMO2012Q6_p_lt_bound n k m p hp_range j⟩ : Fin (n + 4 * k))) Finset.univ; Finset.univ = S ∪ (Finset.univ.erase m).image (Fin.castAdd (4 * k)) := by
      have h_complement : let S := Finset.image (fun j => (⟨p j, IMO2012Q6_p_lt_bound n k m p hp_range j⟩ : Fin (n + 4 * k))) Finset.univ; Finset.univ.filter (fun x => x ∉ S) = (Finset.univ.erase m).image (Fin.castAdd (4 * k)) := by
        convert IMO2012Q6_complement_eq_image n k m p hp_inj hp_range using 1;
      grind;
    have h_split_sum : let a' := IMO2012Q6_next_seq_gen n k a m p coeffs; ∑ i : Fin (n + 4 * k), ((i : ℚ) + 1) / (3 ^ (a' i) : ℚ) = (∑ i ∈ (Finset.image (fun j => (⟨p j, IMO2012Q6_p_lt_bound n k m p hp_range j⟩ : Fin (n + 4 * k))) Finset.univ), ((i : ℚ) + 1) / (3 ^ (a' i) : ℚ)) + (∑ i ∈ (Finset.univ.erase m).image (Fin.castAdd (4 * k)), ((i : ℚ) + 1) / (3 ^ (a' i) : ℚ)) := by
      convert Finset.sum_union ?_ using 2;
      rw [ Finset.disjoint_left ] ; simp +decide [ Fin.ext_iff ];
      intro a x hx y hy; specialize hp_range x; simp_all +decide [ Finset.mem_insert, Finset.mem_map ] ;
      grind;
    have h_image_sum : let a' := IMO2012Q6_next_seq_gen n k a m p coeffs; ∑ i ∈ (Finset.image (fun j => (⟨p j, IMO2012Q6_p_lt_bound n k m p hp_range j⟩ : Fin (n + 4 * k))) Finset.univ), ((i : ℚ) + 1) / (3 ^ (a' i) : ℚ) = ((m : ℚ) + 1) / (3 ^ (a m) : ℚ) := by
      convert IMO2012Q6_recurrence_sum2_subset n k a m p coeffs h_coeffs hp_inj hp_range h_eq using 1;
    have h_complement_sum : let a' := IMO2012Q6_next_seq_gen n k a m p coeffs; ∑ i ∈ (Finset.univ.erase m).image (Fin.castAdd (4 * k)), ((i : ℚ) + 1) / (3 ^ (a' i) : ℚ) = ∑ i ∈ Finset.univ.erase m, ((i : ℚ) + 1) / (3 ^ (a i) : ℚ) := by
      field_simp;
      rw [ Finset.sum_image ];
      · refine' Finset.sum_congr rfl fun x hx => _;
        unfold IMO2012Q6_next_seq_gen;
        split_ifs <;> norm_num at *;
        have := Classical.choose_spec ‹∃ j, p j = ↑ ( Fin.castAdd ( 4 * k ) x ) ›; specialize hp_range ( Classical.choose ‹∃ j, p j = ↑ ( Fin.castAdd ( 4 * k ) x ) › ) ; simp_all +decide [ Fin.ext_iff ] ;
        grind;
      · exact fun x hx y hy hxy => by simpa [ Fin.ext_iff ] using hxy;
    simp +zetaDelta at *;
    linarith

/-
Checking if coefficient lists are equal.
-/
def check_coeffs_eq : Bool :=
  let c1 := IMO2012Q6_step_coeffs 2
  let c2 := IMO2012Q6_step_coeffs_correct 2
  c1 == c2

#eval check_coeffs_eq

/-
Evaluating coefficient lists for k=2.
-/
#eval IMO2012Q6_step_coeffs 2
#eval IMO2012Q6_step_coeffs_correct 2
#eval IMO2012Q6_coeffs8

/-
Proof of the recurrence step.
-/
theorem IMO2012Q6_recurrence_step_proven (n : ℕ) (h : IMO2012Q6 n) (h_helper : IMO2012Q6_helper_prop n) : IMO2012Q6 (n + 4) := by
  convert IMO2012Q6_recurrence_step n h h_helper using 1

/-
Checking sum property for k=2 with original coefficients.
-/
#eval IMO2012Q6_check_sum_powers_of_2 2

/-
Checking if step_coeffs is a subset of step_coeffs_correct.
-/
#eval (IMO2012Q6_step_coeffs 2).all (fun c => c ∈ IMO2012Q6_step_coeffs_correct 2)

/-
First sum condition for the generalized recurrence (valid version).
-/
theorem IMO2012Q6_recurrence_sum1_valid (n k : ℕ) (a : Fin n → ℕ) (m : Fin n) (p : Fin (4 * k + 1) → ℕ) (coeffs : List ℕ)
  (h_coeffs : coeffs ∈ IMO2012Q6_step_coeffs_correct k)
  (hp_inj : Function.Injective p)
  (hp_range : ∀ i, p i ∈ insert (m : ℕ) ((List.range (4 * k)).map (fun x => n + x)).toFinset)
  (ha_sum : ∑ i : Fin n, (1 : ℚ) / 2 ^ (a i) = 1) :
  let a' := IMO2012Q6_next_seq_gen n k a m p coeffs
  ∑ i : Fin (n + 4 * k), (1 : ℚ) / 2 ^ (a' i) = 1 := by
    convert IMO2012Q6_recurrence_sum1 n k a m p coeffs h_coeffs hp_inj hp_range ha_sum using 1

/-
Sum over the complement of the image of p for the second condition.
-/
theorem IMO2012Q6_recurrence_sum2_complement (n k : ℕ) (a : Fin n → ℕ) (m : Fin n) (p : Fin (4 * k + 1) → ℕ) (coeffs : List ℕ)
  (hp_inj : Function.Injective p)
  (hp_range : ∀ i, p i ∈ insert (m : ℕ) ((List.range (4 * k)).map (fun x => n + x)).toFinset) :
  let a' := IMO2012Q6_next_seq_gen n k a m p coeffs
  let S := Finset.image (fun j => (⟨p j, IMO2012Q6_p_lt_bound n k m p hp_range j⟩ : Fin (n + 4 * k))) Finset.univ
  ∑ i ∈ Finset.univ.filter (fun x => x ∉ S), ((i : ℚ) + 1) / 3 ^ (a' i) = ∑ i ∈ Finset.univ.erase m, ((i : ℚ) + 1) / 3 ^ (a i) := by
    convert Finset.sum_image ?_ using 2;
    rotate_left;
    rotate_left;
    exact?;
    use fun i => ⟨ i, by linarith [ Fin.is_lt i ] ⟩;
    · exact fun i hi j hj hij => by simpa [ Fin.ext_iff ] using hij;;
    · convert IMO2012Q6_complement_eq_image n k m p hp_inj hp_range using 1;
    · unfold IMO2012Q6_next_seq_gen;
      split_ifs <;> simp_all +decide [ Fin.ext_iff, hp_inj.eq_iff ];
      grind

/-
Checking for failures of the modular check.
-/
#eval IMO2012Q6_relevant_failures_list

/-
Corrected generalized recurrence step.
-/
def IMO2012Q6_helper_prop_gen_correct (k : ℕ) (n : ℕ) : Prop :=
  ∃ m < n, ∃ p : Fin (4 * k + 1) → ℕ,
    Function.Injective p ∧
    (∀ i, p i ∈ insert m ((List.range (4 * k)).map (fun x => n + x)).toFinset) ∧
    ∃ coeffs ∈ IMO2012Q6_step_coeffs_correct k,
      ∑ i : Fin (4 * k + 1), coeffs.get! i * p i = 3^(4 * k) * m + (3^(4 * k) - coeffs.sum)

theorem IMO2012Q6_recurrence_step_gen_correct (n k : ℕ) (h : IMO2012Q6 n) (h_helper : IMO2012Q6_helper_prop_gen_correct k n) : IMO2012Q6 (n + 4 * k) := by
  obtain ⟨ a, ha₁, ha₂ ⟩ := h
  obtain ⟨ m, hm₁, p, hp_inj, hp_range, coeffs, h_coeffs, h_eq ⟩ := h_helper
  generalize_proofs at *;
  -- Apply the generalized recurrence step to conclude the proof.
  apply Exists.intro (IMO2012Q6_next_seq_gen n k a ⟨m, hm₁⟩ p coeffs);
  exact ⟨ by simpa using IMO2012Q6_recurrence_sum1_valid n k a ⟨ m, hm₁ ⟩ p coeffs h_coeffs hp_inj hp_range ha₁, by simpa using IMO2012Q6_recurrence_sum2 n k a ⟨ m, hm₁ ⟩ p coeffs h_coeffs hp_inj hp_range h_eq ha₂ ⟩

/-
Correct modular check function.
-/
def IMO2012Q6_mod_check_step_correct (k : ℕ) (n : ℕ) : Bool :=
  let coeffs_list := IMO2012Q6_step_coeffs_correct k
  let P := 3^(4*k)
  let num_offsets := 4*k
  let offsets := List.range num_offsets
  let perms := offsets.permutations
  coeffs_list.any fun coeffs =>
    let S := coeffs.sum
    let C := P - S
    (List.range coeffs.length).any fun j =>
      let c_j := coeffs.get! j
      let other_coeffs := coeffs.eraseIdx j
      let S_other := S - c_j
      let M := P - c_j
      let target := (C + M * n - (S_other * n % M)) % M
      perms.any fun p =>
        let K := (List.zipWith (· * ·) other_coeffs p).sum
        K % M == target

#eval IMO2012Q6_mod_check_step_correct 1 14
#eval IMO2012Q6_mod_check_step_correct 2 10

/-
Extract witness from modular check.
-/
structure IMO2012Q6_Witness (k : ℕ) where
  coeffs : List ℕ
  h_coeffs : coeffs ∈ IMO2012Q6_step_coeffs_correct k
  j : Fin coeffs.length
  p_offsets : List ℕ
  h_perm : p_offsets ∈ (List.range (4 * k)).permutations
  K' : ℕ
  h_K' : K' = (List.zipWith (· * ·) (coeffs.eraseIdx j) p_offsets).sum

theorem IMO2012Q6_mod_check_extract_witness (k : ℕ) (n : ℕ) (h : IMO2012Q6_mod_check_step_correct k n) :
  ∃ w : IMO2012Q6_Witness k,
    let P := 3^(4*k)
    let S := w.coeffs.sum
    let c_j := w.coeffs.get w.j
    let M := P - c_j
    let C := P - S
    let S_other := S - c_j
    let target := (C + M * n - (S_other * n % M)) % M
    w.K' % M = target := by
      -- By definition of `List.any`, if `h` is true, then there exist `coeffs`, `j`, and `p` such that `K' % M = target`.
      obtain ⟨coeffs, j, p, hp⟩ : ∃ coeffs ∈ IMO2012Q6_step_coeffs_correct k, ∃ j : Fin coeffs.length, ∃ p ∈ List.permutations (List.range (4*k)), (List.zipWith (· * ·) (coeffs.eraseIdx j) p).sum % (3^(4*k) - coeffs.get! j) = ((3^(4*k) - coeffs.sum + (3^(4*k) - coeffs.get! j) * n - (coeffs.sum - coeffs.get! j) * n % (3^(4*k) - coeffs.get! j)) % (3^(4*k) - coeffs.get! j)) := by
        unfold IMO2012Q6_mod_check_step_correct at h;
        simp +zetaDelta at *;
        rcases h with ⟨ coeffs, hcoeffs, j, hj, p, hp, h ⟩ ; use coeffs, hcoeffs, ⟨ j, hj ⟩ ; aesop;
      rcases hp with ⟨ p, hp_mem, hp_eq ⟩ ; refine' ⟨ _, _ ⟩ ; simp_all +decide [ List.get ] ;
      constructor;
      exact j;
      exact List.mem_permutations.mpr hp_mem;
      exact?;
      convert hp_eq using 1;
      · simp +decide [ Fin.cast_val_eq_self ];
      · simp +decide [ List.get! ]

/-
Checking the definition of IMO2012Q6_Witness.
-/
#print IMO2012Q6_Witness

/-
Checking existing declarations.
-/
#print IMO2012Q6_Witness
#check IMO2012Q6_mod_check_extract_witness

/-
Checking if the witness extraction theorem exists.
-/
#check IMO2012Q6_mod_check_extract_witness

/-
Length lemmas for witness fields.
-/
theorem IMO2012Q6_Witness_coeffs_len (k : ℕ) (w : IMO2012Q6_Witness k) : w.coeffs.length = 4 * k + 1 := by
  apply IMO2012Q6_coeffs_length k w.coeffs w.h_coeffs

theorem IMO2012Q6_Witness_offsets_len (k : ℕ) (w : IMO2012Q6_Witness k) : w.p_offsets.length = 4 * k := by
  exact List.mem_permutations.mp w.h_perm |> List.Perm.length_eq |> Eq.trans <| by simp +arith +decide;

/-
Definition of p derived from the witness (manual implementation corrected).
-/
def IMO2012Q6_Witness_p (k n : ℕ) (w : IMO2012Q6_Witness k) (m : ℕ) (i : Fin (4 * k + 1)) : ℕ :=
  let j' : Fin (4 * k + 1) := Fin.cast (IMO2012Q6_Witness_coeffs_len k w) w.j
  if h : i = j' then m
  else
    let idx : Fin (4 * k) :=
      if h_lt : i < j' then
        ⟨i.val, by
          have h1 : i.val < j'.val := h_lt
          have h2 : j'.val < 4 * k + 1 := j'.isLt
          -- We need i.val < 4 * k.
          -- Since i < j' and j' <= 4*k (as j' < 4*k+1), i < 4*k.
          exact lt_of_lt_of_le h1 (Nat.le_of_lt_succ h2)⟩
      else
        ⟨i.val - 1, by
          have h1 : i.val < 4 * k + 1 := i.isLt
          have h_not_lt : ¬(i < j') := h_lt
          have h_ne : i ≠ j' := h
          have h_gt : i.val > j'.val := lt_of_le_of_ne (le_of_not_lt h_not_lt) (fun e => h_ne (Fin.ext e.symm))
          have h_pos : i.val > 0 := lt_of_le_of_lt (Nat.zero_le j'.val) h_gt
          exact Nat.sub_lt_right_of_lt_add (Nat.succ_le_of_lt h_pos) h1⟩
    let idx' : Fin w.p_offsets.length := Fin.cast (IMO2012Q6_Witness_offsets_len k w).symm idx
    n + w.p_offsets.get idx'

/-
Definition of m derived from the witness.
-/
def IMO2012Q6_Witness_m (k n : ℕ) (w : IMO2012Q6_Witness k) : ℕ :=
  let P := 3^(4*k)
  let S := w.coeffs.sum
  let c_j := w.coeffs.get w.j
  let M := P - c_j
  let C := P - S
  let S_other := S - c_j
  let K' := w.K'
  (S_other * n + K' - C) / M

/-
Inequality for terms in the sum.
-/
lemma IMO2012Q6_term_ineq (x : ℕ) (hx : x ≥ 1) : (1 : ℚ) / 3^x ≤ (2/3) * (1 : ℚ) / 2^x := by
  rw [ div_mul_eq_mul_div, div_div, div_le_div_iff₀ ] <;> norm_cast <;> induction hx <;> norm_num [ pow_succ' ] at * ; nlinarith [ pow_pos ( show 0 < 2 by decide ) ‹_›, pow_pos ( show 0 < 2 by decide ) ‹_› ] ;

/-
Strict inequality for terms in the sum.
-/
lemma IMO2012Q6_term_strict_ineq (x : ℕ) (hx : x > 1) : (1 : ℚ) / 3^x < (2/3) * (1 : ℚ) / 2^x := by
  -- We can multiply both sides by $3^x \cdot 2^x$ to obtain $2^x < 2/3 \cdot 3^x$.
  have h_mul : (2 : ℚ) ^ x < (2 : ℚ) / 3 * (3 : ℚ) ^ x := by
    rcases x with ( _ | _ | x ) <;> norm_num at *;
    induction x <;> norm_num [ pow_succ' ] at * ; linarith [ pow_pos ( by norm_num : ( 0 : ℚ ) < 2 ) ‹_›, pow_le_pow_left₀ ( by norm_num ) ( by norm_num : ( 2 : ℚ ) ≤ 3 ) ‹_› ];
  rw [ div_lt_div_iff₀ ] <;> first | positivity | linarith;

/-
The exponent 4k - log3(c) is at least 1.
-/
theorem IMO2012Q6_exponent_ge_one (k : ℕ) (coeffs : List ℕ) (h_coeffs : coeffs ∈ IMO2012Q6_step_coeffs_correct k) (c : ℕ) (hc : c ∈ coeffs) :
  1 ≤ 4 * k - Nat.log 3 c := by
    by_contra h_contra;
    -- If `4 * k - Nat.log 3 c = 0`, then `c = 3^(4 * k)`.
    have h_c_eq : c = 3^(4 * k) := by
      have h_c_eq : Nat.log 3 c = 4 * k := by
        exact le_antisymm ( IMO2012Q6_coeffs_log_bound k coeffs h_coeffs c hc ) ( Nat.le_of_not_gt fun h => h_contra <| Nat.sub_pos_of_lt h );
      have h_c_eq : ∀ c ∈ coeffs, IMO2012Q6_is_power_of_3 c := by
        exact?;
      obtain ⟨ m, hm ⟩ := h_c_eq c hc;
      simp_all +decide [ pow_succ' ];
    -- Since `c` is in `coeffs`, `1` is one of the terms in the sum.
    have h_sum_ge_one : ∑ i ∈ Finset.range coeffs.length, (1 : ℚ) / 2 ^ (4 * k - Nat.log 3 (coeffs.get! i)) > 1 := by
      have h_sum_ge_one : ∃ i ∈ Finset.range coeffs.length, coeffs.get! i = 3^(4 * k) := by
        obtain ⟨ i, hi ⟩ := List.mem_iff_get.mp hc; use i; aesop;
      rw [ Finset.sum_eq_add_sum_diff_singleton h_sum_ge_one.choose_spec.1 ];
      refine' lt_add_of_le_of_pos _ _;
      · rw [ h_sum_ge_one.choose_spec.2, Nat.log_pow ] <;> norm_num;
      · refine' Finset.sum_pos _ _ <;> norm_num;
        refine' Finset.card_pos.mp _;
        rw [ Finset.card_sdiff ] ; norm_num;
        refine' lt_of_le_of_lt ( Finset.card_le_one.mpr _ ) _ <;> norm_num;
        rcases k with ( _ | _ | k ) <;> simp_all +decide [ IMO2012Q6_step_coeffs_correct ];
        rcases h_coeffs with ⟨ a, ha, ha' ⟩ ; unfold IMO2012Q6_expand_coeffs_correct at ha' ; aesop;
    -- This contradicts the sum property that the sum of the terms is 1.
    have h_contradiction : ∑ i ∈ Finset.range coeffs.length, (1 : ℚ) / 2 ^ (4 * k - Nat.log 3 (coeffs.get! i)) = 1 := by
      convert IMO2012Q6_sum_property k coeffs h_coeffs using 1;
      refine' congr_arg _ ( List.ext_get _ _ ) <;> aesop;
    linarith

/-
There exists a coefficient with exponent strictly greater than 1.
-/
theorem IMO2012Q6_exists_exponent_gt_one (k : ℕ) (coeffs : List ℕ) (h_coeffs : coeffs ∈ IMO2012Q6_step_coeffs_correct k) :
  ∃ c ∈ coeffs, 4 * k - Nat.log 3 c > 1 := by
    by_contra h_contra;
    -- If for all `c`, `4 * k - Nat.log 3 c = 1`, then `sum (1/2^(4k - log3 c)) = sum (1/2^1) = sum (1/2) = coeffs.length * 1/2`.
    have h_sum_eq : (coeffs.map (fun c => (1 : ℚ) / 2^(4*k - Nat.log 3 c))).sum = coeffs.length * (1 / 2 : ℚ) := by
      have h_sum_eq : ∀ c ∈ coeffs, 4 * k - Nat.log 3 c = 1 := by
        exact fun c hc => le_antisymm ( le_of_not_gt fun h => h_contra ⟨ c, hc, h ⟩ ) ( IMO2012Q6_exponent_ge_one k coeffs h_coeffs c hc );
      rw [ List.sum_eq_card_nsmul ] <;> aesop;
    -- We know sum is 1.
    have h_sum_one : (coeffs.map (fun c => (1 : ℚ) / 2^(4*k - Nat.log 3 c))).sum = 1 := by
      convert IMO2012Q6_sum_property k coeffs h_coeffs using 1;
    -- But `coeffs.length = 4 * k + 1 >= 5` (since `k >= 1`).
    have h_length_ge_5 : coeffs.length = 4 * k + 1 := by
      exact?;
    rcases k with ( _ | _ | k ) <;> norm_num [ h_length_ge_5 ] at * ; nlinarith;
    linarith [ show ( k : ℚ ) ≥ 0 by positivity ]

/-
The sum of 1/3^x_i is strictly less than 2/3.
-/
theorem IMO2012Q6_sum_term_lt_two_thirds (k : ℕ) (coeffs : List ℕ) (h_coeffs : coeffs ∈ IMO2012Q6_step_coeffs_correct k) :
  (coeffs.map (fun c => (1 : ℚ) / 3^(4*k - Nat.log 3 c))).sum < 2/3 := by
    have h_sum_lt : (List.map (fun c => (1 : ℚ) / 3^(4*k - Nat.log 3 c)) coeffs).sum < (List.map (fun c => (2/3 : ℚ) * (1 : ℚ) / 2^(4*k - Nat.log 3 c)) coeffs).sum := by
      have h_sum_lt : ∀ c ∈ coeffs, (1 : ℚ) / 3^(4*k - Nat.log 3 c) ≤ (2/3 : ℚ) * (1 : ℚ) / 2^(4*k - Nat.log 3 c) := by
        intro c hc
        have h_exp : 1 ≤ 4 * k - Nat.log 3 c := by
          exact IMO2012Q6_exponent_ge_one k coeffs h_coeffs c hc
        have h_term_ineq : (1 : ℚ) / 3^(4 * k - Nat.log 3 c) ≤ (2/3) * (1 : ℚ) / 2^(4 * k - Nat.log 3 c) := by
          exact?
        exact h_term_ineq;
      obtain ⟨c, hc⟩ : ∃ c ∈ coeffs, (1 : ℚ) / 3^(4*k - Nat.log 3 c) < (2/3 : ℚ) * (1 : ℚ) / 2^(4*k - Nat.log 3 c) := by
        obtain ⟨ c, hc₁, hc₂ ⟩ := IMO2012Q6_exists_exponent_gt_one k coeffs h_coeffs;
        exact ⟨ c, hc₁, IMO2012Q6_term_strict_ineq _ ( by linarith ) ⟩;
      apply_rules [ List.sum_lt_sum ] ; aesop;
    have h_sum_eq : (List.map (fun c => (1 : ℚ) / 2^(4*k - Nat.log 3 c)) coeffs).sum = 1 := by
      convert IMO2012Q6_sum_property k coeffs h_coeffs using 1;
    simp_all +decide [ div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm, List.sum_map_mul_left ];
    convert h_sum_lt using 1 ; norm_num [ List.sum_map_mul_right ] at * ; linarith

/-
The sum of the upper bound terms is 2/3.
-/
lemma IMO2012Q6_sum_g_eq_two_thirds (k : ℕ) (coeffs : List ℕ) (h_coeffs : coeffs ∈ IMO2012Q6_step_coeffs_correct k) :
  (coeffs.map (fun c => (2/3 : ℚ) * ((1 : ℚ) / 2^(4*k - Nat.log 3 c)))).sum = 2/3 := by
    -- By linearity of summation, we can factor out the constant $2/3$ from the sum.
    have h_sum_factor : (coeffs.map (fun c => (2 : ℚ) / 3 * (1 / 2 ^ (4 * k - Nat.log 3 c)))).sum = (2 / 3 : ℚ) * (coeffs.map (fun c => (1 : ℚ) / 2 ^ (4 * k - Nat.log 3 c))).sum := by
      rw [ List.sum_map_mul_left ];
    rw [ h_sum_factor, IMO2012Q6_sum_property k coeffs h_coeffs, mul_one ]

/-
The sum of coefficients is P times the sum of f(c).
-/
lemma IMO2012Q6_sum_c_eq_P_mul_sum_f (k : ℕ) (coeffs : List ℕ) (h_coeffs : coeffs ∈ IMO2012Q6_step_coeffs_correct k) :
  (coeffs.sum : ℚ) = (3^(4*k) : ℚ) * (coeffs.map (fun c => (1 : ℚ) / 3^(4*k - Nat.log 3 c))).sum := by
    -- By definition of `IMO2012Q6_step_coeffs_correct`, each coefficient `c` in `coeffs` is a power of 3.
    have h_pow : ∀ c ∈ coeffs, ∃ exp, c = 3^exp ∧ exp ≤ 4 * k := by
      intro c hc
      have h_power : IMO2012Q6_is_power_of_3 c := by
        exact IMO2012Q6_coeffs_correct_are_powers_of_3 k coeffs h_coeffs c hc
      have h_log : Nat.log 3 c ≤ 4 * k := by
        exact?
      obtain ⟨exp, h_exp⟩ := h_power
      use exp
      aesop;
    have h_sum_eq : ∀ c ∈ coeffs, (c : ℚ) = 3^(4 * k) * (1 / 3^(4 * k - Nat.log 3 c) : ℚ) := by
      intro c hc; obtain ⟨ exp, rfl, hexp ⟩ := h_pow c hc; norm_num [ Nat.log_pow ( show 1 < 3 by norm_num ), hexp ] ;
      field_simp;
      rw [ ← pow_add, Nat.add_sub_of_le hexp ];
    have h_sum_eq : ∀ (l : List ℕ), (∀ c ∈ l, (c : ℚ) = 3^(4 * k) * (1 / 3^(4 * k - Nat.log 3 c) : ℚ)) → (l.sum : ℚ) = 3^(4 * k) * (l.map (fun c => (1 : ℚ) / 3^(4 * k - Nat.log 3 c))).sum := by
      intros l hl; induction l <;> simp_all +decide [ mul_assoc, Finset.sum_range_succ', List.sum_cons ] ;
      ring;
    exact h_sum_eq coeffs ‹_›

/-
The sum of coefficients is strictly less than 2/3 of P.
-/
theorem IMO2012Q6_sum_c_lt_two_thirds_P (k : ℕ) (coeffs : List ℕ) (h_coeffs : coeffs ∈ IMO2012Q6_step_coeffs_correct k) :
  (coeffs.sum : ℚ) < (2 / 3 : ℚ) * 3^(4*k) := by
    rw [IMO2012Q6_sum_c_eq_P_mul_sum_f k coeffs h_coeffs]
    have h_lt := IMO2012Q6_sum_term_lt_two_thirds k coeffs h_coeffs
    have h_pos : (0 : ℚ) < 3^(4*k) := pow_pos (by norm_num) (4*k)
    nlinarith

/-
C is strictly greater than 1/3 of P.
-/
theorem IMO2012Q6_C_gt_one_third_P (k : ℕ) (coeffs : List ℕ) (h_coeffs : coeffs ∈ IMO2012Q6_step_coeffs_correct k) :
  let P := 3^(4*k)
  let S := coeffs.sum
  let C := P - S
  (C : ℚ) > (1 / 3 : ℚ) * P := by
    have h_sum_c_lt_two_thirds_P : (coeffs.sum : ℚ) < (2 / 3 : ℚ) * 3^(4*k) := by
      convert IMO2012Q6_sum_c_lt_two_thirds_P k coeffs h_coeffs using 1;
    field_simp;
    rw [ Nat.cast_sub ];
    · norm_num at * ; linarith;
    · exact_mod_cast h_sum_c_lt_two_thirds_P.le.trans ( mul_le_of_le_one_left ( by positivity ) ( by norm_num ) )

/-
S_other is strictly less than 2C.
-/
theorem IMO2012Q6_S_other_lt_two_C (k : ℕ) (w : IMO2012Q6_Witness k) :
  let P := 3^(4*k)
  let S := w.coeffs.sum
  let c_j := w.coeffs.get w.j
  let C := P - S
  let S_other := S - c_j
  S_other < 2 * C := by
    -- By definition of $C$, we have $C = P - S$.
    set P := 3^(4 * k)
    set S := w.coeffs.sum
    set c_j := w.coeffs.get w.j
    set C := P - S
    set S_other := S - c_j
    have h_C : C = P - S := by
      rfl
    have h_S_other : S_other = S - c_j := by
      rfl
    have h_S_lt_two_thirds_P : S < (2 / 3 : ℚ) * P := by
      convert IMO2012Q6_sum_c_lt_two_thirds_P k w.coeffs w.h_coeffs using 1
      generalize_proofs at *; (
      norm_num +zetaDelta at *)
    have h_C_gt_one_third_P : C > (1 / 3 : ℚ) * P := by
      rw [ Nat.cast_sub ] <;> norm_num at * ; linarith [ pow_pos ( show 0 < 3 by norm_num ) ( 4 * k ) ] ;
      exact_mod_cast ( by linarith : ( S : ℚ ) ≤ P )
    have h_S_other_lt_two_C : S_other < S := by
      have h_c_j_pos : c_j > 0 := by
        have h_c_j_pos : ∀ c ∈ w.coeffs, c > 0 := by
          exact IMO2012Q6_coeffs_pos k _ w.h_coeffs |> fun h => by simpa using h;
        exact h_c_j_pos c_j (by
        exact?)
      exact Nat.sub_lt (Nat.pos_of_ne_zero (by
      exact ne_of_gt <| lt_of_lt_of_le h_c_j_pos <| List.le_sum_of_mem <| by aesop;)) h_c_j_pos
    have h_two_C_gt_two_thirds_P : 2 * C > (2 / 3 : ℚ) * P := by
      grind
    have h_final : S_other < 2 * C := by
      rw [ gt_iff_lt, div_mul_eq_mul_div, div_lt_iff₀ ] at * <;> norm_cast at * ; linarith [ Nat.sub_add_cancel <| show S ≤ P from le_of_lt <| Nat.lt_of_sub_pos <| by linarith ] ;
    exact h_final

/-
Upper bound for K'.
-/
theorem IMO2012Q6_K_prime_bound (k : ℕ) (w : IMO2012Q6_Witness k) :
  w.K' < (w.coeffs.sum - w.coeffs.get w.j) * (4 * k) := by
    -- Since `p_offsets` is a permutation of `List.range (4*k)`, each element in `p_offsets` is less than `4*k`.
    have h_p_offsets_lt : ∀ x ∈ w.p_offsets, x < 4 * k := by
      have := w.h_perm;
      exact fun x hx => List.mem_range.mp ( List.mem_permutations.mp this |> List.Perm.subset <| hx );
    have h_zip_lt : (List.zipWith (· * ·) (w.coeffs.eraseIdx w.j) w.p_offsets).sum < (w.coeffs.eraseIdx w.j).sum * (4 * k) := by
      have h_zip_lt : ∀ (l1 l2 : List ℕ), (∀ x ∈ l2, x < 4 * k) → (∀ x ∈ l1, x > 0) → l1.length = l2.length → l1 ≠ [] → (List.zipWith (· * ·) l1 l2).sum < l1.sum * (4 * k) := by
        intros l1 l2 hl2 hl1 hlen hl1_nonempty
        induction' l1 with x l1 ih generalizing l2 <;> simp_all +decide [ List.zipWith ];
        rcases l2 with ( _ | ⟨ y, l2 ⟩ ) <;> simp_all +decide [ List.zipWith ];
        by_cases hl1_empty : l1 = [] <;> simp_all +decide [ add_mul ];
        · rw [ eq_comm ] at hlen ; aesop;
        · exact add_lt_add_of_lt_of_le ( Nat.mul_lt_mul_of_pos_left hl2.1 hl1.1 ) ( le_of_lt ( ih _ hl2.2 rfl ) );
      apply h_zip_lt;
      · assumption;
      · exact fun x hx => IMO2012Q6_coeffs_pos k _ w.h_coeffs _ <| List.mem_of_mem_eraseIdx hx;
      · have := w.h_coeffs; simp_all +decide [ List.length_eraseIdx ] ;
        have := IMO2012Q6_Witness_coeffs_len k w; have := IMO2012Q6_Witness_offsets_len k w; aesop;
      · have := IMO2012Q6_Witness_coeffs_len k w; simp_all +decide ;
        rcases k with ( _ | k ) <;> simp_all +decide [ Nat.succ_eq_add_one ];
        · have := w.h_coeffs; simp_all +decide [ IMO2012Q6_step_coeffs_correct ] ;
        · aesop_cat;
    convert h_zip_lt using 2;
    · exact w.h_K' ▸ rfl;
    · rw [ List.eraseIdx_eq_take_drop_succ ];
      rw [ ← List.sum_take_add_sum_drop w.coeffs ( w.j + 1 ) ] ; simp +arith +decide [ List.sum_take_add_sum_drop ];
      exact Nat.sub_eq_of_eq_add <| by ring;

/-
3S < 2P in Nat.
-/
theorem IMO2012Q6_3S_lt_2P (k : ℕ) (coeffs : List ℕ) (h_coeffs : coeffs ∈ IMO2012Q6_step_coeffs_correct k) :
  3 * coeffs.sum < 2 * 3^(4*k) := by
    have h_rat := IMO2012Q6_sum_c_lt_two_thirds_P k coeffs h_coeffs
    rw [div_mul_eq_mul_div, lt_div_iff₀ (by norm_num)] at h_rat
    norm_cast at h_rat
    linarith

/-
Bound on m derived from the witness (final attempt).
-/
theorem IMO2012Q6_Witness_m_lt_n (k : ℕ) (n : ℕ) (w : IMO2012Q6_Witness k) (hn : n > 12 * k) :
  IMO2012Q6_Witness_m k n w < n := by
    unfold IMO2012Q6_Witness_m;
    rw [ Nat.div_lt_iff_lt_mul <| Nat.sub_pos_of_lt <| ?_ ];
    · -- By combining terms, we can factor out common factors and simplify the expression.
      have h_simplify : (w.coeffs.sum - w.coeffs.get w.j) * n + w.K' < (3 ^ (4 * k) - w.coeffs.get w.j) * n := by
        have h_simplify : w.K' < (w.coeffs.sum - w.coeffs.get w.j) * (4 * k) := by
          exact?;
        have h_simplify : w.coeffs.sum < (2 / 3 : ℚ) * 3 ^ (4 * k) := by
          convert IMO2012Q6_sum_c_lt_two_thirds_P k w.coeffs w.h_coeffs using 1;
        rw [ div_mul_eq_mul_div, lt_div_iff₀ ] at h_simplify <;> norm_cast at *;
        nlinarith [ Nat.sub_add_cancel ( show w.coeffs.get w.j ≤ w.coeffs.sum from by
                                          exact List.le_sum_of_mem ( by aesop ) ), Nat.sub_add_cancel ( show w.coeffs.get w.j ≤ 3 ^ ( 4 * k ) from by
                                                                                                                      grind ) ];
      exact lt_of_le_of_lt ( Nat.sub_le _ _ ) ( by linarith );
    · have h_log : Nat.log 3 (w.coeffs.get w.j) < 4 * k := by
        have := IMO2012Q6_exponent_ge_one k w.coeffs w.h_coeffs ( w.coeffs.get w.j ) ( by simp );
        exact Nat.lt_of_sub_pos this;
      exact Nat.lt_pow_of_log_lt ( by norm_num ) h_log

/-
k is at least 1.
-/
theorem IMO2012Q6_k_pos (k : ℕ) (coeffs : List ℕ) (h : coeffs ∈ IMO2012Q6_step_coeffs_correct k) : k ≥ 1 := by
  rcases k with ( _ | _ | k ) <;> simp_all +arith +decide [ IMO2012Q6_step_coeffs_correct ]

/-
Checking if IMO2012Q6_Witness_m_lt_n exists.
-/
#check IMO2012Q6_Witness_m_lt_n

/-
K' is strictly less than C * (n + 1).
-/
theorem IMO2012Q6_K_prime_lt_C_mul_n_plus_one (k : ℕ) (n : ℕ) (w : IMO2012Q6_Witness k) (hn : n > 12 * k) :
  w.K' < (3^(4*k) - w.coeffs.sum) * (n + 1) := by
    -- We use the bounds `K' < S_other * 4k` and `S_other < 2 * C`.
    have h_bounds : w.K' < (w.coeffs.sum - w.coeffs.get w.j) * (4 * k) ∧ (w.coeffs.sum - w.coeffs.get w.j) < 2 * (3^(4*k) - w.coeffs.sum) := by
      apply And.intro;
      · convert IMO2012Q6_K_prime_bound k w using 1;
      · convert IMO2012Q6_S_other_lt_two_C k w using 1;
    nlinarith [ Nat.zero_le ( w.coeffs.sum - w.coeffs.get w.j ) ]

/-
Algebraic lemma for the bound on m.
-/
theorem Nat.div_lt_of_lt_mul_add {n K' C S_other M : ℕ} (hn : n > 0) (hM : M = C + S_other) (hM_pos : M > 0) (hK : K' < C * (n + 1)) :
  (S_other * n + K' - C) / M < n := by
    rcases n with ( _ | n ) <;> simp_all +decide [ Nat.succ_div ];
    rw [ Nat.div_lt_iff_lt_mul <| by aesop ];
    grind

/-
Bound on m derived from the witness (proven).
-/
theorem IMO2012Q6_Witness_m_lt_n_proven (k : ℕ) (n : ℕ) (w : IMO2012Q6_Witness k) (hn : n > 12 * k) :
  IMO2012Q6_Witness_m k n w < n := by
    convert IMO2012Q6_Witness_m_lt_n k n w hn using 1

/-
Injectivity of the constructed permutation p.
-/
theorem IMO2012Q6_Witness_p_injective (k : ℕ) (n : ℕ) (w : IMO2012Q6_Witness k) (hn : n > 12 * k) :
  Function.Injective (IMO2012Q6_Witness_p k n w (IMO2012Q6_Witness_m k n w)) := by
    intro i j hop;
    by_cases hi : i = Fin.cast ( IMO2012Q6_Witness_coeffs_len k w ) w.j <;> by_cases hj : j = Fin.cast ( IMO2012Q6_Witness_coeffs_len k w ) w.j <;> simp_all +decide [ IMO2012Q6_Witness_p ];
    · have h_contra : IMO2012Q6_Witness_m k n w < n := by
        exact IMO2012Q6_Witness_m_lt_n_proven k n w hn;
      grind;
    · -- By definition of $IMO2012Q6_Witness_m$, we know that $IMO2012Q6_Witness_m k n w < n$.
      have h_m_lt_n : IMO2012Q6_Witness_m k n w < n := by
        exact IMO2012Q6_Witness_m_lt_n_proven k n w hn;
      grind;
    · -- Since $w.p_offsets$ is a permutation of the range, the equality of the offsets implies that their indices are equal.
      have h_indices_eq : (if h_lt : i < Fin.cast (IMO2012Q6_Witness_coeffs_len k w) w.j then (i : ℕ) else (i - 1 : ℕ)) = (if h_lt : j < Fin.cast (IMO2012Q6_Witness_coeffs_len k w) w.j then (j : ℕ) else (j - 1 : ℕ)) := by
        have h_indices_eq : List.Nodup w.p_offsets := by
          have := w.h_perm;
          exact List.mem_permutations.mp this |> List.Perm.nodup_iff |>.2 ( by simp +decide [ List.nodup_range ] );
        exact Classical.not_not.1 fun h => absurd ( List.nodup_iff_injective_get.mp h_indices_eq hop ) ( by aesop );
      grind

/-
The values of the constructed permutation p are within the expected range (either m or n + offset).
-/
theorem IMO2012Q6_Witness_p_range (k : ℕ) (n : ℕ) (w : IMO2012Q6_Witness k) (hn : n > 12 * k) :
  ∀ i, IMO2012Q6_Witness_p k n w (IMO2012Q6_Witness_m k n w) i ∈ insert (IMO2012Q6_Witness_m k n w) ((List.range (4 * k)).map (fun x => n + x)).toFinset := by
    intro i
    unfold IMO2012Q6_Witness_p
    simp_all +decide [ Fin.ext_iff, List.mem_map, List.mem_range ];
    refine' Classical.or_iff_not_imp_left.2 fun h => _;
    split_ifs <;> simp_all +decide [ Fin.val_inj ];
    · have := w.h_perm;
      rw [ List.mem_permutations ] at this;
      exact this.subset ( List.getElem_mem _ ) |> fun x => by simpa using x;
    · have := w.h_perm;
      rw [ List.mem_permutations ] at this;
      exact this.subset ( List.getElem_mem _ ) |> fun x => by simpa using List.mem_range.mp x;

/-
The witness values satisfy a divisibility condition derived from the modular check.
-/
def IMO2012Q6_Witness_M (k : ℕ) (w : IMO2012Q6_Witness k) : ℕ := 3^(4*k) - w.coeffs.get w.j
def IMO2012Q6_Witness_C (k : ℕ) (w : IMO2012Q6_Witness k) : ℕ := 3^(4*k) - w.coeffs.sum
def IMO2012Q6_Witness_S_other (k : ℕ) (w : IMO2012Q6_Witness k) : ℕ := w.coeffs.sum - w.coeffs.get w.j

theorem IMO2012Q6_Witness_divisible (k : ℕ) (n : ℕ) (w : IMO2012Q6_Witness k)
  (h_mod : w.K' % IMO2012Q6_Witness_M k w = (IMO2012Q6_Witness_C k w + IMO2012Q6_Witness_M k w * n - (IMO2012Q6_Witness_S_other k w * n % IMO2012Q6_Witness_M k w)) % IMO2012Q6_Witness_M k w) :
  (IMO2012Q6_Witness_S_other k w * n + w.K' - IMO2012Q6_Witness_C k w) % IMO2012Q6_Witness_M k w = 0 := by
    rw [ ← Nat.mod_add_div ( IMO2012Q6_Witness_S_other k w * n + w.K' ) ( IMO2012Q6_Witness_M k w ), ← Nat.mod_add_div ( IMO2012Q6_Witness_C k w ) ( IMO2012Q6_Witness_M k w ) ];
    simp +decide [ Nat.add_mod, Nat.mul_mod, h_mod ];
    cases le_total ( IMO2012Q6_Witness_C k w + IMO2012Q6_Witness_M k w * n ) ( IMO2012Q6_Witness_S_other k w % IMO2012Q6_Witness_M k w % IMO2012Q6_Witness_M k w * ( n % IMO2012Q6_Witness_M k w % IMO2012Q6_Witness_M k w ) % IMO2012Q6_Witness_M k w % IMO2012Q6_Witness_M k w ) <;> simp_all +decide [ ← Nat.mul_mod, ← Nat.add_mod ];
    · have h_contra : IMO2012Q6_Witness_C k w + IMO2012Q6_Witness_M k w * n ≤ IMO2012Q6_Witness_S_other k w * n % IMO2012Q6_Witness_M k w → False := by
        intro h_contra;
        have h_contra : IMO2012Q6_Witness_C k w + IMO2012Q6_Witness_M k w * n ≤ IMO2012Q6_Witness_M k w - 1 := by
          exact le_trans h_contra ( Nat.le_sub_one_of_lt ( Nat.mod_lt _ ( Nat.pos_of_ne_zero ( by
            exact Nat.sub_ne_zero_of_lt ( by
              have h_contra : w.coeffs.get w.j ≤ w.coeffs.sum := by
                exact List.le_sum_of_mem ( by simp +decide );
              exact lt_of_le_of_lt h_contra ( by exact_mod_cast IMO2012Q6_sum_c_lt_two_thirds_P k w.coeffs w.h_coeffs |> lt_of_lt_of_le <| mul_le_of_le_one_left ( by positivity ) <| by norm_num ) ) ) ) ) );
        have h_contra : IMO2012Q6_Witness_C k w > (1 / 3 : ℚ) * 3^(4 * k) := by
          convert IMO2012Q6_C_gt_one_third_P k w.coeffs w.h_coeffs using 1;
          norm_num;
        rcases n with ( _ | _ | n ) <;> norm_num at * <;> norm_cast at *;
        · norm_num [ ‹IMO2012Q6_Witness_C k w = 0› ] at h_contra;
          exact h_contra.not_le ( by positivity );
        · rw [ div_mul_eq_mul_div, div_lt_iff₀ ] at h_contra <;> norm_cast at *;
          grind;
        · rw [ div_mul_eq_mul_div, div_lt_iff₀ ] at h_contra <;> norm_cast at *;
          grind;
      exact False.elim <| h_contra ‹_›;
    · norm_num [ ← mul_tsub, Nat.add_sub_add_left, ← mul_assoc, Nat.mul_mod ]

/-
The sum of the terms excluding the special index matches the linear form involving n and K'.
-/
theorem IMO2012Q6_Witness_sum_rest (k : ℕ) (n : ℕ) (w : IMO2012Q6_Witness k) (hn : n > 12 * k) :
  let j' := Fin.cast (IMO2012Q6_Witness_coeffs_len k w) w.j
  ∑ i ∈ Finset.univ.erase j', w.coeffs.get! i * IMO2012Q6_Witness_p k n w (IMO2012Q6_Witness_m k n w) i =
  (w.coeffs.sum - w.coeffs.get! w.j) * n + w.K' := by
    have h_sum_split : ∑ i ∈ Finset.univ.erase (Fin.cast (IMO2012Q6_Witness_coeffs_len k w) w.j), w.coeffs.get! i * IMO2012Q6_Witness_p k n w (IMO2012Q6_Witness_m k n w) i = ∑ i ∈ Finset.univ.erase (Fin.cast (IMO2012Q6_Witness_coeffs_len k w) w.j), w.coeffs.get! i * n + ∑ i ∈ Finset.univ.erase (Fin.cast (IMO2012Q6_Witness_coeffs_len k w) w.j), w.coeffs.get! i * w.p_offsets.get! (if i.val < (Fin.cast (IMO2012Q6_Witness_coeffs_len k w) w.j).val then i.val else i.val - 1) := by
      rw [ ← Finset.sum_add_distrib ];
      refine' Finset.sum_congr rfl fun i hi => _;
      split_ifs <;> simp_all +decide [ IMO2012Q6_Witness_p ] ; ring!;
      · simp +decide [ Fin.lt_iff_val_lt_val, * ];
        rw [ List.getElem?_eq_getElem ] ; aesop;
      · split_ifs <;> simp_all +decide [ Fin.lt_iff_val_lt_val ] ; ring!;
        · exact False.elim <| ‹i < Fin.cast ( IMO2012Q6_Witness_coeffs_len k w ) w.j›.not_le <| Nat.le_trans ‹_› <| Nat.le_refl _;
        · rw [ mul_add, List.getElem?_eq_getElem ];
          rw [ List.getElem?_eq_getElem ];
          all_goals norm_num [ IMO2012Q6_Witness_coeffs_len, IMO2012Q6_Witness_offsets_len ] at *;
          exact Nat.lt_of_lt_of_le ( Nat.sub_lt ( Nat.pos_of_ne_zero ( by aesop ) ) zero_lt_one ) ( Nat.le_of_lt_succ ( Fin.is_lt i ) );
    have h_sum_zip : ∑ i ∈ Finset.univ.erase (Fin.cast (IMO2012Q6_Witness_coeffs_len k w) w.j), w.coeffs.get! i * w.p_offsets.get! (if i.val < (Fin.cast (IMO2012Q6_Witness_coeffs_len k w) w.j).val then i.val else i.val - 1) = ∑ i ∈ Finset.range (4 * k), (w.coeffs.eraseIdx w.j).get! i * w.p_offsets.get! i := by
      refine' Finset.sum_bij ( fun i hi => if i.val < ( Fin.cast ( IMO2012Q6_Witness_coeffs_len k w ) w.j ).val then i.val else i.val - 1 ) _ _ _ _ <;> simp +decide [ Fin.ext_iff ];
      · grind;
      · grind;
      · intro b hb;
        by_cases h : b < w.j.val;
        · use ⟨ b, by linarith [ Fin.is_lt w.j ] ⟩ ; aesop;
        · use ⟨ b + 1, by
            grind ⟩
          generalize_proofs at *;
          grind;
      · intro a ha; split_ifs <;> simp_all +decide [ Fin.ext_iff, List.getElem?_eraseIdx ] ;
        grind;
    have h_sum_zip : ∑ i ∈ Finset.range (4 * k), (w.coeffs.eraseIdx w.j).get! i * w.p_offsets.get! i = (List.zipWith (· * ·) (w.coeffs.eraseIdx w.j) w.p_offsets).sum := by
      have h_sum_zip : ∀ (l1 l2 : List ℕ), l1.length = l2.length → ∑ i ∈ Finset.range l1.length, l1.get! i * l2.get! i = (List.zipWith (· * ·) l1 l2).sum := by
        intros l1 l2 h_len
        induction' l1 with l1_head l1_tail l1_ih generalizing l2 <;> induction' l2 with l2_head l2_tail l2_ih <;> simp_all +decide [ Finset.sum_range_succ' ];
        ring;
      convert h_sum_zip _ _ _ using 2;
      · grind;
      · simp +decide [ IMO2012Q6_Witness_coeffs_len, IMO2012Q6_Witness_offsets_len ];
        grind;
    have h_sum_zip : ∑ i ∈ Finset.univ.erase (Fin.cast (IMO2012Q6_Witness_coeffs_len k w) w.j), w.coeffs.get! i * n = (w.coeffs.sum - w.coeffs.get! w.j) * n := by
      have h_sum_zip : ∑ i ∈ Finset.univ.erase (Fin.cast (IMO2012Q6_Witness_coeffs_len k w) w.j), w.coeffs.get! i * n = (∑ i ∈ Finset.range (w.coeffs.length), w.coeffs.get! i * n) - w.coeffs.get! w.j * n := by
        have h_sum_zip : ∑ i ∈ Finset.univ.erase (Fin.cast (IMO2012Q6_Witness_coeffs_len k w) w.j), w.coeffs.get! i * n = ∑ i ∈ Finset.range (w.coeffs.length), w.coeffs.get! i * n - ∑ i ∈ {Fin.cast (IMO2012Q6_Witness_coeffs_len k w) w.j}, w.coeffs.get! i * n := by
          rw [ Nat.sub_eq_of_eq_add ];
          rw [ ← Finset.sum_union ] <;> norm_num [ Finset.disjoint_singleton_right ];
          rw [ Finset.sum_range ];
          convert rfl;
          · exact Eq.symm ( IMO2012Q6_Witness_coeffs_len k w );
          · exact?;
        convert h_sum_zip using 1;
      rw [ h_sum_zip, tsub_mul ];
      simp +decide [ ← Finset.sum_mul _ _ _, List.sum_eq_foldr ];
      congr;
      induction w.coeffs <;> simp +decide [ *, Finset.sum_range_succ' ];
      ring;
    linarith [ w.h_K' ]

/-
The value m satisfies the linear equation derived from the division definition.
-/
theorem IMO2012Q6_Witness_m_eq (k : ℕ) (n : ℕ) (w : IMO2012Q6_Witness k)
  (h_mod : w.K' % IMO2012Q6_Witness_M k w = (IMO2012Q6_Witness_C k w + IMO2012Q6_Witness_M k w * n - (IMO2012Q6_Witness_S_other k w * n % IMO2012Q6_Witness_M k w)) % IMO2012Q6_Witness_M k w)
  (h_ineq : IMO2012Q6_Witness_S_other k w * n + w.K' ≥ IMO2012Q6_Witness_C k w) :
  IMO2012Q6_Witness_M k w * IMO2012Q6_Witness_m k n w = IMO2012Q6_Witness_S_other k w * n + w.K' - IMO2012Q6_Witness_C k w := by
    have h_div : IMO2012Q6_Witness_M k w ∣ (IMO2012Q6_Witness_S_other k w * n + w.K' - IMO2012Q6_Witness_C k w) := by
      have := IMO2012Q6_Witness_divisible k n w h_mod
      exact Nat.dvd_of_mod_eq_zero this
    generalize_proofs at *; (
    convert Nat.mul_div_cancel' h_div using 1) -- workaround for a known Lean issue with NOT_IMPLEMENTED_YET

/-
The witness satisfies the sum property, proven by combining the sum splitting and the linear equation for m.
-/
theorem IMO2012Q6_Witness_sum_property_corrected (k : ℕ) (n : ℕ) (w : IMO2012Q6_Witness k) (hn : n > 12 * k)
  (h_mod : w.K' % IMO2012Q6_Witness_M k w = (IMO2012Q6_Witness_C k w + IMO2012Q6_Witness_M k w * n - (IMO2012Q6_Witness_S_other k w * n % IMO2012Q6_Witness_M k w)) % IMO2012Q6_Witness_M k w)
  (h_ineq : IMO2012Q6_Witness_S_other k w * n + w.K' ≥ IMO2012Q6_Witness_C k w) :
  ∑ i : Fin (4 * k + 1), w.coeffs.get! i * IMO2012Q6_Witness_p k n w (IMO2012Q6_Witness_m k n w) i = 3^(4 * k) * IMO2012Q6_Witness_m k n w + (3^(4 * k) - w.coeffs.sum) := by
    have := IMO2012Q6_Witness_m_eq k n w h_mod h_ineq;
    have h_split_sum : ∑ i : Fin (4 * k + 1), w.coeffs.get! i * IMO2012Q6_Witness_p k n w (IMO2012Q6_Witness_m k n w) i = w.coeffs.get! w.j * IMO2012Q6_Witness_m k n w + ∑ i ∈ Finset.univ.erase (Fin.cast (IMO2012Q6_Witness_coeffs_len k w) w.j), w.coeffs.get! i * IMO2012Q6_Witness_p k n w (IMO2012Q6_Witness_m k n w) i := by
      rw [ ← Finset.sum_erase_add _ _ ( Finset.mem_univ ( Fin.cast ( IMO2012Q6_Witness_coeffs_len k w ) w.j ) ), add_comm ];
      unfold IMO2012Q6_Witness_p; aesop;
    have h_split_sum : ∑ i ∈ Finset.univ.erase (Fin.cast (IMO2012Q6_Witness_coeffs_len k w) w.j), w.coeffs.get! i * IMO2012Q6_Witness_p k n w (IMO2012Q6_Witness_m k n w) i = (w.coeffs.sum - w.coeffs.get! w.j) * n + w.K' := by
      convert IMO2012Q6_Witness_sum_rest k n w hn using 1;
    simp_all +decide [ IMO2012Q6_Witness_M, IMO2012Q6_Witness_C, IMO2012Q6_Witness_S_other ];
    rw [ eq_tsub_iff_add_eq_of_le ] at this;
    · rw [ ← this ];
      rw [ ← add_assoc, ← add_mul, Nat.add_sub_of_le ];
      exact le_trans ( List.le_sum_of_mem ( by aesop ) ) ( show w.coeffs.sum ≤ 3 ^ ( 4 * k ) from by
                                                            have := IMO2012Q6_sum_c_lt_two_thirds_P k w.coeffs w.h_coeffs;
                                                            exact_mod_cast ( by linarith [ pow_pos ( by decide : 0 < 3 ) ( 4 * k ) ] : ( w.coeffs.sum : ℚ ) ≤ 3 ^ ( 4 * k ) ) );
    · grind

/-
The sum of the other coefficients is positive because there are at least 4 other positive coefficients.
-/
theorem IMO2012Q6_Witness_S_other_pos (k : ℕ) (w : IMO2012Q6_Witness k) : IMO2012Q6_Witness_S_other k w > 0 := by
  -- By definition of $IMO2012Q6_Witness_S_other$, we have $IMO2012Q6_Witness_S_other k w = w.coeffs.sum - w.coeffs.get w.j$.
  have h_S_other_def : IMO2012Q6_Witness_S_other k w = (w.coeffs.sum : ℕ) - (w.coeffs.get! w.j) := by
    unfold IMO2012Q6_Witness_S_other; simp +decide [ Nat.sub_sub ] ;
  -- Since $w.coeffs$ has length $4k+1$, and $k \geq 1$, $S$ is the sum of at least 5 positive integers.
  have h_coeffs_pos : ∀ c ∈ w.coeffs, 0 < c := by
    exact fun c hc => IMO2012Q6_coeffs_pos k w.coeffs w.h_coeffs c hc;
  have h_coeffs_sum : ∑ c ∈ Finset.erase (Finset.range (w.coeffs.length)) w.j, w.coeffs.get! c > 0 := by
    refine' Finset.sum_pos _ _;
    · aesop;
    · rcases k with ( _ | k ) <;> simp_all +arith +decide [ Finset.card_sdiff ];
      · exact absurd ( IMO2012Q6_k_pos 0 w.coeffs w.h_coeffs ) ( by norm_num );
      · exact ⟨ 0, Finset.mem_range.mpr ( by linarith [ IMO2012Q6_Witness_coeffs_len ( k + 1 ) w ] ), 1, Finset.mem_range.mpr ( by linarith [ IMO2012Q6_Witness_coeffs_len ( k + 1 ) w ] ), by norm_num ⟩;
  have h_coeffs_sum : ∑ c ∈ Finset.erase (Finset.range (w.coeffs.length)) w.j, w.coeffs.get! c = ∑ c ∈ Finset.range (w.coeffs.length), w.coeffs.get! c - w.coeffs.get! w.j := by
    exact eq_tsub_of_add_eq <| Finset.sum_erase_add _ _ <| Finset.mem_range.mpr <| by linarith [ Fin.is_lt w.j, IMO2012Q6_Witness_coeffs_len k w ] ;
  simp_all +decide [ Finset.sum_range, List.sum ]

/-
Checking if the stricter modular check (including inequality) holds for the failures of step 1.
-/
def IMO2012Q6_mod_check_step_correct_with_ineq (k : ℕ) (n : ℕ) : Bool :=
  let coeffs_list := IMO2012Q6_step_coeffs_correct k
  let P := 3^(4*k)
  let num_offsets := 4*k
  let offsets := List.range num_offsets
  let perms := offsets.permutations
  coeffs_list.any fun coeffs =>
    let S := coeffs.sum
    let C := P - S
    (List.range coeffs.length).any fun j =>
      let c_j := coeffs.get! j
      let other_coeffs := coeffs.eraseIdx j
      let S_other := S - c_j
      let M := P - c_j
      let target := (C + M * n - (S_other * n % M)) % M
      perms.any fun p =>
        let K := (List.zipWith (· * ·) other_coeffs p).sum
        K % M == target && S_other * n + K >= C

#eval [14, 22, 38, 41, 45, 49, 50, 53, 54, 58, 62, 77, 85, 89].map (IMO2012Q6_mod_check_step_correct_with_ineq 2)

/-
Defining and evaluating the final modular check that includes the m < n condition.
-/
def IMO2012Q6_mod_check_step_correct_final (k : ℕ) (n : ℕ) : Bool :=
  let coeffs_list := IMO2012Q6_step_coeffs_correct k
  let P := 3^(4*k)
  let num_offsets := 4*k
  let offsets := List.range num_offsets
  let perms := offsets.permutations
  coeffs_list.any fun coeffs =>
    let S := coeffs.sum
    let C := P - S
    (List.range coeffs.length).any fun j =>
      let c_j := coeffs.get! j
      let other_coeffs := coeffs.eraseIdx j
      let S_other := S - c_j
      let M := P - c_j
      let target := (C + M * n - (S_other * n % M)) % M
      perms.any fun p =>
        let K := (List.zipWith (· * ·) other_coeffs p).sum
        if K % M == target && S_other * n + K >= C then
          let m := (S_other * n + K - C) / M
          m < n
        else false

#eval [14, 22, 38, 41, 45, 49, 50, 53, 54, 58, 62, 77, 85, 89].map (IMO2012Q6_mod_check_step_correct_final 2)

/-
The witness satisfies the sum property, proven by combining the sum splitting and the linear equation for m.
-/
theorem IMO2012Q6_Witness_sum_property_corrected_v2 (k : ℕ) (n : ℕ) (w : IMO2012Q6_Witness k) (hn : n > 12 * k)
  (h_mod : w.K' % IMO2012Q6_Witness_M k w = (IMO2012Q6_Witness_C k w + IMO2012Q6_Witness_M k w * n - (IMO2012Q6_Witness_S_other k w * n % IMO2012Q6_Witness_M k w)) % IMO2012Q6_Witness_M k w)
  (h_ineq : IMO2012Q6_Witness_S_other k w * n + w.K' ≥ IMO2012Q6_Witness_C k w) :
  ∑ i : Fin (4 * k + 1), w.coeffs.get! i * IMO2012Q6_Witness_p k n w (IMO2012Q6_Witness_m k n w) i = 3^(4 * k) * IMO2012Q6_Witness_m k n w + (3^(4 * k) - w.coeffs.sum) := by
    convert IMO2012Q6_Witness_sum_property_corrected k n w hn h_mod h_ineq using 1

/-
The constructed permutation p is injective provided m < n.
-/
theorem IMO2012Q6_Witness_p_injective_of_m_lt_n (k : ℕ) (n : ℕ) (w : IMO2012Q6_Witness k)
  (hm : IMO2012Q6_Witness_m k n w < n) :
  Function.Injective (IMO2012Q6_Witness_p k n w (IMO2012Q6_Witness_m k n w)) := by
    intro i j hij;
    unfold IMO2012Q6_Witness_p at hij;
    by_cases hi : i = Fin.cast ( IMO2012Q6_Witness_coeffs_len k w ) w.j <;> by_cases hj : j = Fin.cast ( IMO2012Q6_Witness_coeffs_len k w ) w.j <;> simp_all +decide;
    · linarith [ show IMO2012Q6_Witness_m k n w < n from hm ];
    · -- Since $p$ is a permutation, the indices in $p$ must be equal.
      have h_perm : List.Nodup w.p_offsets := by
        have := w.h_perm; simp_all +decide [ List.mem_permutations ] ;
        exact this.nodup_iff.mpr ( by simp +decide [ List.nodup_range ] );
      have := List.nodup_iff_injective_get.mp h_perm hij; simp_all +decide [ Fin.ext_iff ] ;
      grind

/-
If the final modular check returns true, then there exist coefficients and a permutation satisfying the required properties.
-/
def IMO2012Q6_mod_check_final_prop (k : ℕ) (n : ℕ) : Prop :=
  ∃ coeffs ∈ IMO2012Q6_step_coeffs_correct k,
    let P := 3^(4*k)
    let S := coeffs.sum
    let C := P - S
    ∃ j : Fin coeffs.length,
      let c_j := coeffs.get j
      let other_coeffs := coeffs.eraseIdx j
      let S_other := S - c_j
      let M := P - c_j
      let target := (C + M * n - (S_other * n % M)) % M
      ∃ p_offsets ∈ (List.range (4 * k)).permutations,
        let K := (List.zipWith (· * ·) other_coeffs p_offsets).sum
        K % M = target ∧ S_other * n + K >= C ∧
        let m := (S_other * n + K - C) / M
        m < n

theorem IMO2012Q6_bool_implies_prop (k : ℕ) (n : ℕ) (h : IMO2012Q6_mod_check_step_correct_final k n = true) :
  IMO2012Q6_mod_check_final_prop k n := by
    revert h;
    unfold IMO2012Q6_mod_check_step_correct_final;
    unfold IMO2012Q6_mod_check_final_prop;
    simp +decide [ List.any ];
    intros x hx x_1 hx_1 x_2 hx_2 hx_3 hx_4 hx_5;
    refine' ⟨ x, hx, ⟨ x_1, hx_1 ⟩, x_2, hx_2, _, _, _ ⟩ <;> aesop

/-
The sum of the terms excluding the special index matches the linear form involving n and K', valid for all n.
-/
theorem IMO2012Q6_Witness_sum_rest_general (k : ℕ) (n : ℕ) (w : IMO2012Q6_Witness k) :
  let j' := Fin.cast (IMO2012Q6_Witness_coeffs_len k w) w.j
  ∑ i ∈ Finset.univ.erase j', w.coeffs.get! i * IMO2012Q6_Witness_p k n w (IMO2012Q6_Witness_m k n w) i =
  (w.coeffs.sum - w.coeffs.get! w.j) * n + w.K' := by
    have h_sum : ∀ i ∈ Finset.univ.erase (Fin.cast (IMO2012Q6_Witness_coeffs_len k w) w.j), w.coeffs.get! i * IMO2012Q6_Witness_p k n w (IMO2012Q6_Witness_m k n w) i = w.coeffs.get! i * n + w.coeffs.get! i * (if i.val < w.j.val then w.p_offsets.get! i.val else w.p_offsets.get! (i.val - 1)) := by
      unfold IMO2012Q6_Witness_p; intros; split_ifs <;> ring;
      · split_ifs <;> simp_all +decide [ Fin.ext_iff ] ; ring!;
        · grind;
        · exact False.elim <| ‹¬_› <| by exact?;
      · split_ifs <;> simp_all +decide [ Fin.ext_iff, Nat.mod_eq_of_lt ];
        · exact False.elim <| ‹ ( _:Fin ( 4 * k + 1 ) ) < Fin.cast _ w.j ›.not_le <| Nat.le_trans ‹_› <| Nat.le_refl _;
        · grind;
    have h_split_sum : ∑ i ∈ Finset.univ.erase (Fin.cast (IMO2012Q6_Witness_coeffs_len k w) w.j), w.coeffs.get! i * (if i.val < w.j.val then w.p_offsets.get! i.val else w.p_offsets.get! (i.val - 1)) = List.sum (List.zipWith (· * ·) (w.coeffs.eraseIdx w.j) w.p_offsets) := by
      have h_split_sum : Finset.univ.erase (Fin.cast (IMO2012Q6_Witness_coeffs_len k w) w.j) = Finset.image (fun i : Fin (w.coeffs.length - 1) => if i.val < w.j.val then ⟨i.val, by
        exact lt_of_lt_of_le i.2 ( Nat.sub_le_of_le_add <| by linarith [ IMO2012Q6_Witness_coeffs_len k w ] )⟩ else ⟨i.val + 1, by
        grind⟩) (Finset.univ : Finset (Fin (w.coeffs.length - 1))) := by
        ext i; simp [Finset.mem_erase, Finset.mem_image];
        constructor;
        · intro hi;
          use ⟨ if i.val < w.j.val then i.val else i.val - 1, by
            grind ⟩
          generalize_proofs at *;
          split_ifs <;> simp_all +decide [ Fin.ext_iff ];
          grind;
        · rintro ⟨ a, rfl ⟩ ; split_ifs <;> simp_all +decide [ Fin.ext_iff ];
          · linarith;
          · linarith [ Fin.is_lt a ]
      generalize_proofs at *;
      rw [ h_split_sum, Finset.sum_image ];
      · have h_split_sum : ∀ (l : List ℕ) (p : List ℕ) (j : ℕ), j < l.length → List.sum (List.zipWith (· * ·) (l.eraseIdx j) p) = ∑ i ∈ Finset.range (l.length - 1), (if i < j then l.get! i else l.get! (i + 1)) * p.get! i := by
          intros l p j hj
          induction' l with hd tl ih generalizing p j;
          · contradiction;
          · rcases j with ( _ | j ) <;> simp_all +decide [ Finset.sum_range_succ' ];
            · induction' tl with hd tl ih generalizing p <;> simp_all +decide [ Finset.sum_range_succ' ];
              rcases p with ( _ | ⟨ hd', tl' ⟩ ) <;> simp_all +decide [ Finset.sum_range_succ' ];
              rw [ add_comm ];
              convert congr_arg₂ ( · + · ) ( ih tl' 0 ( Nat.zero_lt_succ _ ) ) rfl using 1;
            · rcases p with ( _ | ⟨ hd', tl' ⟩ ) <;> simp_all +decide [ Finset.sum_range_succ' ];
              rcases tl <;> simp_all +decide [ Finset.sum_range_succ' ];
              ring;
        rw [ h_split_sum ];
        · rw [ Finset.sum_range ];
          refine' Finset.sum_congr rfl fun i hi => _ ; split_ifs <;> simp +decide [ * ];
          exact Or.inr ( by linarith! );
        · exact w.j.2.trans_le ( by simp +decide [ * ] );
      · intro i hi j hj hij; simp_all +decide [ Fin.ext_iff ] ;
        grind;
    have h_sum_split : ∑ i ∈ Finset.univ.erase (Fin.cast (IMO2012Q6_Witness_coeffs_len k w) w.j), w.coeffs.get! i * IMO2012Q6_Witness_p k n w (IMO2012Q6_Witness_m k n w) i = ∑ i ∈ Finset.univ.erase (Fin.cast (IMO2012Q6_Witness_coeffs_len k w) w.j), w.coeffs.get! i * n + ∑ i ∈ Finset.univ.erase (Fin.cast (IMO2012Q6_Witness_coeffs_len k w) w.j), w.coeffs.get! i * (if i.val < w.j.val then w.p_offsets.get! i.val else w.p_offsets.get! (i.val - 1)) := by
      rw [ ← Finset.sum_add_distrib, Finset.sum_congr rfl h_sum ];
    simp_all +decide [ ← Finset.sum_mul _ _ _ ];
    congr! 2;
    · have h_sum_erase : ∑ i ∈ Finset.range (4 * k + 1), w.coeffs.get! i = w.coeffs.sum := by
        have h_sum_split : ∀ (l : List ℕ), ∑ i ∈ Finset.range l.length, l.get! i = l.sum := by
          intro l; induction l <;> simp +decide [ *, Finset.sum_range_succ' ] ;
          simp_all +decide [ add_comm, Finset.sum_range_succ' ];
        convert h_sum_split w.coeffs using 1;
        rw [ IMO2012Q6_Witness_coeffs_len ];
      convert congr_arg ( fun x : ℕ => x - w.coeffs.get! w.j ) h_sum_erase using 1;
      · simp +decide [ Finset.sum_range, Fin.cast_val_eq_self ];
        refine' eq_tsub_of_add_eq _;
        rw [ ← Finset.sum_erase_add _ _ ( Finset.mem_univ ( Fin.cast ( IMO2012Q6_Witness_coeffs_len k w ) w.j ) ), add_comm ];
        simp +decide [ add_comm, Fin.cast_val_eq_self ];
      · simp +decide [ List.get! ];
    · exact w.h_K'.symm

/-
The witness satisfies the sum property, proven by combining the sum splitting and the linear equation for m.
-/
theorem IMO2012Q6_Witness_sum_property_final (k : ℕ) (n : ℕ) (w : IMO2012Q6_Witness k)
  (h_mod : w.K' % IMO2012Q6_Witness_M k w = (IMO2012Q6_Witness_C k w + IMO2012Q6_Witness_M k w * n - (IMO2012Q6_Witness_S_other k w * n % IMO2012Q6_Witness_M k w)) % IMO2012Q6_Witness_M k w)
  (h_ineq : IMO2012Q6_Witness_S_other k w * n + w.K' ≥ IMO2012Q6_Witness_C k w) :
  ∑ i : Fin (4 * k + 1), w.coeffs.get! i * IMO2012Q6_Witness_p k n w (IMO2012Q6_Witness_m k n w) i = 3^(4 * k) * IMO2012Q6_Witness_m k n w + (3^(4 * k) - w.coeffs.sum) := by
    -- Let's split the sum into two parts: the term when $i = j'$ and the rest.
    have h_split_sum : ∑ i : Fin (4 * k + 1), w.coeffs.get! i * IMO2012Q6_Witness_p k n w (IMO2012Q6_Witness_m k n w) i = w.coeffs.get! w.j * IMO2012Q6_Witness_m k n w + ∑ i ∈ Finset.univ.erase (Fin.cast (IMO2012Q6_Witness_coeffs_len k w) w.j), w.coeffs.get! i * IMO2012Q6_Witness_p k n w (IMO2012Q6_Witness_m k n w) i := by
      rw [ ← Finset.sum_erase_add _ _ ( Finset.mem_univ ( Fin.cast ( IMO2012Q6_Witness_coeffs_len k w ) w.j ) ), add_comm ];
      unfold IMO2012Q6_Witness_p; aesop;
    -- By definition of `IMO2012Q6_Witness_m`, we know that `IMO2012Q6_Witness_M k w * IMO2012Q6_Witness_m k n w = IMO2012Q6_Witness_S_other k w * n + w.K' - IMO2012Q6_Witness_C k w`.
    have h_m_eq : IMO2012Q6_Witness_M k w * IMO2012Q6_Witness_m k n w = IMO2012Q6_Witness_S_other k w * n + w.K' - IMO2012Q6_Witness_C k w := by
      apply IMO2012Q6_Witness_m_eq k n w h_mod h_ineq;
    -- Substitute h_m_eq into the equation.
    have h_subst : w.coeffs.get! w.j * IMO2012Q6_Witness_m k n w = 3^(4*k) * IMO2012Q6_Witness_m k n w - (IMO2012Q6_Witness_S_other k w * n + w.K' - IMO2012Q6_Witness_C k w) := by
      rw [ ← h_m_eq ];
      refine' eq_tsub_of_add_eq _;
      rw [ show IMO2012Q6_Witness_M k w = 3 ^ ( 4 * k ) - w.coeffs.get w.j from rfl ] ; rw [ tsub_mul ] ; ring;
      rw [ add_comm, tsub_add_eq_add_tsub ];
      · rw [ Nat.sub_eq_of_eq_add ] ; ring!;
        simp +decide [ Fin.cast_val_eq_self ];
      · gcongr;
        have := w.h_coeffs;
        have := IMO2012Q6_coeffs_correct_are_powers_of_3 k w.coeffs this ( w.coeffs.get w.j ) ( by simp ) ; obtain ⟨ x, hx ⟩ := this; simp_all +decide [ pow_mul' ] ;
        have := IMO2012Q6_coeffs_log_bound k w.coeffs this ( w.coeffs.get w.j ) ( by simp ) ; simp_all +decide [ Nat.log_pow ] ;
        exact le_trans ( pow_le_pow_right₀ ( by decide ) this ) ( by rw [ pow_mul ] ; norm_num );
    convert congr_arg₂ ( · + · ) h_subst ( IMO2012Q6_Witness_sum_rest_general k n w ) using 1;
    unfold IMO2012Q6_Witness_C IMO2012Q6_Witness_S_other at *;
    rw [ show w.coeffs.get! w.j = w.coeffs.get w.j from ?_ ];
    · rw [ tsub_add_eq_add_tsub ];
      · grind;
      · rw [ ← h_m_eq ];
        exact Nat.mul_le_mul_right _ ( Nat.sub_le _ _ );
    · simp +decide [ List.get! ]

/-
If the final modular check property holds, then the generalized helper property holds.
-/
theorem IMO2012Q6_prop_implies_helper (k : ℕ) (n : ℕ) (h : IMO2012Q6_mod_check_final_prop k n) :
  IMO2012Q6_helper_prop_gen_correct k n := by
    -- By definition of IMO2012Q6_mod_check_final_prop, we can extract the necessary components from h.
    obtain ⟨coeffs, h_coeffs, j, p_offsets, hp_offsets, hK, h_ineq, hm⟩ := h;
    refine' ⟨ _, hm, IMO2012Q6_Witness_p k n ⟨ coeffs, h_coeffs, j, p_offsets, hp_offsets, _, rfl ⟩ ( ( ( coeffs.sum - coeffs.get j ) * n + ( List.zipWith ( · * · ) ( coeffs.eraseIdx j ) p_offsets ).sum - ( 3 ^ ( 4 * k ) - coeffs.sum ) ) / ( 3 ^ ( 4 * k ) - coeffs.get j ) ), _, _, coeffs, h_coeffs, _ ⟩;
    · exact IMO2012Q6_Witness_p_injective_of_m_lt_n _ _ _ hm;
    · intro i; unfold IMO2012Q6_Witness_p; simp +decide [ Finset.mem_insert, Finset.mem_singleton ] ;
      refine' Classical.or_iff_not_imp_left.2 fun h => _;
      split_ifs <;> simp_all +decide [ Fin.ext_iff ];
      · have := List.mem_permutations.mp hp_offsets;
        exact List.mem_range.mp ( this.subset ( List.getElem_mem _ ) );
      · have := List.mem_permutations.mp hp_offsets; simp_all +decide [ List.mem_permutations ] ;
        exact this.subset ( List.getElem_mem _ ) |> fun x => by simpa using List.mem_range.mp x;
    · convert IMO2012Q6_Witness_sum_property_final k n ⟨ coeffs, h_coeffs, j, p_offsets, hp_offsets, _, rfl ⟩ _ _ using 1;
      · convert hK using 1;
      · exact h_ineq

/-
If the modular check passes for k and n, and n is a solution, then n + 4k is a solution.
-/
def IMO2012Q6_covers (k n : ℕ) : Bool := IMO2012Q6_mod_check_step_correct_final k n

theorem IMO2012Q6_covers_implies_step (k n : ℕ) (h_covers : IMO2012Q6_covers k n = true) (h_sol : IMO2012Q6 n) : IMO2012Q6 (n + 4 * k) := by
  -- Apply the modular check property to conclude the proof.
  apply IMO2012Q6_recurrence_step_gen_correct n k h_sol (IMO2012Q6_prop_implies_helper k n (IMO2012Q6_bool_implies_prop k n h_covers))

/-
Checking the jump property: for every failure of step 1 at n, step 2 works at n-4.
-/
def IMO2012Q6_check_jump_property : Bool :=
  let failures := (List.range 702).filter (fun n => n ≥ 1 ∧ (n % 4 == 1 ∨ n % 4 == 2) ∧ ¬ IMO2012Q6_mod_check_step_correct_final 1 n)
  failures.all fun n =>
    if n ≥ 4 then IMO2012Q6_mod_check_step_correct_final 2 (n - 4)
    else false

#eval IMO2012Q6_check_jump_property

/-
Checking for failures of the modular check in a larger range to determine if they persist.
-/
def IMO2012Q6_check_failures_range (start stop : ℕ) : List ℕ :=
  (List.range (stop - start)).map (fun i => start + i) |>.filter (fun n => n ≥ 1 ∧ (n % 4 == 1 ∨ n % 4 == 2) ∧ ¬ IMO2012Q6_mod_check_step_correct_final 1 n)

#eval IMO2012Q6_check_failures_range 100 1000

/-
The jump property holds for all n in the period, as verified by computation.
-/
theorem IMO2012Q6_jump_property_proven :
  ∀ n ∈ List.range 702,
    n ≥ 1 → (n % 4 = 1 ∨ n % 4 = 2) →
    IMO2012Q6_mod_check_step_correct_final 1 n = false →
    n ≥ 4 ∧ IMO2012Q6_mod_check_step_correct_final 2 (n - 4) = true := by
      native_decide +revert

/-
Evaluating check 2 for n from 1000 to 1099.
-/
#eval (List.range 100).all (fun i => IMO2012Q6_mod_check_step_correct_final 2 (1000 + i))

/-
The coefficients generated by the step process are always positive.
-/
theorem IMO2012Q6_coeffs_pos_v2 (k : ℕ) (coeffs : List ℕ) (h : coeffs ∈ IMO2012Q6_step_coeffs_correct k) :
  ∀ c ∈ coeffs, c > 0 := by
    convert IMO2012Q6_coeffs_pos k coeffs h using 1

#eval (List.range 10).map (fun i => (IMO2012Q6_mod_check_step_correct_final 1 i, IMO2012Q6_mod_check_step_correct_final 1 (i + 702)))
#eval (List.range 10).map (fun i => (IMO2012Q6_mod_check_step_correct_final 2 i, IMO2012Q6_mod_check_step_correct_final 2 (i + 702)))

#eval IMO2012Q6_relevant_failures_list

#eval IMO2012Q6_relevant_failures_list.length

def IMO2012Q6_check_period_coverage (start : ℕ) : Bool :=
  (List.range 702).all fun i =>
    let n := start + i
    if n % 4 == 1 || n % 4 == 2 then
      IMO2012Q6_mod_check_step_correct_final 1 n || IMO2012Q6_mod_check_step_correct_final 2 n
    else true

#eval IMO2012Q6_check_period_coverage 1000

theorem IMO2012Q6_1_proof : IMO2012Q6 1 := by
  -- For the base case $n = 1$, we can choose $a_1 = 0$.
  use ![0]
  simp [IMO2012Q6]

theorem IMO2012Q6_2_proof : IMO2012Q6 2 := by
  -- We can choose $a_1 = 1$ and $a_2 = 1$.
  use ![1, 1];
  -- Let's simplify the sums for the base case $n = 2$.
  simp [Fin.sum_univ_succ, Fin.sum_univ_zero]; norm_num

def IMO2012Q6_reverse_coverage (n : ℕ) : Bool :=
  if n % 4 == 1 || n % 4 == 2 then
    let r1 := if n >= 4 then IMO2012Q6_mod_check_step_correct_final 1 (n - 4) else false
    let r2 := if n >= 8 then IMO2012Q6_mod_check_step_correct_final 2 (n - 8) else false
    r1 || r2
  else true

#eval (List.range 1000).all (fun i => IMO2012Q6_reverse_coverage (1000 + i))

def IMO2012Q6_find_reverse_coverage_failure : Option ℕ :=
  (List.range 2000).find? (fun n => n >= 4 && (n % 4 == 1 || n % 4 == 2) && ¬ IMO2012Q6_reverse_coverage n)

#eval IMO2012Q6_find_reverse_coverage_failure

/-
Definition of the periodic part of the modular check.
-/
def IMO2012Q6_mod_check_step_periodic (k : ℕ) (n : ℕ) : Bool :=
  let coeffs_list := IMO2012Q6_step_coeffs_correct k
  let P := 3^(4*k)
  let num_offsets := 4*k
  let offsets := List.range num_offsets
  let perms := offsets.permutations
  coeffs_list.any fun coeffs =>
    let S := coeffs.sum
    let C := P - S
    (List.range coeffs.length).any fun j =>
      let c_j := coeffs.get! j
      let other_coeffs := coeffs.eraseIdx j
      let S_other := S - c_j
      let M := P - c_j
      let target := (C + M * n - (S_other * n % M)) % M
      perms.any fun p =>
        let K := (List.zipWith (· * ·) other_coeffs p).sum
        K % M == target

/-
Multiplying the sum by 3^K yields an integer equation.
-/
lemma IMO2012Q6_sum_mul_pow (n : ℕ) (a : Fin n → ℕ) (K : ℕ) (hK : ∀ i, a i ≤ K) (h2 : ∑ i : Fin n, ((i : ℚ) + 1) / 3 ^ (a i) = 1) :
  ∑ i : Fin n, ((i : ℕ) + 1) * 3 ^ (K - a i) = 3 ^ K := by
    rw [ ← @Nat.cast_inj ℚ ];
    convert congr_arg ( · * ( 3 ^ K : ℚ ) ) h2 using 1 ; norm_num [ Finset.sum_mul _ _ _, div_mul_eq_mul_div ];
    · exact Finset.sum_congr rfl fun i _ => by rw [ eq_div_iff ( by positivity ) ] ; rw [ mul_assoc, ← pow_add, Nat.sub_add_cancel ( hK i ) ] ;
    · grind

/-
Reducing the integer equation modulo 2 implies that the triangular number is odd.
-/
lemma IMO2012Q6_sum_mod_2 (n : ℕ) (a : Fin n → ℕ) (K : ℕ) (h_eq : ∑ i : Fin n, ((i : ℕ) + 1) * 3 ^ (K - a i) = 3 ^ K) :
  (n * (n + 1) / 2) % 2 = 1 := by
    -- Since $3$ is odd, each term $(i + 1) * 3^(K - a i)$ is congruent to $(i + 1)$ modulo $2$.
    have h_mod : (∑ i : Fin n, ((i : ℕ) + 1) * 3 ^ (K - a i)) % 2 = (∑ i : Fin n, ((i : ℕ) + 1)) % 2 := by
      norm_num [ Finset.sum_nat_mod, Nat.mul_mod, Nat.pow_mod ];
    rw [ show ∑ i : Fin n, ( i + 1 : ℕ ) = n * ( n + 1 ) / 2 from ?_ ] at h_mod;
    · exact h_mod.symm.trans ( h_eq.symm ▸ by norm_num [ Nat.pow_mod ] );
    · convert Finset.sum_range_id ( n + 1 ) using 1 <;> simp +arith +decide [ mul_comm, Finset.sum_range, Fin.sum_univ_succ ]

/-
If the triangular number is odd, then n is 1 or 2 mod 4.
-/
lemma IMO2012Q6_n_mod_4_of_odd_triangle (n : ℕ) (h : (n * (n + 1) / 2) % 2 = 1) :
  n % 4 = 1 ∨ n % 4 = 2 := by
    rw [ ← Nat.mod_add_div n 4 ] at *; have := Nat.mod_lt n zero_lt_four; interval_cases n % 4 <;> norm_num [ Nat.add_mod, Nat.mul_mod, Nat.pow_mod, Nat.mul_div_assoc ] at *;
    · grind;
    · ring_nf at h;
      norm_num [ Nat.add_mod, Nat.add_div, Nat.mul_mod, Nat.mul_div_assoc, Nat.mul_comm ] at h

/-
Necessary condition: n = 1 or 2 mod 4.
-/
theorem IMO2012Q6_necessary_proof (n : ℕ) (h : IMO2012Q6 n) : n % 4 = 1 ∨ n % 4 = 2 := by
  -- By `IMO2012Q6_sum_mul_pow`, we have an integer equation involving powers of 3.
  obtain ⟨a, ha⟩ := h
  set K := Finset.univ.sup a with hK
  have h_eq : ∑ i : Fin n, ((i : ℕ) + 1) * 3 ^ (K - a i) = 3 ^ K := by
    have h_mul : ∑ i : Fin n, ((i : ℚ) + 1) * 3 ^ (K - a i) = 3 ^ K := by
      have h_eq : ∑ i : Fin n, ((i : ℚ) + 1) / 3 ^ (a i) = 1 := by
        convert ha.2 using 1
      convert congr_arg ( · * 3 ^ K ) h_eq using 1 <;> norm_num [ Finset.sum_mul _ _ _ ];
      exact Finset.sum_congr rfl fun i _ => by rw [ div_mul_eq_mul_div, eq_div_iff ( by positivity ) ] ; rw [ mul_assoc, ← pow_add, Nat.sub_add_cancel ( show a i ≤ K from Finset.le_sup ( f := a ) ( Finset.mem_univ i ) ) ] ;
    exact_mod_cast h_mul;
  -- By `IMO2012Q6_sum_mod_2`, this implies that n(n+1)/2 is odd.
  have h_odd : (n * (n + 1) / 2) % 2 = 1 := by
    exact?;
  exact?

/-
The jump property: for n >= 9, we can step back by 4 or 8.
-/
def IMO2012Q6_JumpProp : Prop :=
  ∀ n, n ≥ 9 → (n % 4 = 1 ∨ n % 4 = 2) →
    (IMO2012Q6_mod_check_step_correct_final 1 (n - 4) = true ∨
     IMO2012Q6_mod_check_step_correct_final 2 (n - 8) = true)

/-
Helper lemma: (n - k) % 4 = n % 4 if k is a multiple of 4.
-/
lemma IMO2012Q6_sub_mod_eq_mod (n k : ℕ) (h : n ≥ k) (h_mod : k % 4 = 0) : (n - k) % 4 = n % 4 := by
  omega

#check IMO2012Q6_JumpProp

#check IMO2012Q6_jump_property_proven

def IMO2012Q6_check_periodicity_702 (start : ℕ) (len : ℕ) : Bool :=
  (List.range len).all fun i =>
    let n := start + i
    IMO2012Q6_mod_check_step_correct_final 1 n == IMO2012Q6_mod_check_step_correct_final 1 (n + 702)

#eval IMO2012Q6_check_periodicity_702 1000 1000

/-
Checking periodicity for step 2.
-/
def IMO2012Q6_check_periodicity_702_step2 (start : ℕ) (len : ℕ) : Bool :=
  (List.range len).all fun i =>
    let n := start + i
    IMO2012Q6_mod_check_step_correct_final 2 n == IMO2012Q6_mod_check_step_correct_final 2 (n + 702)

#eval IMO2012Q6_check_periodicity_702_step2 1000 1000

/-
Checking if indices 1, 3, 4 are useless for step 1.
-/
def IMO2012Q6_check_useless_indices (k : ℕ) (useless_indices : List ℕ) : Bool :=
  let coeffs_list := IMO2012Q6_step_coeffs_correct k
  let P := 3^(4*k)
  let num_offsets := 4*k
  let offsets := List.range num_offsets
  let perms := offsets.permutations
  coeffs_list.all fun coeffs =>
    useless_indices.all fun j =>
      let c_j := coeffs.get! j
      let other_coeffs := coeffs.eraseIdx j
      let S_other := coeffs.sum - c_j
      let M := P - c_j
      let C := P - coeffs.sum
      -- We want to check if there exists ANY n and ANY p such that the condition holds.
      -- The condition is K % M == (C - S_other * n) % M.
      -- This is equivalent to K + S_other * n == C (mod M).
      -- This has a solution for n iff gcd(S_other, M) divides (C - K).
      -- So we check if for all p, gcd(S_other, M) does NOT divide (C - K).
      perms.all fun p =>
        let K := (List.zipWith (· * ·) other_coeffs p).sum
        (C - K) % (Nat.gcd S_other M) != 0

#eval IMO2012Q6_check_useless_indices 1 [1, 3, 4]

/-
Verifying the jump property computationally for a range of n.
-/
def IMO2012Q6_JumpProp_bool (n : ℕ) : Bool :=
  if n < 9 then true
  else if n % 4 == 1 || n % 4 == 2 then
    IMO2012Q6_mod_check_step_correct_final 1 (n - 4) ||
    IMO2012Q6_mod_check_step_correct_final 2 (n - 8)
  else true

#eval (List.range 2000).all fun i => IMO2012Q6_JumpProp_bool (9 + i)

/-
Base cases for n < 9.
-/
lemma IMO2012Q6_base_cases (n : ℕ) (h : n < 9) (h_mod : n % 4 = 1 ∨ n % 4 = 2) : IMO2012Q6 n := by
  interval_cases n
  · have : 0 % 4 = 0 := rfl; rw [this] at h_mod; cases h_mod <;> contradiction
  · exact IMO2012Q6_1
  · exact IMO2012Q6_2
  · have : 3 % 4 = 3 := rfl; rw [this] at h_mod; cases h_mod <;> contradiction
  · have : 4 % 4 = 0 := rfl; rw [this] at h_mod; cases h_mod <;> contradiction
  · exact IMO2012Q6_5
  · exact IMO2012Q6_6
  · have : 7 % 4 = 3 := rfl; rw [this] at h_mod; cases h_mod <;> contradiction
  · have : 8 % 4 = 0 := rfl; rw [this] at h_mod; cases h_mod <;> contradiction

/-
Conditional proof of sufficiency assuming the jump property.
-/
theorem IMO2012Q6_sufficient_assuming_jump (h_jump : IMO2012Q6_JumpProp) (n : ℕ) : n % 4 = 1 ∨ n % 4 = 2 → IMO2012Q6 n := by
  -- By definition of IMO2012Q6_JumpProp, if n ≥ 9 and (n % 4 = 1 ∨ n % 4 = 2), then either IMO2012Q6_mod_check_step_correct_final 1 (n - 4) is true or IMO2012Q6_mod_check_step_correct_final 2 (n - 8) is true.
  have h_step : ∀ n, n ≥ 9 → (n % 4 = 1 ∨ n % 4 = 2) → (IMO2012Q6_mod_check_step_correct_final 1 (n - 4) = true ∨ IMO2012Q6_mod_check_step_correct_final 2 (n - 8) = true) := by
    exact?
  generalize_proofs at *; (
  -- We proceed by induction on $n$.
  induction' n using Nat.strong_induction_on with n ih;
  by_cases hn : n < 9;
  · exact fun h => IMO2012Q6_base_cases n hn h;
  · intro hn_mod
    obtain h | h := h_step n (by linarith) hn_mod <;> simp_all +decide [ IMO2012Q6_covers ];
    · exact IMO2012Q6_covers_implies_step 1 ( n - 4 ) h ( ih _ ( Nat.sub_lt ( by linarith ) ( by linarith ) ) ( by omega ) ) |> fun h => by rwa [ show n = n - 4 + 4 by rw [ Nat.sub_add_cancel ( by linarith ) ] ] ;
    · convert IMO2012Q6_covers_implies_step 2 ( n - 8 ) h ( ih ( n - 8 ) ( Nat.sub_lt ( by linarith ) ( by linarith ) ) ( by omega ) ) using 1 ; rw [ Nat.sub_add_cancel ( by linarith ) ])

#eval IMO2012Q6_check_periodicity_702 0 100

/-
For any n < 9, if n is congruent to 1 or 2 modulo 4, then n is a solution to IMO 2012 Q6.
-/
theorem IMO2012Q6_base_cases_proven (n : ℕ) (h : n < 9) (h_mod : n % 4 = 1 ∨ n % 4 = 2) : IMO2012Q6 n := by
  exact?

/-
Check if the modular check function is periodic with period 702 for k=1 and k=2.
-/
def check_periodicity_test (k : ℕ) : Bool := (List.range 100).all fun n => IMO2012Q6_mod_check_step_correct_final k n == IMO2012Q6_mod_check_step_correct_final k (n + 702)

#eval check_periodicity_test 1
#eval check_periodicity_test 2

/-
Check if the jump property boolean function is periodic with period 702.
-/
def check_jump_prop_periodicity : Bool :=
  (List.range 100).all fun n =>
    let n := n + 9
    IMO2012Q6_JumpProp_bool n == IMO2012Q6_JumpProp_bool (n + 702)

#eval check_jump_prop_periodicity

/-
Assuming the jump property, if n is 1 or 2 mod 4, then n is a solution.
-/
theorem IMO2012Q6_sufficient_assuming_jump_proven (h_jump : IMO2012Q6_JumpProp) (n : ℕ) : n % 4 = 1 ∨ n % 4 = 2 → IMO2012Q6 n := by
  -- By definition of $IMO2012Q6$, if $n \% 4 = 1$ or $n \% 4 = 2$, then $IMO2012Q6 n$ holds.
  intro h_mod
  apply IMO2012Q6_sufficient_assuming_jump h_jump n h_mod

/-
Calculate the LCM of the moduli for k=1 and k=2.
-/
def IMO2012Q6_lcm_moduli (k : ℕ) : ℕ :=
  let coeffs_list := IMO2012Q6_step_coeffs_correct k
  let P := 3^(4*k)
  let moduli := coeffs_list.flatMap fun coeffs =>
    coeffs.map fun c => P - c
  moduli.foldr Nat.lcm 1

#eval IMO2012Q6_lcm_moduli 1
#eval IMO2012Q6_lcm_moduli 2

/-
For step 1, the term S_other * 702 is divisible by M for all coefficients.
-/
theorem IMO2012Q6_step1_divisibility (j : Fin 5) :
  let coeffs := [27, 9, 3, 1, 1]
  let c := coeffs.get j
  let M := 81 - c
  let S_other := 41 - c
  (S_other * 702) % M = 0 := by
    decide +revert

/-
If a*p is divisible by m, then adding p to n doesn't change a*n mod m.
-/
lemma IMO2012Q6_mod_add_period (a n p m : ℕ) (h : (a * p) % m = 0) : (a * (n + p)) % m = (a * n) % m := by
  simp +decide [ mul_add, Nat.add_mod, h ]

/-
For step 1 and n >= 3, the inequality S_other * n + K >= C always holds.
-/
theorem IMO2012Q6_step1_ineq1 (n : ℕ) (hn : n ≥ 3) (j : Fin 5) (p : List ℕ) :
  let coeffs := [27, 9, 3, 1, 1]
  let c := coeffs.get j
  let other_coeffs := coeffs.eraseIdx j
  let S_other := 41 - c
  let C := 40
  let K := (List.zipWith (· * ·) other_coeffs p).sum
  S_other * n + K >= C := by
    fin_cases j <;> simp +arith +decide [ * ] at *;
    · linarith [ Nat.zero_le ( List.sum ( List.zipWith ( fun x1 x2 => x1 * x2 ) [ 9, 3, 1, 1 ] p ) ) ];
    · grind;
    · linarith [ Nat.zero_le ( List.sum ( List.zipWith ( fun x1 x2 => x1 * x2 ) [ 27, 9, 1, 1 ] p ) ) ];
    · grind;
    · exact le_add_of_le_of_nonneg ( by linarith ) ( Nat.zero_le _ )

/-
For step 1 and n >= 3, the value m is strictly less than n.
-/
theorem IMO2012Q6_step1_m_lt_n (n : ℕ) (hn : n ≥ 3) (j : Fin 5) (K : ℕ) (hK : K ≤ 102) :
  let coeffs := [27, 9, 3, 1, 1]
  let c := coeffs.get j
  let M := 81 - c
  let S_other := 41 - c
  let C := 40
  (S_other * n + K - C) / M < n := by
    fin_cases j <;> norm_num at * <;> omega

/-
Simplified modular check without the inequality and m < n conditions.
-/
def IMO2012Q6_mod_check_step_simplified (k : ℕ) (n : ℕ) : Bool :=
  let coeffs_list := IMO2012Q6_step_coeffs_correct k
  let P := 3^(4*k)
  let num_offsets := 4*k
  let offsets := List.range num_offsets
  let perms := offsets.permutations
  coeffs_list.any fun coeffs =>
    let S := coeffs.sum
    let C := P - S
    (List.range coeffs.length).any fun j =>
      let c_j := coeffs.get! j
      let other_coeffs := coeffs.eraseIdx j
      let S_other := S - c_j
      let M := P - c_j
      let target := (C + M * n - (S_other * n % M)) % M
      perms.any fun p =>
        let K := (List.zipWith (· * ·) other_coeffs p).sum
        K % M == target

/-
For n >= 3, the final modular check for step 1 is equivalent to the simplified modular check.
-/
theorem IMO2012Q6_step1_equivalence (n : ℕ) (hn : n ≥ 3) :
  IMO2012Q6_mod_check_step_correct_final 1 n = IMO2012Q6_mod_check_step_simplified 1 n := by
    -- Since the inequality and m < n conditions are always true for n ≥ 3, the two modular checks are equivalent.
    have h_equiv : ∀ coeffs ∈ IMO2012Q6_step_coeffs_correct 1, ∀ j : Fin coeffs.length, ∀ p ∈ (List.range (4 * 1)).permutations, (let S := coeffs.sum; let C := 3^(4*1) - S; let c_j := coeffs.get! j; let other_coeffs := coeffs.eraseIdx j; let S_other := S - c_j; let M := 3^(4*1) - c_j; let target := (C + M * n - (S_other * n % M)) % M; let K := (List.zipWith (· * ·) other_coeffs p).sum; K % M == target) → (let S := coeffs.sum; let C := 3^(4*1) - S; let c_j := coeffs.get! j; let other_coeffs := coeffs.eraseIdx j; let S_other := S - c_j; let M := 3^(4*1) - c_j; let target := (C + M * n - (S_other * n % M)) % M; let K := (List.zipWith (· * ·) other_coeffs p).sum; S_other * n + K >= C ∧ (S_other * n + K - C) / M < n) := by
      unfold IMO2012Q6_step_coeffs_correct; simp +decide ;
      intro j p hp h; fin_cases j <;> simp +decide at h ⊢;
      · have := hp.length_eq; simp_all +arith +decide;
        rcases p with ( _ | ⟨ a, _ | ⟨ b, _ | ⟨ c, _ | ⟨ d, _ | p ⟩ ⟩ ⟩ ⟩ ) <;> simp_all +arith +decide;
        · cases hp;
        · have := hp.subset; simp_all +arith +decide;
          omega;
      · have := hp.length_eq; simp_all +arith +decide;
        rcases p with ( _ | ⟨ a, _ | ⟨ b, _ | ⟨ c, _ | ⟨ d, _ | p ⟩ ⟩ ⟩ ⟩ ) <;> simp +arith +decide at *;
        have := hp.subset ; simp_all +arith +decide;
        omega;
      · have := hp.length_eq; simp_all +arith +decide;
        rcases p with ( _ | ⟨ a, _ | ⟨ b, _ | ⟨ c, _ | ⟨ d, _ | p ⟩ ⟩ ⟩ ⟩ ) <;> simp_all +arith +decide;
        · cases hp;
        · have := hp.subset; simp_all +arith +decide;
          omega;
      · have := hp.length_eq; simp_all +arith +decide;
        rcases p with ( _ | ⟨ a, _ | ⟨ b, _ | ⟨ c, _ | ⟨ d, _ | p ⟩ ⟩ ⟩ ⟩ ) <;> simp +arith +decide at *;
        have := hp.subset ; simp_all +arith +decide;
        grind;
      · have := hp.length_eq; simp_all +arith +decide;
        rcases p with ( _ | ⟨ a, _ | ⟨ b, _ | ⟨ c, _ | ⟨ d, _ | p ⟩ ⟩ ⟩ ⟩ ) <;> simp_all +arith +decide;
        · cases hp;
        · have := hp.subset ; simp_all +arith +decide;
          omega;
    unfold IMO2012Q6_mod_check_step_simplified IMO2012Q6_mod_check_step_correct_final;
    simp +decide [ List.any_eq, List.all_eq ];
    constructor <;> rintro ⟨ coeffs, hcoeffs, j, hj, p, hp, h ⟩ <;> use coeffs, hcoeffs, j, hj, p, hp <;> specialize h_equiv coeffs hcoeffs ⟨ j, hj ⟩ p <;> aesop ( simp_config := { singlePass := true } ) ;

/-
The simplified modular check for step 1 is periodic with period 702.
-/
theorem IMO2012Q6_mod_check_step_simplified_periodic_1 (n : ℕ) :
  IMO2012Q6_mod_check_step_simplified 1 (n + 702) = IMO2012Q6_mod_check_step_simplified 1 n := by
    have h_periodic : ∀ j : Fin 5, let coeffs := [27, 9, 3, 1, 1]; let P := 3^(4*1); let c := coeffs.get j; let M := P - c; let C := P - coeffs.sum; let S_other := coeffs.sum - c; (C + M * (n + 702) - (S_other * (n + 702) % M)) % M = (C + M * n - (S_other * n % M)) % M := by
      have h_periodic : ∀ j : Fin 5, let coeffs := [27, 9, 3, 1, 1]; let P := 3^(4*1); let c := coeffs.get j; let M := P - c; let C := P - coeffs.sum; let S_other := coeffs.sum - c; (S_other * 702) % M = 0 := by
        decide +kernel;
      intro j
      simp [h_periodic j];
      zify ; norm_num [ Nat.add_mod, Nat.mul_mod ];
      rw [ Int.ofNat_sub, Int.ofNat_sub ] <;> norm_num [ Int.add_emod, Int.sub_emod, Int.mul_emod ];
      · fin_cases j <;> norm_num [ Int.subNatNat_eq_coe ] <;> ring_nf <;> norm_num [ Int.add_emod, Int.sub_emod, Int.mul_emod ];
        · grind;
        · grind;
        · grind;
        · grind;
        · grind;
      · fin_cases j <;> decide;
      · exact le_trans ( Nat.le_of_lt ( Nat.mod_lt _ ( by fin_cases j <;> decide ) ) ) ( by fin_cases j <;> norm_num <;> nlinarith );
    unfold IMO2012Q6_mod_check_step_simplified;
    unfold IMO2012Q6_step_coeffs_correct; simp +decide [ Fin.forall_fin_succ ] at *;
    simp +decide [ List.range_succ, List.permutations ] at * ; aesop ( simp_config := { decide := true } ) ;

/-
The simplified modular check for step 1 is periodic with period 702.
-/
theorem IMO2012Q6_mod_check_step_simplified_periodic_1_v2 (n : ℕ) :
  IMO2012Q6_mod_check_step_simplified 1 (n + 702) = IMO2012Q6_mod_check_step_simplified 1 n := by
    -- Apply the periodicity theorem to conclude the proof.
    apply IMO2012Q6_mod_check_step_simplified_periodic_1

/-
For n >= 3, the final modular check for step 1 is periodic with period 702.
-/
theorem IMO2012Q6_mod_check_step_correct_final_periodic_1 (n : ℕ) (hn : n ≥ 3) :
  IMO2012Q6_mod_check_step_correct_final 1 (n + 702) = IMO2012Q6_mod_check_step_correct_final 1 n := by
    -- By definition of `IMO2012Q6_mod_check_step_correct_final`, the periodicity follows from the periodicity of the simpler check.
    have h_periodic : ∀ n ≥ 3, IMO2012Q6_mod_check_step_correct_final 1 n = IMO2012Q6_mod_check_step_simplified 1 n := by
      exact?;
    rw [ h_periodic n hn, h_periodic ( n + 702 ) ( by linarith ), IMO2012Q6_mod_check_step_simplified_periodic_1_v2 ]

/-
Check if step 2 works on the shifted failures of step 1, and if it persists after a period of 702.
-/
def IMO2012Q6_check_step2_on_failures : Bool :=
  let failures := (List.range 702).filter (fun n => n ≥ 3 ∧ (n % 4 == 1 ∨ n % 4 == 2) ∧ ¬ IMO2012Q6_mod_check_step_correct_final 1 n)
  failures.all fun m =>
    let m2 := m - 4
    let check_base := IMO2012Q6_mod_check_step_correct_final 2 m2
    let check_shifted := IMO2012Q6_mod_check_step_correct_final 2 (m2 + 702)
    check_base && check_shifted

#eval IMO2012Q6_check_step2_on_failures

/-
Identify which coefficient sets in step 2 work for the failures of step 1.
-/
def IMO2012Q6_find_working_coeffs_step2 (failure_residue : ℕ) : List (List ℕ) :=
  let coeffs_list := IMO2012Q6_step_coeffs_correct 2
  let P := 3^(4*2)
  coeffs_list.filter fun coeffs =>
    let S := coeffs.sum
    let C := P - S
    (List.range coeffs.length).any fun j =>
      let c_j := coeffs.get! j
      let other_coeffs := coeffs.eraseIdx j
      let S_other := S - c_j
      let M := P - c_j
      let target := (C + M * failure_residue - (S_other * failure_residue % M)) % M
      let offsets := List.range (4*2)
      let perms := offsets.permutations
      perms.any fun p =>
        let K := (List.zipWith (· * ·) other_coeffs p).sum
        K % M == target && S_other * failure_residue + K >= C

def IMO2012Q6_analyze_failures : List (ℕ × List (List ℕ)) :=
  let failures := (List.range 702).filter (fun n => n ≥ 3 ∧ (n % 4 == 1 ∨ n % 4 == 2) ∧ ¬ IMO2012Q6_mod_check_step_correct_final 1 n)
  failures.map fun m =>
    let m2 := m - 4
    (m, IMO2012Q6_find_working_coeffs_step2 m2)

#eval IMO2012Q6_analyze_failures

/-
Check if step 2 is periodic with period 702 specifically on the indices where step 1 fails.
-/
def IMO2012Q6_check2_periodic_on_failures : Bool :=
  (List.range 100).all fun i =>
    let n := 9 + i
    if n % 4 == 1 || n % 4 == 2 then
      if ¬ IMO2012Q6_mod_check_step_correct_final 1 (n - 4) then
        IMO2012Q6_mod_check_step_correct_final 2 (n - 8) == IMO2012Q6_mod_check_step_correct_final 2 (n - 8 + 702)
      else true
    else true

#eval IMO2012Q6_check2_periodic_on_failures

/-
Check that for every failure of step 1 in the period, there exists a witness in step 2 that satisfies the periodicity condition.
-/
def IMO2012Q6_check_step2_witness_periodic : Bool :=
  (List.range 702).all fun i =>
    let n := 9 + i
    if n % 4 == 1 || n % 4 == 2 then
      if ¬ IMO2012Q6_mod_check_step_correct_final 1 (n - 4) then
        let m := n - 8
        let coeffs_list := IMO2012Q6_step_coeffs_correct 2
        let P := 3^(4*2)
        coeffs_list.any fun coeffs =>
          let S := coeffs.sum
          let C := P - S
          (List.range coeffs.length).any fun j =>
            let c_j := coeffs.get! j
            let other_coeffs := coeffs.eraseIdx j
            let S_other := S - c_j
            let M := P - c_j
            let target := (C + M * m - (S_other * m % M)) % M
            let offsets := List.range (4*2)
            let perms := offsets.permutations
            perms.any fun p =>
              let K := (List.zipWith (· * ·) other_coeffs p).sum
              if K % M == target && S_other * m + K >= C then
                let m_val := (S_other * m + K - C) / M
                if m_val < m then
                  -- Check periodicity condition
                  (S_other * 702) % M == 0
                else false
              else false
      else true
    else true

/-
For all coefficient sets in step 2, the sum is strictly less than P.
-/
theorem IMO2012Q6_step2_S_lt_P :
  ∀ coeffs ∈ IMO2012Q6_step_coeffs_correct 2, coeffs.sum < 3^(4*2) := by
    native_decide +revert

/-
Find a counterexample to the divisibility condition in step 2.
-/
def IMO2012Q6_find_step2_divisibility_counterexample : Option (List ℕ × ℕ) :=
  let coeffs_list := IMO2012Q6_step_coeffs_correct 2
  let P := 3^(4*2)
  (coeffs_list.map fun coeffs =>
    (coeffs, coeffs.find? fun c =>
      let M := P - c
      let S := coeffs.sum
      let S_other := S - c
      (S_other * 702) % M != 0)).find? (fun x => x.2.isSome) |>.map fun x => (x.1, x.2.get!)

#eval IMO2012Q6_find_step2_divisibility_counterexample

/-
If S_other < M, then (S_other * period) / M < period.
-/
theorem IMO2012Q6_step2_q_lt_period (S_other M period : ℕ) (h_lt : S_other < M) (h_period : period > 0) :
  (S_other * period) / M < period := by
    exact Nat.div_lt_of_lt_mul <| by nlinarith;

/-
Identify bad coefficient sets and check if they are useless.
-/
def IMO2012Q6_step2_bad_coeffs : List (List ℕ) :=
  let coeffs_list := IMO2012Q6_step_coeffs_correct 2
  let P := 3^(4*2)
  coeffs_list.filter fun coeffs =>
    (List.range coeffs.length).any fun j =>
      let c := coeffs.get! j
      let M := P - c
      let S := coeffs.sum
      let S_other := S - c
      (S_other * 702) % M != 0

def IMO2012Q6_check_coeffs_useless (coeffs : List ℕ) : Bool :=
  let P := 3^(4*2)
  let S := coeffs.sum
  let C := P - S
  (List.range coeffs.length).all fun j =>
    let c := coeffs.get! j
    let M := P - c
    let S_other := S - c
    if (S_other * 702) % M == 0 then true -- Not bad for this j
    else
      let other_coeffs := coeffs.eraseIdx j
      let offsets := List.range (4*2)
      let perms := offsets.permutations
      let possible_K := perms.map fun p => (List.zipWith (· * ·) other_coeffs p).sum % M
      let possible_target := (List.range M).map fun r => (C + M * r - (S_other * r % M)) % M
      -- Check if intersection is empty
      possible_K.all fun k => possible_target.all fun t => k != t

#eval IMO2012Q6_step2_bad_coeffs.length
#eval IMO2012Q6_step2_bad_coeffs.all IMO2012Q6_check_coeffs_useless

/-
Evaluate the check for periodic witnesses in step 2.
-/
#eval IMO2012Q6_check_step2_witness_periodic

/-
Boolean check for the existence of a periodic witness in step 2 for a given n.
-/
def IMO2012Q6_has_periodic_witness_step2 (n : ℕ) : Bool :=
  let coeffs_list := IMO2012Q6_step_coeffs_correct 2
  let P := 3^(4*2)
  coeffs_list.any fun coeffs =>
    let S := coeffs.sum
    let C := P - S
    (List.range coeffs.length).any fun j =>
      let c_j := coeffs.get! j
      let other_coeffs := coeffs.eraseIdx j
      let S_other := S - c_j
      let M := P - c_j
      let target := (C + M * n - (S_other * n % M)) % M
      let offsets := List.range (4*2)
      let perms := offsets.permutations
      perms.any fun p =>
        let K := (List.zipWith (· * ·) other_coeffs p).sum
        if K % M == target && S_other * n + K >= C then
          let m := (S_other * n + K - C) / M
          if m < n then
            (S_other * 702) % M == 0
          else false
        else false

/-
Definition of a periodic witness for step k and n. A witness is periodic if it satisfies the modular check, the inequalities, and the periodicity condition (S_other * 702) % M = 0.
-/
def IMO2012Q6_IsPeriodicWitness (k : ℕ) (n : ℕ) (coeffs : List ℕ) (j : Fin coeffs.length) (p : List ℕ) : Prop :=
  let P := 3^(4*k)
  let S := coeffs.sum
  let C := P - S
  let c_j := coeffs.get j
  let other_coeffs := coeffs.eraseIdx j
  let S_other := S - c_j
  let M := P - c_j
  let target := (C + M * n - (S_other * n % M)) % M
  let K := (List.zipWith (· * ·) other_coeffs p).sum
  K % M = target ∧
  S_other * n + K >= C ∧
  (S_other * n + K - C) / M < n ∧
  (S_other * 702) % M = 0

def IMO2012Q6_HasPeriodicWitness (k : ℕ) (n : ℕ) : Prop :=
  ∃ coeffs ∈ IMO2012Q6_step_coeffs_correct k,
    ∃ j : Fin coeffs.length,
      ∃ p ∈ (List.range (4*k)).permutations,
        IMO2012Q6_IsPeriodicWitness k n coeffs j p

/-
If S_other * period is divisible by M, then the target value is periodic.
-/
theorem IMO2012Q6_step2_target_eq (n period : ℕ) (C M S_other : ℕ)
  (h_div : (S_other * period) % M = 0) :
  (C + M * (n + period) - (S_other * (n + period) % M)) % M = (C + M * n - (S_other * n % M)) % M := by
    -- Since $S_other * period$ is divisible by $M$, we have $S_other * (n + period) \equiv S_other * n \pmod{M}$.
    have h_mod_eq : S_other * (n + period) % M = S_other * n % M := by
      simp +decide [ mul_add, Nat.add_mod, h_div ];
    rcases le_total ( C + M * n ) ( S_other * n % M ) with h | h <;> rcases le_total ( C + M * ( n + period ) ) ( S_other * ( n + period ) % M ) with h' | h' <;> simp +decide [ *, Nat.add_mod, Nat.mul_mod ];
    · simp_all +decide [ Nat.le_of_lt ];
    · contrapose! h;
      rcases n with ( _ | _ | n ) <;> simp +decide [ Nat.mod_eq_of_lt ] at *;
      · exact lt_of_lt_of_le ( Nat.mod_lt _ ( Nat.pos_of_ne_zero ( by aesop_cat ) ) ) ( Nat.le_add_left _ _ );
      · exact lt_of_lt_of_le ( Nat.mod_lt _ ( Nat.pos_of_ne_zero ( by aesop_cat ) ) ) ( by nlinarith );
    · simp_all +decide [ Nat.le_of_lt ];
      rw [ Nat.sub_eq_zero_of_le ];
      · rw [ Nat.zero_mod ];
      · grind;
    · simp +decide [ ← Nat.mul_mod, ← Nat.add_mod, h_mod_eq ];
      rw [ show C + M * ( n + period ) - S_other * n % M = ( C + M * n - S_other * n % M ) + M * period by rw [ tsub_add_eq_add_tsub ( by nlinarith ) ] ; ring ] ; norm_num [ Nat.add_mod, Nat.mul_mod ]

/-
Checking if the periodic witness definitions exist.
-/
#check IMO2012Q6_IsPeriodicWitness
#check IMO2012Q6_HasPeriodicWitness

/-
For every relevant failure of step 1 in the base period, there exists a periodic witness for step 2.
-/
theorem IMO2012Q6_step2_covers_failures_periodic :
  ∀ n ∈ List.range 702,
    let n := n + 9
    (n % 4 = 1 ∨ n % 4 = 2) →
    ¬ IMO2012Q6_mod_check_step_correct_final 1 (n - 4) →
    IMO2012Q6_HasPeriodicWitness 2 (n - 8) := by
      intro n hn h_mod h_not_step1
      apply Classical.byContradiction
      intro h_no_periodic_witness
      push_neg at h_no_periodic_witness
      generalize_proofs at *; (
      obtain ⟨coeffs, h_coeffs, j, h_j, p, h_p, h_periodic⟩ : ∃ coeffs ∈ IMO2012Q6_step_coeffs_correct 2,
        ∃ j : Fin coeffs.length,
          ∃ p ∈ (List.range (4*2)).permutations,
            let P := 3^(4*2)
            let S := coeffs.sum
            let C := P - S
            let c_j := coeffs.get! j
            let other_coeffs := coeffs.eraseIdx j
            let S_other := S - c_j
            let M := P - c_j
            let target := (C + M * (n + 9 - 8) - (S_other * (n + 9 - 8) % M)) % M
            let K := (List.zipWith (· * ·) other_coeffs p).sum
            K % M = target ∧ S_other * (n + 9 - 8) + K ≥ C ∧ (S_other * (n + 9 - 8) + K - C) / M < n + 9 - 8 ∧ (S_other * 702) % M = 0 := by
              native_decide +revert
      generalize_proofs at *; (
      exact h_no_periodic_witness.2 ⟨ coeffs, h_coeffs, j, h_j, p, by simpa using h_p, by simpa using h_periodic ⟩))

/-
Checking if the periodic witness definitions exist.
-/
#check IMO2012Q6_IsPeriodicWitness
#check IMO2012Q6_HasPeriodicWitness

/-
If a witness works for n and satisfies the periodicity condition, it works for n + period.
-/
theorem IMO2012Q6_step2_periodicity_implication (n : ℕ) (period : ℕ) (h_period : period = 702)
  (w : IMO2012Q6_Witness 2)
  (h_witness_valid :
    let P := 3^(4*2)
    let S := w.coeffs.sum
    let c_j := w.coeffs.get w.j
    let M := P - c_j
    let C := P - S
    let S_other := S - c_j
    let target := (C + M * n - (S_other * n % M)) % M
    w.K' % M = target ∧ S_other * n + w.K' ≥ C ∧ (S_other * n + w.K' - C) / M < n)
  (h_periodic :
    let P := 3^(4*2)
    let c_j := w.coeffs.get w.j
    let M := P - c_j
    let S := w.coeffs.sum
    let S_other := S - c_j
    (S_other * period) % M = 0) :
  let P := 3^(4*2)
  let S := w.coeffs.sum
  let c_j := w.coeffs.get w.j
  let M := P - c_j
  let C := P - S
  let S_other := S - c_j
  let n' := n + period
  let target' := (C + M * n' - (S_other * n' % M)) % M
  w.K' % M = target' ∧ S_other * n' + w.K' ≥ C ∧ (S_other * n' + w.K' - C) / M < n' := by
    refine' ⟨ _, _, _ ⟩;
    · convert h_witness_valid.1 using 1;
      exact?;
    · grind;
    · have h_q_lt_period : (w.coeffs.sum - w.coeffs.get w.j) * period / (3 ^ (4 * 2) - w.coeffs.get w.j) < period := by
        have h_S_other_lt_M : w.coeffs.sum - w.coeffs.get w.j < 3 ^ (4 * 2) - w.coeffs.get w.j := by
          have h_S_lt_P : w.coeffs.sum < 3 ^ (4 * 2) := by
            apply IMO2012Q6_step2_S_lt_P;
            cases w ; tauto;
          exact Nat.sub_lt_sub_right ( by
            exact List.le_sum_of_mem ( by simp +decide ) ) ( by
            exact h_S_lt_P );
        rw [ Nat.div_lt_iff_lt_mul ] <;> nlinarith only [ h_S_other_lt_M, h_period ];
      rw [ show ( w.coeffs.sum - w.coeffs.get w.j ) * ( n + period ) + w.K' - ( 3 ^ ( 4 * 2 ) - w.coeffs.sum ) = ( w.coeffs.sum - w.coeffs.get w.j ) * n + w.K' - ( 3 ^ ( 4 * 2 ) - w.coeffs.sum ) + ( w.coeffs.sum - w.coeffs.get w.j ) * period by
            rw [ tsub_add_eq_add_tsub ] ; ring;
            exact h_witness_valid.2.1 ];
      rw [ Nat.add_div ] <;> norm_num at *;
      · grind;
      · have h_coeff_lt_6561 : w.coeffs.sum ≤ 6561 := by
          have h_coeff_lt_6561 : w.coeffs ∈ IMO2012Q6_step_coeffs_correct 2 := by
            exact?;
          exact IMO2012Q6_step2_S_lt_P _ h_coeff_lt_6561 |> le_of_lt;
        exact lt_of_le_of_lt ( List.le_sum_of_mem ( by aesop ) ) ( lt_of_le_of_ne h_coeff_lt_6561 ( by
          have := w.h_coeffs; simp_all +decide [ IMO2012Q6_step_coeffs_correct ] ;
          have h_coeff_lt_6561 : ∀ coeffs ∈ IMO2012Q6_expand_coeffs_correct [27, 9, 3, 1, 1], coeffs.sum < 6561 := by
            native_decide +revert;
          exact ne_of_lt ( h_coeff_lt_6561 _ this ) ) )

/-
For any witness in step 2, S_other is strictly less than M.
-/
theorem IMO2012Q6_step2_S_other_lt_M (w : IMO2012Q6_Witness 2) :
  w.coeffs.sum - w.coeffs.get w.j < 3^(4*2) - w.coeffs.get w.j := by
    apply_rules [ Nat.sub_lt_sub_right ];
    · convert List.le_sum_of_mem _;
      · infer_instance;
      · exact?;
    · exact IMO2012Q6_step2_S_lt_P _ w.h_coeffs

/-
Checking if the theorem is already declared.
-/
#check IMO2012Q6_step2_periodicity_implication

/-
If n has a periodic witness for step 2, then n + 702 also has a periodic witness.
-/
theorem IMO2012Q6_periodic_witness_induction (n : ℕ) :
  IMO2012Q6_HasPeriodicWitness 2 n → IMO2012Q6_HasPeriodicWitness 2 (n + 702) := by
    rintro ⟨ coeffs, h_coeffs, j, p, hp, h_witness ⟩;
    refine' ⟨ coeffs, h_coeffs, j, p, hp, _, _, _, _ ⟩;
    · unfold IMO2012Q6_IsPeriodicWitness at h_witness;
      convert h_witness.1 using 1;
      simp +decide [ ← ZMod.natCast_eq_natCast_iff', Nat.cast_sub ( show coeffs.sum ≤ 3 ^ ( 4 * 2 ) from _ ) ];
      rw [ Nat.cast_sub, Nat.cast_sub ] <;> norm_num;
      · simp_all +decide [ ← ZMod.val_natCast, Nat.add_mod, Nat.mul_mod ];
        linear_combination' h_witness.2.2.2;
      · refine' le_trans ( Nat.le_of_lt ( Nat.mod_lt _ ( Nat.sub_pos_of_lt ( show coeffs[↑j] < 6561 from _ ) ) ) ) _;
        · have h_coeffs_lt : coeffs.sum < 6561 := by
            exact IMO2012Q6_step2_S_lt_P coeffs h_coeffs;
          exact lt_of_le_of_lt ( List.le_sum_of_mem ( by aesop ) ) h_coeffs_lt;
        · exact le_add_of_nonneg_of_le ( Nat.zero_le _ ) ( Nat.le_mul_of_pos_right _ ( Nat.pos_of_ne_zero ( by aesop_cat ) ) );
      · refine' le_trans ( Nat.le_of_lt ( Nat.mod_lt _ ( Nat.sub_pos_of_lt ( show coeffs[↑j] < 6561 from _ ) ) ) ) _;
        · have h_coeffs_lt : coeffs.sum < 6561 := by
            exact IMO2012Q6_step2_S_lt_P coeffs h_coeffs;
          exact lt_of_le_of_lt ( List.le_sum_of_mem ( by aesop ) ) h_coeffs_lt;
        · exact le_add_of_nonneg_of_le ( Nat.zero_le _ ) ( Nat.le_mul_of_pos_right _ ( Nat.succ_pos _ ) );
    · have := h_witness.2.1;
      exact le_trans this ( by nlinarith [ Nat.zero_le ( coeffs.sum - coeffs.get j ) ] );
    · refine' Nat.div_lt_of_lt_mul _;
      have := h_witness.2.2.1;
      rw [ Nat.div_lt_iff_lt_mul <| Nat.sub_pos_of_lt <| ?_ ] at this;
      · rw [ tsub_lt_iff_left ] at *;
        · have h_periodic : (coeffs.sum - coeffs.get j) * 702 < (3 ^ (4 * 2) - coeffs.get j) * 702 := by
            have h_periodic : coeffs.sum < 3 ^ (4 * 2) := by
              exact IMO2012Q6_step2_S_lt_P coeffs h_coeffs;
            exact Nat.mul_lt_mul_of_pos_right ( by rw [ tsub_lt_tsub_iff_right ( List.le_sum_of_mem ( by simp ) ) ] ; exact h_periodic ) ( by decide );
          linarith;
        · exact h_witness.2.1;
        · have := h_witness.2.1;
          exact le_trans this ( by nlinarith );
      · exact lt_of_le_of_lt ( List.le_sum_of_mem ( List.getElem_mem _ ) ) ( IMO2012Q6_step2_S_lt_P coeffs h_coeffs );
    · exact h_witness.2.2.2

/-
If a periodic witness exists, the modular check returns true.
-/
theorem IMO2012Q6_HasPeriodicWitness_implies_check (k n : ℕ) :
  IMO2012Q6_HasPeriodicWitness k n → IMO2012Q6_mod_check_step_correct_final k n = true := by
    intro h_periodic_witness_exists
    obtain ⟨coeffs, h_coeffs_valid, j, p, hp_valid, h_periodic, h_witness_valid⟩ := h_periodic_witness_exists;
    unfold IMO2012Q6_mod_check_step_correct_final;
    simp_all +decide [ Fin.cast_val_eq_self ];
    refine' ⟨ coeffs, h_coeffs_valid, j, _, p, hp_valid, _, _ ⟩ <;> aesop

/-
The modular check for step 1 is periodic with any multiple of 702.
-/
theorem IMO2012Q6_mod_check_step_correct_final_periodic_1_general (n k : ℕ) (hn : n ≥ 3) :
  IMO2012Q6_mod_check_step_correct_final 1 (n + 702 * k) = IMO2012Q6_mod_check_step_correct_final 1 n := by
    induction' k with k ih;
    · rfl;
    · rw [ Nat.mul_succ, ← add_assoc, IMO2012Q6_mod_check_step_correct_final_periodic_1 _ ( by linarith ) ] ; exact ih

/-
If n has a periodic witness for step 2, then n + 702*k also has a periodic witness.
-/
theorem IMO2012Q6_periodic_witness_induction_general (n k : ℕ) :
  IMO2012Q6_HasPeriodicWitness 2 n → IMO2012Q6_HasPeriodicWitness 2 (n + 702 * k) := by
    induction' k with k ih;
    · aesop;
    · exact fun h => by simpa only [ Nat.mul_succ, ← add_assoc ] using IMO2012Q6_periodic_witness_induction _ ( ih h ) ;

/-
The check1 failure is periodic with respect to the base mapping.
-/
theorem IMO2012Q6_check1_periodic_n_minus_4 (n : ℕ) (hn : n ≥ 9) :
  let base_n := (n - 9) % 702 + 9
  IMO2012Q6_mod_check_step_correct_final 1 (n - 4) = IMO2012Q6_mod_check_step_correct_final 1 (base_n - 4) := by
    -- By definition of `mod`, we know that `n = k * 702 + base_n`, where `k = (n - 9) / 702` and `base_n = (n - 9) % 702 + 9`.
    obtain ⟨k, base_n, hk, h_base⟩ : ∃ k base_n, n = k * 702 + base_n ∧ base_n = (n - 9) % 702 + 9 ∧ k = (n - 9) / 702 := by
      exact ⟨ ( n - 9 ) / 702, ( n - 9 ) % 702 + 9, by linarith [ Nat.mod_add_div ( n - 9 ) 702, Nat.sub_add_cancel hn ], rfl, rfl ⟩;
    convert IMO2012Q6_mod_check_step_correct_final_periodic_1_general _ k _ using 2;
    · omega;
    · omega

/-
Check if there are any failures of step 1 for n = 0 or 3 mod 4 in the range [9, 710].
-/
def IMO2012Q6_check1_failures_03_mod_4 : List ℕ :=
  (List.range 702).filterMap fun i =>
    let n := 9 + i
    if (n % 4 == 0 || n % 4 == 3) && ¬ IMO2012Q6_mod_check_step_correct_final 1 (n - 4) then
      some n
    else none

#eval IMO2012Q6_check1_failures_03_mod_4

/-
Check if all failures of step 1 in the base period are covered by a periodic witness in step 2.
-/
def IMO2012Q6_check_all_failures_covered_periodic : Bool :=
  (List.range 702).all fun i =>
    let n := 9 + i
    if ¬ IMO2012Q6_mod_check_step_correct_final 1 (n - 4) then
      IMO2012Q6_has_periodic_witness_step2 (n - 8)
    else true

#eval IMO2012Q6_check_all_failures_covered_periodic

/-
If the boolean check for a periodic witness returns true, then a periodic witness exists.
-/
theorem IMO2012Q6_bool_implies_periodic_witness (n : ℕ) :
  IMO2012Q6_has_periodic_witness_step2 n = true → IMO2012Q6_HasPeriodicWitness 2 n := by
    unfold IMO2012Q6_has_periodic_witness_step2;
    simp +zetaDelta at *;
    intro coeffs hcoeffs j hj p hp hsum hsum' hperiodic hdiv
    use coeffs, hcoeffs, ⟨j, hj⟩, p, by
      exact?
    generalize_proofs at *;
    unfold IMO2012Q6_IsPeriodicWitness; aesop;

/-
Arithmetic lemma: (a + b) - c = a + (b - c) if b >= c.
-/
lemma IMO2012Q6_sub_add_comm (a b c : ℕ) (h : b ≥ c) : (a + b) - c = a + (b - c) := by
  rw [ Nat.add_sub_assoc h ]

/-
Prove that for all failures in the period, a periodic witness exists.
-/
theorem IMO2012Q6_periodic_cover_proven :
  ∀ i ∈ List.range 702,
    let n := 9 + i
    ¬ IMO2012Q6_mod_check_step_correct_final 1 (n - 4) →
    IMO2012Q6_HasPeriodicWitness 2 (n - 8) := by
      -- By definition of `IMO2012Q6_check_all_failures_covered_periodic`, if it returns true, then for any `i` in the range 0 to 701, if there's a failure in step 1, then there's a periodic witness in step 2.
      intro i hi hfail
      have h_periodic_witness : IMO2012Q6_has_periodic_witness_step2 (9 + i - 8) = true := by
        native_decide +revert;
      exact fun _ => IMO2012Q6_bool_implies_periodic_witness _ h_periodic_witness

/-
Prove the Jump Property using the periodic cover result and induction.
-/
theorem IMO2012Q6_JumpProp_proven : IMO2012Q6_JumpProp := by
  intro n hn h_mod
  have h_base : let base_n := (n - 9) % 702 + 9; (IMO2012Q6_mod_check_step_correct_final 1 (base_n - 4)) = (IMO2012Q6_mod_check_step_correct_final 1 (n - 4)) := by
    convert IMO2012Q6_check1_periodic_n_minus_4 n hn using 1;
    simp +decide only [eq_comm];
  by_cases h : IMO2012Q6_mod_check_step_correct_final 1 (n - 4) <;> simp_all +decide [ Nat.mod_eq_of_lt ];
  have h_periodic : IMO2012Q6_HasPeriodicWitness 2 ((n - 9) % 702 + 1) := by
    convert IMO2012Q6_periodic_cover_proven ( ( n - 9 ) % 702 ) ( List.mem_range.mpr ( Nat.mod_lt _ ( by decide ) ) ) using 1;
    grind +ring;
  convert IMO2012Q6_HasPeriodicWitness_implies_check 2 ( n - 8 ) _ using 1;
  convert IMO2012Q6_periodic_witness_induction_general ( ( n - 9 ) % 702 + 1 ) ( ( n - 9 ) / 702 ) h_periodic using 1;
  omega

/-
The set of solutions to IMO 2012 Q6 is exactly the set of integers n such that n = 1 or 2 mod 4.
-/
theorem IMO2012Q6_final_iff (n : ℕ) : IMO2012Q6 n ↔ n % 4 = 1 ∨ n % 4 = 2 := by
  constructor
  · apply IMO2012Q6_necessary_proof
  · apply IMO2012Q6_sufficient_assuming_jump_proven IMO2012Q6_JumpProp_proven

/-
Prove the integer equation by multiplying the rational sum by 3^K.
-/
lemma IMO2012Q6_sum_mul_pow_proven (n : ℕ) (a : Fin n → ℕ) (K : ℕ) (hK : ∀ i, a i ≤ K) (h2 : ∑ i : Fin n, ((i : ℚ) + 1) / 3 ^ (a i) = 1) :
  ∑ i : Fin n, ((i : ℕ) + 1) * 3 ^ (K - a i) = 3 ^ K := by
    convert IMO2012Q6_sum_mul_pow n a K hK h2 using 1

/-
Prove that the triangular number is odd by reducing the equation modulo 2.
-/
lemma IMO2012Q6_sum_mod_2_proven (n : ℕ) (a : Fin n → ℕ) (K : ℕ) (h_eq : ∑ i : Fin n, ((i : ℕ) + 1) * 3 ^ (K - a i) = 3 ^ K) :
  (n * (n + 1) / 2) % 2 = 1 := by
    exact?

/-
Prove the sum identity sum_{i < n} (i + 1) = n(n+1)/2.
-/
lemma IMO2012Q6_sum_identity (n : ℕ) : ∑ i : Fin n, ((i : ℕ) + 1) = n * (n + 1) / 2 := by
  rw [Fin.sum_univ_eq_sum_range (fun i => i + 1)]
  rw [Finset.sum_add_distrib]
  rw [Finset.sum_const, Finset.card_range, nsmul_eq_mul, mul_one]
  rw [Finset.sum_range_id]
  -- n * (n - 1) / 2 + n = n * (n + 1) / 2
  -- Multiply by 2 to clear denominator
  -- 2 * (n * (n - 1) / 2 + n) = n * (n - 1) + 2n = n^2 - n + 2n = n^2 + n = n(n+1)
  -- 2 * (n * (n + 1) / 2) = n(n+1)
  -- Need to handle division carefully or use zify
  cases n
  · simp
  · simp
    -- For n.succ, we can just use algebra
    grind

/-
Prove that the triangular number is odd by reducing the equation modulo 2 (v2).
-/
lemma IMO2012Q6_sum_mod_2_proven_v2 (n : ℕ) (a : Fin n → ℕ) (K : ℕ) (h_eq : ∑ i : Fin n, ((i : ℕ) + 1) * 3 ^ (K - a i) = 3 ^ K) :
  (n * (n + 1) / 2) % 2 = 1 := by
    -- Apply the lemma that states if the sum of (i+1)*3^(K-a_i) equals 3^K, then the triangular number is odd.
    apply IMO2012Q6_sum_mod_2 n a K h_eq

/-
Prove that the triangular number is odd by reducing the equation modulo 2 (v3).
-/
lemma IMO2012Q6_sum_mod_2_proven_v3 (n : ℕ) (a : Fin n → ℕ) (K : ℕ) (h_eq : ∑ i : Fin n, ((i : ℕ) + 1) * 3 ^ (K - a i) = 3 ^ K) :
  (n * (n + 1) / 2) % 2 = 1 := by
    -- Apply the lemma that states if the sum of (i+1)*3^(K-a i) equals 3^K, then (n*(n+1)/2) % 2 = 1.
    apply IMO2012Q6_sum_mod_2_proven_v2 n a K h_eq

/-
Prove that if the triangular number is odd, then n is 1 or 2 mod 4.
-/
lemma IMO2012Q6_n_mod_4_of_odd_triangle_proven (n : ℕ) (h : (n * (n + 1) / 2) % 2 = 1) :
  n % 4 = 1 ∨ n % 4 = 2 := by
    rw [ ← Nat.mod_add_div n 4 ] at *; have := Nat.mod_lt n zero_lt_four; interval_cases n % 4 <;> norm_num [ Nat.add_mod, Nat.mul_mod, Nat.add_div ] at *;
    · norm_num [ mul_assoc, Nat.mul_div_assoc ] at h;
      omega;
    · grind

/-
Prove that if the triangular number is odd, then n is 1 or 2 mod 4 (v2).
-/
lemma IMO2012Q6_n_mod_4_of_odd_triangle_proven_v2 (n : ℕ) (h : (n * (n + 1) / 2) % 2 = 1) :
  n % 4 = 1 ∨ n % 4 = 2 := by
    rw [ ← Nat.mod_add_div ( n * ( n + 1 ) ) 4 ] at h; norm_num [ Nat.add_mod, Nat.mul_mod, Nat.pow_mod ] at h ⊢; ring_nf at h ⊢; norm_num [ Nat.add_mod, Nat.mul_mod ] at h ⊢; have := Nat.mod_lt n zero_lt_four; interval_cases n % 4 <;> norm_num at h ⊢;
    · grind;
    · grind

/-
Prove the necessary condition using the established lemmas.
-/
theorem IMO2012Q6_necessary_condition_proven (n : ℕ) (h : IMO2012Q6 n) : n % 4 = 1 ∨ n % 4 = 2 := by
  rcases h with ⟨a, h1, h2⟩
  let K := Finset.sup Finset.univ a
  have hK : ∀ i, a i ≤ K := fun i => Finset.le_sup (Finset.mem_univ i)
  have h_eq_int : ∑ i : Fin n, ((i : ℕ) + 1) * 3 ^ (K - a i) = 3 ^ K := by
    apply IMO2012Q6_sum_mul_pow_proven n a K hK h2
  have h_odd : (n * (n + 1) / 2) % 2 = 1 := by
    apply IMO2012Q6_sum_mod_2_proven_v3 n a K h_eq_int
  apply IMO2012Q6_n_mod_4_of_odd_triangle_proven_v2 n h_odd

/-
Prove the base cases for n < 9.
-/
theorem IMO2012Q6_base_cases_proven_v2 (n : ℕ) (h : n < 9) (h_mod : n % 4 = 1 ∨ n % 4 = 2) : IMO2012Q6 n := by
  interval_cases n
  · -- n = 0
    contradiction
  · -- n = 1
    use (fun _ => 0)
    simp
  · -- n = 2
    use (fun _ => 1)
    simp; ring
  · -- n = 3
    norm_num at h_mod
  · -- n = 4
    norm_num at h_mod
  · -- n = 5
    use ![2, 2, 2, 3, 3]
    constructor
    · native_decide
    · native_decide
  · -- n = 6
    use ![2, 2, 3, 3, 3, 3]
    constructor
    · native_decide
    · native_decide
  · -- n = 7
    norm_num at h_mod
  · -- n = 8
    norm_num at h_mod

/-
Prove sufficiency using the jump property and strong induction (v2).
-/
theorem IMO2012Q6_sufficient_assuming_jump_proven_v2 (h_jump : IMO2012Q6_JumpProp) (n : ℕ) : n % 4 = 1 ∨ n % 4 = 2 → IMO2012Q6 n := by
  exact?

/-
Check existence of key theorems.
-/
#check IMO2012Q6_sufficient_assuming_jump_proven_v2
#check IMO2012Q6_necessary_condition_proven
#check IMO2012Q6_JumpProp_proven

/-
The final theorem stating that n is a solution iff n is 1 or 2 mod 4, using the fully proven components.
-/
theorem IMO2012Q6_solution (n : ℕ) : IMO2012Q6 n ↔ n % 4 = 1 ∨ n % 4 = 2 := by
  constructor
  · apply IMO2012Q6_necessary_condition_proven
  · apply IMO2012Q6_sufficient_assuming_jump_proven_v2 IMO2012Q6_JumpProp_proven
